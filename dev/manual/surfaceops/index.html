<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Surface-grid operations · ImmersedLayers.jl</title><meta name="title" content="Surface-grid operations · ImmersedLayers.jl"/><meta property="og:title" content="Surface-grid operations · ImmersedLayers.jl"/><meta property="twitter:title" content="Surface-grid operations · ImmersedLayers.jl"/><meta name="description" content="Documentation for ImmersedLayers.jl."/><meta property="og:description" content="Documentation for ImmersedLayers.jl."/><meta property="twitter:description" content="Documentation for ImmersedLayers.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ImmersedLayers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../caches/">Immersed layer caches</a></li><li class="is-active"><a class="tocitem" href>Surface-grid operations</a><ul class="internal"><li><a class="tocitem" href="#Basic-regularization-and-interpolation"><span>Basic regularization and interpolation</span></a></li><li><a class="tocitem" href="#A-double-layer"><span>A double layer</span></a></li><li><a class="tocitem" href="#A-curl-layer"><span>A curl layer</span></a></li><li><a class="tocitem" href="#Masks"><span>Masks</span></a></li><li><a class="tocitem" href="#Surface-grid-operator-functions"><span>Surface-grid operator functions</span></a></li></ul></li><li><a class="tocitem" href="../multbodies/">Multiple bodies</a></li><li><a class="tocitem" href="../gridops/">Grid operations</a></li><li><a class="tocitem" href="../helmholtz/">Helmholtz decomposition</a></li><li><a class="tocitem" href="../matrices/">Matrix operators</a></li><li><a class="tocitem" href="../dirichlet/">A Dirichlet Poisson problem</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li></ul></li><li><span class="tocitem">Setting up PDEs</span><ul><li><a class="tocitem" href="../problems/">Problems and the system</a></li><li><a class="tocitem" href="../neumann/">Poisson with Neumann conditions</a></li><li><a class="tocitem" href="../stokes/">Stokes flow</a></li><li><a class="tocitem" href="../heatconduction/">Setting up a time-varying PDE</a></li><li><a class="tocitem" href="../heatconduction-unbounded/">A time-varying PDE with forcing</a></li><li><a class="tocitem" href="../heatconduction-neumann/">A time-varying PDE with Neumann conditions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Basics</a></li><li class="is-active"><a href>Surface-grid operations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Surface-grid operations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaIBPM/ImmersedLayers.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/main/test/literate/surfaceops.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Surface-grid-operations"><a class="docs-heading-anchor" href="#Surface-grid-operations">Surface-grid operations</a><a id="Surface-grid-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Surface-grid-operations" title="Permalink"></a></h1><p>Here, we will discuss the various surface-grid operators available in the package. We will start by generating the cache, just as we did in <a href="../caches/#Immersed-layer-caches">Immersed layer caches</a></p><pre><code class="language-julia hljs">using ImmersedLayers
using Plots
using LinearAlgebra</code></pre><h3 id="Set-up-the-grid,-shape,-and-cache"><a class="docs-heading-anchor" href="#Set-up-the-grid,-shape,-and-cache">Set up the grid, shape, and cache</a><a id="Set-up-the-grid,-shape,-and-cache-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-the-grid,-shape,-and-cache" title="Permalink"></a></h3><p>We do this just as we did in <a href="../caches/#Immersed-layer-caches">Immersed layer caches</a></p><pre><code class="language-julia hljs">Δx = 0.01
Lx = 4.0
xlim = (-Lx/2,Lx/2)
ylim = (-Lx/2,Lx/2)
g = PhysicalGrid(xlim,ylim,Δx)
RadC = 1.0
Δs = 1.4*cellsize(g)
body = Circle(RadC,Δs)
cache = SurfaceScalarCache(body,g,scaling=GridScaling)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Surface cache with scaling of type GridScaling
  448 point data of type ScalarData{448, Float64, Vector{Float64}}
  Grid data of type Nodes{Primal, 408, 404, Float64, Matrix{Float64}}
</code></pre><h2 id="Basic-regularization-and-interpolation"><a class="docs-heading-anchor" href="#Basic-regularization-and-interpolation">Basic regularization and interpolation</a><a id="Basic-regularization-and-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-regularization-and-interpolation" title="Permalink"></a></h2><p>Let&#39;s perform an example in which we regularize the x coordinate of the surface points onto the grid. We can get the surface coordinates by using the <a href="../caches/#ImmersedLayers.points-Tuple{BasicILMCache}"><code>points</code></a> function. This can be applied either to <code>body</code> directly or to the <code>cache</code>. As for any <code>VectorData</code> type, the components of <code>pts</code> are <code>pts.u</code> and <code>pts.v</code>.</p><pre><code class="language-julia hljs">pts = points(cache);</code></pre><p>Now, we set up some blank grid data on which to regularize onto</p><pre><code class="language-julia hljs">gx = zeros_grid(cache);</code></pre><p>Now regularize. We will time it to show that it is fast and memory-efficient:</p><pre><code class="language-julia hljs">@time regularize!(gx,pts.u,cache);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">  0.001257 seconds (35.97 k allocations: 562.078 KiB)</code></pre><p>Let&#39;s plot this to look at it. This also gives us a chance to highlight the plot recipe for grid data associated with the cache, which is achieved by simply supplying the cache to the <code>plot</code> function in <code>Plots.jl</code>. By default, this plots the immersed points, as well, but this can be suppressed by adding the keyword <code>layers=false</code>.</p><pre><code class="language-julia hljs">plot(gx,cache)</code></pre><img src="06760451.svg" alt="Example block output"/><p>This shows how the regularization spreads the data over a couple of cells around the surface. In the parlance of potential theory, this is a <strong>single layer</strong>. If we wish to interpolate, then we do so with the [<code>interpolate!</code>] function. For example, suppose we have a uniform field that we wish to interpolate:</p><pre><code class="language-julia hljs">oc = 2.5*ones_grid(cache)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Nodes{Primal, 408, 404, Float64, Matrix{Float64}} data
Printing in grid orientation (lower left is (1,1))
403×407 Matrix{Float64}:
 2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5  …  2.5  2.5  2.5  2.5  2.5  2.5  2.5
 2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5     2.5  2.5  2.5  2.5  2.5  2.5  2.5
 2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5     2.5  2.5  2.5  2.5  2.5  2.5  2.5
 2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5     2.5  2.5  2.5  2.5  2.5  2.5  2.5
 2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5     2.5  2.5  2.5  2.5  2.5  2.5  2.5
 2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5  …  2.5  2.5  2.5  2.5  2.5  2.5  2.5
 2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5     2.5  2.5  2.5  2.5  2.5  2.5  2.5
 2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5     2.5  2.5  2.5  2.5  2.5  2.5  2.5
 2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5     2.5  2.5  2.5  2.5  2.5  2.5  2.5
 2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5     2.5  2.5  2.5  2.5  2.5  2.5  2.5
 ⋮                        ⋮              ⋱  ⋮                        ⋮    
 2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5     2.5  2.5  2.5  2.5  2.5  2.5  2.5
 2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5  …  2.5  2.5  2.5  2.5  2.5  2.5  2.5
 2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5     2.5  2.5  2.5  2.5  2.5  2.5  2.5
 2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5     2.5  2.5  2.5  2.5  2.5  2.5  2.5
 2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5     2.5  2.5  2.5  2.5  2.5  2.5  2.5
 2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5     2.5  2.5  2.5  2.5  2.5  2.5  2.5
 2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5  …  2.5  2.5  2.5  2.5  2.5  2.5  2.5
 2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5     2.5  2.5  2.5  2.5  2.5  2.5  2.5
 2.5  2.5  2.5  2.5  2.5  2.5  2.5  2.5     2.5  2.5  2.5  2.5  2.5  2.5  2.5</code></pre><p>Now set up some surface data to receive the interpolated data, and interpolate:</p><pre><code class="language-julia hljs">f = zeros_surface(cache);
interpolate!(f,oc,cache)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">448 points of scalar-valued Float64 data
448-element Vector{Float64}:
 2.5000000000000004
 2.5
 2.4999999999999982
 2.4999999999999987
 2.5
 2.499999999999998
 2.4999999999999987
 2.4999999999999982
 2.4999999999999987
 2.4999999999999987
 ⋮
 2.499999999999999
 2.4999999999999996
 2.4999999999999987
 2.4999999999999987
 2.4999999999999982
 2.499999999999999
 2.499999999999999
 2.499999999999999
 2.4999999999999996</code></pre><p>It is clear that the interpolation preserves the value of the field. This is also true for linearly varying fields, since the DDF is built to ensure this. Let&#39;s try this, using the <span>$x$</span> coordinate of the grid. Here, we use the <code>coordinates</code> function of <code>CartesianGrids.jl</code>, which gets the coordinates of the grid, and set the values of grid data to the <span>$x$</span> coordinate. We interpolate and plot, comparing to the actual <span>$x$</span> coordinate of the points on the body:</p><pre><code class="language-julia hljs">xg = x_grid(cache)
interpolate!(f,xg,cache)
plot(f,cache,ylim=(-2,2),label=&quot;Interpolated from grid&quot;,ylabel=&quot;x&quot;,xlabel=&quot;arclength&quot;)
plot!(pts.u,cache,label=&quot;Actual body coordinate&quot;,legend=:true)</code></pre><img src="9199bf4e.svg" alt="Example block output"/><h2 id="A-double-layer"><a class="docs-heading-anchor" href="#A-double-layer">A double layer</a><a id="A-double-layer-1"></a><a class="docs-heading-anchor-permalink" href="#A-double-layer" title="Permalink"></a></h2><p>Now we will generate a double layer. Mathematically, this takes the form</p><p class="math-container">\[D_s f = \nabla\cdot \left( \delta(\chi) \mathbf{n} f \right)\]</p><p>for some scalar data <span>$f$</span> on the surface. (See <a href="../../#Background">Background</a> for an example.) Notice that it maps scalar data on the surface (<span>$f$</span>) to scalar data in space. So to calculate this using our discrete tools, we set up some grid data to receive the result. Then, we use the function <a href="#ImmersedLayers.surface_divergence!"><code>surface_divergence!</code></a> to compute the double layer. Here, we will demonstrate this on the <span>$y$</span> coordinate of the surface points:</p><pre><code class="language-julia hljs">dl = zeros_grid(cache)
surface_divergence!(dl,pts.v,cache)
plot(dl,cache)</code></pre><img src="64d4cf43.svg" alt="Example block output"/><p>If the surface data are vectors, <span>$\mathbf{f}$</span>, then this operation is a little different:</p><p class="math-container">\[D_s \mathbf{f} = \nabla\cdot \left[\delta(\chi) \left(  \mathbf{n} \mathbf{f} + \mathbf{f} \mathbf{n} \right) \right]\]</p><p>This maps <span>$\mathbf{f}$</span> to a vector field. We use this in conjunction with a cache generated with <a href="../caches/#ImmersedLayers.SurfaceVectorCache"><code>SurfaceVectorCache</code></a>.</p><p>The transpose of the double layer, <span>$D_s$</span>, is the operation</p><p class="math-container">\[G_s u = \mathbf{n}\cdot \delta^{T}(\chi) \nabla u\]</p><p>for some scalar field data <span>$u$</span>. This operation computes the gradient of the field data, interpolates this gradient onto the surface, and obtains the normal component of that surface data. As such, it represents an important tool for computing the normal derivative of field data on a surface. In the package, we use <a href="#ImmersedLayers.surface_grad!"><code>surface_grad!</code></a> for this operation.</p><p>The vector field version of this is</p><p class="math-container">\[G_s \mathbf{u} = \mathbf{n}\cdot \delta^{T}(\chi) (\nabla \mathbf{u} + \nabla^{T} \mathbf{u})\]</p><p>which maps vector field data <span>$\mathbf{u}$</span> to vector-valued surface data.</p><h2 id="A-curl-layer"><a class="docs-heading-anchor" href="#A-curl-layer">A curl layer</a><a id="A-curl-layer-1"></a><a class="docs-heading-anchor-permalink" href="#A-curl-layer" title="Permalink"></a></h2><p>We also sometimes need to take the curl of the regularized surface data,</p><p class="math-container">\[C_s f = \nabla\times \left( \delta(\chi) \mathbf{n} f \right)\]</p><p>For this, we use the <a href="#ImmersedLayers.surface_curl!"><code>surface_curl!</code></a> operator. Let&#39;s demonstrate this on a uniform field on the surface.</p><pre><code class="language-julia hljs">gc = zeros_gridcurl(cache)
f = ones_surface(cache)
surface_curl!(gc,f,cache)
plot(gc,cache)</code></pre><img src="5ddd1210.svg" alt="Example block output"/><p>The continuous version of this operation is actually zero. It&#39;s not quite zero in discrete form. However, its norm is much smaller than that of the double layer.</p><pre><code class="language-julia hljs">norm(gc,cache)/norm(dl,cache)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.056709335671267014</code></pre><p>Finally, a pair of operations that are used in support of the previous ones, or occasionally on their own, are</p><p class="math-container">\[R_n f = \delta(\chi)\mathbf{n}\circ f\]</p><p>for scalar surface data <span>$f$</span>, which maps to a vector field, effectively a field of doublet strengths; and its transpose</p><p class="math-container">\[R_n^T \mathbf{u} = \mathbf{n}\cdot \delta^{T}(\chi)\mathbf{u}\]</p><p>which maps vector field data <span>$\mathbf{u}$</span> to a scalar surface field, the normal component of the vector field on the surface. These are provided by <a href="#ImmersedLayers.regularize_normal!"><code>regularize_normal!</code></a> and <a href="#ImmersedLayers.normal_interpolate!"><code>normal_interpolate!</code></a>, respectively.</p><h2 id="Masks"><a class="docs-heading-anchor" href="#Masks">Masks</a><a id="Masks-1"></a><a class="docs-heading-anchor-permalink" href="#Masks" title="Permalink"></a></h2><p>Masks are grid data that take the value 1 in one region (e.g., the interior of a surface) and 0 in the other (e.g., the exterior). The functions <a href="#ImmersedLayers.mask"><code>mask</code></a> and <a href="#ImmersedLayers.complementary_mask"><code>complementary_mask</code></a> achieve this</p><pre><code class="language-julia hljs">m = mask(cache)
cm = complementary_mask(cache)
plot(
   surface(m,cache,layers=false),
   surface(cm,cache,layers=false)
   )</code></pre><img src="f2b42772.svg" alt="Example block output"/><p>One can apply a mask to some grid data by multiplying it, using, e.g., the <code>product!</code> function in <code>CartesianGrids.jl</code>. Let&#39;s demonstrate that with the grid data of <span>$x$</span> coordinates:</p><pre><code class="language-julia hljs">xmask = zeros_grid(cache)
xcmask = zeros_grid(cache)
product!(xmask,xg,m)
product!(xcmask,xg,cm)
plot(
 plot(xmask,cache),
 plot(xcmask,cache)
 )</code></pre><img src="2c653163.svg" alt="Example block output"/><p>The mask and complementary mask effectively partition the field into two parts. We can also apply masks in place, using <a href="#ImmersedLayers.mask!"><code>mask!</code></a> and <a href="#ImmersedLayers.complementary_mask!"><code>complementary_mask!</code></a>:</p><pre><code class="language-julia hljs">xmask .= xg
mask!(xmask,cache)
plot(xmask,cache)</code></pre><img src="855ed54f.svg" alt="Example block output"/><h2 id="Surface-grid-operator-functions"><a class="docs-heading-anchor" href="#Surface-grid-operator-functions">Surface-grid operator functions</a><a id="Surface-grid-operator-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Surface-grid-operator-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.regularize!" href="#ImmersedLayers.regularize!"><code>ImmersedLayers.regularize!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">regularize!(s::Nodes{Primal},f::ScalarData,cache::BasicILMCache)
regularize!(s::Nodes{Primal},f::ScalarData,sys::ILMSystem)</code></pre><p>The operation <span>$s = R_c f$</span>, which regularizes scalar surface data <code>f</code> onto the grid in the form of scalar grid data <code>s</code>. This is the adjoint to <a href="#ImmersedLayers.interpolate!"><code>interpolate!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L4-L12">source</a></section><section><div><pre><code class="language-julia hljs">regularize!(s::Nodes{Dual},f::ScalarData,cache::BasicILMCache)
regularize!(s::Nodes{Dual},f::ScalarData,sys::ILMSystem)</code></pre><p>The operation <span>$s = R_N f$</span>, which regularizes scalar surface data <code>f</code> onto the grid in the form of scalar grid (curl) data <code>s</code>. Only works if the cache is built for vector data. This is the adjoint to <a href="#ImmersedLayers.interpolate!"><code>interpolate!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L15-L24">source</a></section><section><div><pre><code class="language-julia hljs">regularize!(v::Edges{Primal},vb::VectorData,cache::BasicILMCache)
regularize!(v::Edges{Primal},vb::VectorData,sys::ILMSystem)</code></pre><p>The operation <span>$\mathbf{v} = R_f \mathbf{v}_b$</span>, which regularizes vector surface data <code>vb</code> onto the grid in the form of scalar grid data <code>v</code>. This is the adjoint to <a href="#ImmersedLayers.interpolate!"><code>interpolate!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L28-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.interpolate!" href="#ImmersedLayers.interpolate!"><code>ImmersedLayers.interpolate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interpolate!(f::ScalarData,s::Nodes{Primal},cache::BasicILMCache)
interpolate!(f::ScalarData,s::Nodes{Primal},sys::ILMSystem)</code></pre><p>The operation <span>$f = R_c^T s$</span>, which interpolates scalar grid data <code>s</code> onto the surface points in the form of scalar point data <code>f</code>. This is the adjoint to <a href="#ImmersedLayers.regularize!"><code>regularize!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L48-L55">source</a></section><section><div><pre><code class="language-julia hljs">interpolate!(f::ScalarData,s::Nodes{Dual},cache::BasicILMCache)
interpolate!(f::ScalarData,s::Nodes{Dual},sys::ILMSystem)</code></pre><p>The operation <span>$f = R_N^T s$</span>, which interpolates scalar grid (curl) data <code>s</code> onto the surface points in the form of scalar point data <code>f</code>. Only works if the cache is built for vector data. This is the adjoint to <a href="#ImmersedLayers.regularize!"><code>regularize!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L58-L66">source</a></section><section><div><pre><code class="language-julia hljs">interpolate!(vb::VectorData,v::Edges{Primal},cache::BasicILMCache)
interpolate!(vb::VectorData,v::Edges{Primal},sys::ILMSystem)</code></pre><p>The operation <span>$\mathbf{v}_b = R_c^T \mathbf{v}$</span>, which interpolates vector grid data <code>v</code> onto the surface points in the form of scalar point data <code>vb</code>. This is the adjoint to <a href="#ImmersedLayers.regularize!"><code>regularize!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L70-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.regularize_normal!" href="#ImmersedLayers.regularize_normal!"><code>ImmersedLayers.regularize_normal!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">regularize_normal!(v::Edges{Primal},f::ScalarData,cache::BasicILMCache)
regularize_normal!(v::Edges{Primal},f::ScalarData,sys::ILMSystem)</code></pre><p>The operation <span>$\mathbf{v} = R_f \mathbf{n}\circ f$</span>, which maps scalar surface data <code>f</code> (like a jump in scalar potential) to grid data <code>v</code> (like velocity). This is the adjoint to <a href="#ImmersedLayers.normal_interpolate!"><code>normal_interpolate!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L90-L97">source</a></section><section><div><pre><code class="language-julia hljs">regularize_normal!(qt::EdgeGradient{Primal},v::VectorData,cache::BasicILMCache)
regularize_normal!(qt::EdgeGradient{Primal},v::VectorData,sys::ILMSystem)</code></pre><p>The operation <span>$\mathbf{q}_t = R_t \mathbf{n}\circ \mathbf{v}$</span>, which maps scalar vector data <code>v</code> (like a jump in velocity) to grid data <code>qt</code> (like velocity-normal tensor). This is the adjoint to <a href="#ImmersedLayers.normal_interpolate!"><code>normal_interpolate!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L105-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.regularize_normal_symm!" href="#ImmersedLayers.regularize_normal_symm!"><code>ImmersedLayers.regularize_normal_symm!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">regularize_normal_symm!(qt::EdgeGradient{Primal},v::VectorData,cache::BasicILMCache)
regularize_normal_symm!(qt::EdgeGradient{Primal},v::VectorData,sys::ILMSystem)</code></pre><p>The operation <span>$\mathbf{q}_t = R_t (\mathbf{n}\circ \mathbf{v}+\mathbf{v}\circ \mathbf{n})$</span>, which maps scalar vector data <code>v</code> (like a jump in velocity) to grid data <code>qt</code> (like velocity-normal tensor). This is the adjoint to <a href="#ImmersedLayers.normal_interpolate_symm!"><code>normal_interpolate_symm!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L115-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.normal_interpolate!" href="#ImmersedLayers.normal_interpolate!"><code>ImmersedLayers.normal_interpolate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normal_interpolate!(vn::ScalarData,v::Edges{Primal},cache::BasicILMCache)
normal_interpolate!(vn::ScalarData,v::Edges{Primal},sys::ILMSystem)</code></pre><p>The operation <span>$v_n = \mathbf{n} \cdot R_f^T \mathbf{v}$</span>, which maps grid data <code>v</code> (like velocity) to scalar surface data <code>vn</code> (like normal component of surface velocity). This is the adjoint to <a href="#ImmersedLayers.regularize_normal!"><code>regularize_normal!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L220-L227">source</a></section><section><div><pre><code class="language-julia hljs">normal_interpolate!(τ::VectorData,A::EdgeGradient{Primal},cache::BasicILMCache)
normal_interpolate!(τ::VectorData,A::EdgeGradient{Primal},sys::ILMSystem)</code></pre><p>The operation <span>$\mathbf{\tau} = \mathbf{n} \cdot R_t^T \mathbf{A}$</span>, which maps grid tensor data <code>A</code> (like velocity gradient tensor) to vector surface data <code>τ</code> (like traction). This is the adjoint to <a href="#ImmersedLayers.regularize_normal!"><code>regularize_normal!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L235-L241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.normal_interpolate_symm!" href="#ImmersedLayers.normal_interpolate_symm!"><code>ImmersedLayers.normal_interpolate_symm!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normal_interpolate_symm!(τ::VectorData,A::EdgeGradient{Primal},cache::BasicILMCache)
normal_interpolate_symm!(τ::VectorData,A::EdgeGradient{Primal},sys::ILMSystem)</code></pre><p>The operation <span>$\mathbf{\tau} = \mathbf{n} \cdot R_t^T (\mathbf{A} +\mathbf{A}^T - (\mathrm{tr}\mathbf{A})\mathbf{I})$</span>, which maps grid tensor data <code>A</code> (like velocity gradient tensor) to vector surface data <code>τ</code> (like traction). This is the adjoint to <a href="#ImmersedLayers.regularize_normal_symm!"><code>regularize_normal_symm!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L245-L251">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.regularize_normal_cross!" href="#ImmersedLayers.regularize_normal_cross!"><code>ImmersedLayers.regularize_normal_cross!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">regularize_normal_cross!(v::Edges{Primal},f::ScalarData,cache::BasicILMCache)
regularize_normal_cross!(v::Edges{Primal},f::ScalarData,sys::ILMSystem)</code></pre><p>The operation <span>$\mathbf{v} = R_f \mathbf{n}\times f \mathbf{e}_z$</span>, which maps scalar surface data <code>f</code> (like a jump in streamfunction, endowed with the out-of-plane unit vector <span>$\mathbf{e}_z$</span>) to grid data <code>v</code> (like velocity). This is the negative adjoint to <a href="#ImmersedLayers.normal_cross_interpolate!"><code>normal_cross_interpolate!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L142-L149">source</a></section><section><div><pre><code class="language-julia hljs">regularize_normal_cross!(w::Nodes{Dual},vs::VectorData,cache::BasicILMCache)
regularize_normal_cross!(w::Nodes{Dual},vs::VectorData,sys::ILMSystem)</code></pre><p>The operation <span>$\omega = R_N \mathbf{n}\times \mathbf{v}_s$</span>, which maps surface vector data <code>vs</code> (like a jump in velocity) to grid dual nodal data <code>w</code> (like vorticity). This is for use only with vector-data caches. This is the negative adjoint to <a href="#ImmersedLayers.normal_cross_interpolate!"><code>normal_cross_interpolate!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L164-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.normal_cross_interpolate!" href="#ImmersedLayers.normal_cross_interpolate!"><code>ImmersedLayers.normal_cross_interpolate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normal_cross_interpolate!(wn::ScalarData,v::Edges{Primal},cache::BasicILMCache)
normal_cross_interpolate!(wn::ScalarData,v::Edges{Primal},sys::ILMSystem)</code></pre><p>The operation <span>$w_n = e_z\cdot (\mathbf{n} \times R_f^T \mathbf{v})$</span>, which maps grid data <code>v</code> (like velocity) to scalar surface data <code>wn</code> (like vorticity in the surface). This is the negative adjoint to <a href="#ImmersedLayers.regularize_normal_cross!"><code>regularize_normal_cross!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L269-L276">source</a></section><section><div><pre><code class="language-julia hljs">normal_cross_interpolate!(vs::VectorData,s::Nodes{Dual},cache::BasicILMCache)
normal_cross_interpolate!(vs::VectorData,s::Nodes{Dual},sys::ILMSystem)</code></pre><p>The operation <span>$\mathbf{v}_s = \mathbf{n}\times R_N^T \psi\mathbf{e}_z)$</span>, which maps grid data <code>s</code> (like streamfunction) to vector surface data <code>vs</code> (like velocity in the surface). It only works for a vector-type cache. This is the negative adjoint to <a href="#ImmersedLayers.regularize_normal_cross!"><code>regularize_normal_cross!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L293-L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.regularize_normal_dot!" href="#ImmersedLayers.regularize_normal_dot!"><code>ImmersedLayers.regularize_normal_dot!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">regularize_normal_dot!(f::Nodes{Primal},vs::VectorData,cache::BasicILMCache)
regularize_normal_dot!(f::Nodes{Primal},vs::VectorData,sys::ILMSystem)</code></pre><p>The operation <span>$\phi = R_c \mathbf{n}\cdot \mathbf{v}_s$</span>, which maps surface vector data <code>vs</code> (like a jump in velocity) to grid nodal data <code>f</code> (like scalar potential). This is the negative adjoint to <a href="#ImmersedLayers.normal_dot_interpolate!"><code>normal_dot_interpolate!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L181-L187">source</a></section><section><div><pre><code class="language-julia hljs">regularize_normal_dot!(v::Edges{Primal},taus::TensorData,cache::BasicILMCache)
regularize_normal_dot!(v::Edges{Primal},taus::TensorData,sys::ILMSystem)</code></pre><p>The operation <span>$\mathbf{v} = R_f \mathbf{n}\cdot \mathbf{\tau}_s$</span>, which maps surface tensor data <code>taus</code> (like a stress) to grid edge data <code>v</code> (like velocity). This is the negative adjoint to <a href="#ImmersedLayers.normal_dot_interpolate!"><code>normal_dot_interpolate!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L202-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.normal_dot_interpolate!" href="#ImmersedLayers.normal_dot_interpolate!"><code>ImmersedLayers.normal_dot_interpolate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normal_dot_interpolate!(vs::VectorData,f::Nodes{Primal},cache::BasicILMCache)
normal_dot_interpolate!(vs::VectorData,f::Nodes{Primal},sys::ILMSystem)</code></pre><p>The operation <span>$\mathbf{v}_s = \mathbf{n} R_c^T \phi$</span>, which maps grid nodal data <code>f</code> (like scalar potential) to surface vector data <code>vs</code> (like velocity). This is the negative adjoint to <a href="#ImmersedLayers.regularize_normal_dot!"><code>regularize_normal_dot!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L309-L315">source</a></section><section><div><pre><code class="language-julia hljs">normal_dot_interpolate!(taus::TensorData,v::Edges{Primal},cache::BasicILMCache)
normal_dot_interpolate!(taus::TensorData,v::Edges{Primal},sys::ILMSystem)</code></pre><p>The operation <span>$\mathbf{\tau}_s = \mathbf{n}\circ R_f^T\mathbf{v}$</span>, which maps grid edge data <code>v</code> (like velocity) to surface tensor data <code>taus</code> (like stress). This is the negative adjoint to <a href="#ImmersedLayers.regularize_normal_dot!"><code>regularize_normal_dot!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L330-L336">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.surface_divergence!" href="#ImmersedLayers.surface_divergence!"><code>ImmersedLayers.surface_divergence!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">surface_divergence!(Θ::Nodes{Primal},f::ScalarData,cache::BasicILMCache)
surface_divergence!(Θ::Nodes{Primal},f::ScalarData,sys::ILMSystem)</code></pre><p>The operation <span>$\theta = D_s f = D R_f \mathbf{n} \circ f$</span>, which maps surface scalar data <code>f</code> (like jump in scalar potential) to grid data <code>Θ</code> (like dilatation, i.e. divergence of velocity). This is the negative adjoint of <a href="#ImmersedLayers.surface_grad!"><code>surface_grad!</code></a>. Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether <code>sys</code> has been designated with <code>IndexScaling</code> or <code>GridScaling</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L518-L529">source</a></section><section><div><pre><code class="language-julia hljs">surface_divergence!(v::Edges{Primal},dv::VectorData,cache::BasicILMCache)
surface_divergence!(v::Edges{Primal},dv::VectorData,sys::ILMSystem)</code></pre><p>The operation <span>$\mathbf{v} = D_s d\mathbf{v} = D R_t (\mathbf{n} \circ d\mathbf{v})$</span>, which maps surface vector data <code>dv</code> (like jump in velocity) to grid data <code>v</code> (like velocity). This is the negative adjoint of <a href="#ImmersedLayers.surface_grad!"><code>surface_grad!</code></a>. Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether <code>sys</code> has been designated with <code>IndexScaling</code> or <code>GridScaling</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L549-L558">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.surface_grad!" href="#ImmersedLayers.surface_grad!"><code>ImmersedLayers.surface_grad!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">surface_grad!(vn::ScalarData,ϕ::Nodes{Primal},cache::BasicILMCache)
surface_grad!(vn::ScalarData,ϕ::Nodes{Primal},sys::ILMSystem)</code></pre><p>The operation <span>$v_n = G_s\phi = \mathbf{n} \cdot R_f^T G\phi$</span>, which maps grid data <code>ϕ</code> (like scalar potential) to scalar surface data <code>vn</code> (like normal component of velocity). This is the negative adjoint of <a href="#ImmersedLayers.surface_divergence!"><code>surface_divergence!</code></a>. Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether <code>sys</code> has been designated with <code>IndexScaling</code> or <code>GridScaling</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L593-L603">source</a></section><section><div><pre><code class="language-julia hljs">surface_grad!(τ::VectorData,v::Edges{Primal},cache::BasicILMCache)
surface_grad!(τ::VectorData,v::Edges{Primal},sys::ILMSystem)</code></pre><p>The operation <span>$\mathbf{\tau} = G_s v = \mathbf{n} \cdot R_t^T G \mathbf{v}$</span>, which maps grid vector data <code>v</code> (like velocity) to vector surface data <code>τ</code> (like traction). This is the negative adjoint of <a href="#ImmersedLayers.surface_divergence!"><code>surface_divergence!</code></a>. Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether <code>sys</code> has been designated with <code>IndexScaling</code> or <code>GridScaling</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L622-L631">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.surface_curl!" href="#ImmersedLayers.surface_curl!"><code>ImmersedLayers.surface_curl!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">surface_curl!(w::Nodes{Dual},f::ScalarData,cache::BasicILMCache)
surface_curl!(w::Nodes{Dual},f::ScalarData,sys::ILMSystem)</code></pre><p>The operation <span>$w = C_s^T f = C^T R_f \mathbf{n}\circ f$</span>, which maps scalar surface data <code>f</code> (like a jump in scalar potential) to grid data <code>w</code> (like vorticity). This is the adjoint to <span>$C_s$</span>, also given by <code>surface_curl!</code> (but with arguments switched). Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether <code>sys</code> has been designated with <code>IndexScaling</code> or <code>GridScaling</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L346-L356">source</a></section><section><div><pre><code class="language-julia hljs">surface_curl!(w::Nodes{Dual},v::VectorData,cache::BasicILMCache)
surface_curl!(w::Nodes{Dual},v::VectorData,sys::ILMSystem)</code></pre><p>The operation <span>$w = C_s^T \mathbf{v} = C^T R_f \mathbf{v}$</span>, which maps vector surface data <code>v</code> (like velocity) to grid data <code>w</code> (like vorticity). This is the adjoint to <span>$C_s$</span>, also given by <code>surface_curl!</code> (but with arguments switched). Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether <code>sys</code> has been designated with <code>IndexScaling</code> or <code>GridScaling</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L377-L387">source</a></section><section><div><pre><code class="language-julia hljs">surface_curl!(vn::ScalarData,s::Nodes{Dual},cache::BasicILMCache)
surface_curl!(vn::ScalarData,s::Nodes{Dual},sys::ILMSystem)</code></pre><p>The operation <span>$v_n = C_s s = \mathbf{n} \cdot R_f^T C s$</span>, which maps grid data <code>s</code> (like streamfunction) to scalar surface data <code>vn</code> (like normal component of velocity). This is the adjoint to <span>$C_s^T$</span>, also given by <code>surface_curl!</code>, but with arguments switched.  Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether <code>sys</code> has been designated with <code>IndexScaling</code> or <code>GridScaling</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L400-L411">source</a></section><section><div><pre><code class="language-julia hljs">surface_curl!(v::VectorData,s::Nodes{Dual},cache::BasicILMCache)
surface_curl!(v::VectorData,s::Nodes{Dual},sys::ILMSystem)</code></pre><p>The operation <span>$\mathbf{v} = C_s s = R_f^T C s$</span>, which maps grid data <code>s</code> (like streamfunction) to vector surface data <code>v</code> (like velocity). This is the adjoint to <span>$C_s^T$</span>, also given by <code>surface_curl!</code>, but with arguments switched.  Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether <code>sys</code> has been designated with <code>IndexScaling</code> or <code>GridScaling</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L431-L442">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.surface_divergence_symm!" href="#ImmersedLayers.surface_divergence_symm!"><code>ImmersedLayers.surface_divergence_symm!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">surface_divergence_symm!(v::Edges{Primal},dv::VectorData,cache::BasicILMCache)
surface_divergence_symm!(v::Edges{Primal},dv::VectorData,sys::ILMSystem)</code></pre><p>The operation <span>$\mathbf{v} = D_s d\mathbf{v} = D R_t (\mathbf{n} \circ d\mathbf{v} + d\mathbf{v} \circ \mathbf{n})$</span>, which maps surface vector data <code>dv</code> (like jump in velocity) to grid data <code>v</code> (like velocity). This is the negative adjoint of <a href="#ImmersedLayers.surface_grad_symm!"><code>surface_grad_symm!</code></a>. Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether <code>sys</code> has been designated with <code>IndexScaling</code> or <code>GridScaling</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L564-L573">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.surface_divergence_cross!" href="#ImmersedLayers.surface_divergence_cross!"><code>ImmersedLayers.surface_divergence_cross!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">surface_divergence_cross!(Θ::Nodes{Primal},f::ScalarData,cache::BasicILMCache)
surface_divergence_cross!(Θ::Nodes{Primal},f::ScalarData,sys::ILMSystem)</code></pre><p>The operation <span>$\theta = \hat{D}_s f = D R_f \mathbf{n} \times f \mathbf{e}_z$</span>, which maps surface scalar data <code>f</code> (like jump in streamfunction) to grid data <code>Θ</code> (like dilatation, i.e. divergence of velocity). This is the adjoint of <a href="#ImmersedLayers.surface_grad_cross!"><code>surface_grad_cross!</code></a>. Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether <code>sys</code> has been designated with <code>IndexScaling</code> or <code>GridScaling</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L668-L678">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.surface_grad_symm!" href="#ImmersedLayers.surface_grad_symm!"><code>ImmersedLayers.surface_grad_symm!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">surface_grad_symm!(τ::VectorData,v::Edges{Primal},cache::BasicILMCache)
surface_grad_symm!(τ::VectorData,v::Edges{Primal},sys::ILMSystem)</code></pre><p>The operation <span>$\mathbf{\tau} = G_s v = \mathbf{n} \cdot R_t^T (G \mathbf{v} + (G \mathbf{v})^T)$</span>, which maps grid vector data <code>v</code> (like velocity) to vector surface data <code>τ</code> (like traction). This is the negative adjoint of <a href="#ImmersedLayers.surface_divergence_symm!"><code>surface_divergence_symm!</code></a>. Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether <code>sys</code> has been designated with <code>IndexScaling</code> or <code>GridScaling</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L637-L646">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.surface_grad_cross!" href="#ImmersedLayers.surface_grad_cross!"><code>ImmersedLayers.surface_grad_cross!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">surface_grad_cross!(γ::ScalarData,ϕ::Nodes{Primal},cache::BasicILMCache)
surface_grad_cross!(γ::ScalarData,ϕ::Nodes{Primal},sys::ILMSystem)</code></pre><p>The operation <span>$\gamma = \hat{G}_s\phi = \mathbf{e}_z \cdot (\mathbf{n} \times R_f^T G\phi)$</span>, which maps grid data <code>ϕ</code> (like scalar potential) to scalar surface data <code>γ</code> (like surface vorticity). This is the adjoint of <a href="#ImmersedLayers.surface_divergence_cross!"><code>surface_divergence_cross!</code></a>. Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether <code>sys</code> has been designated with <code>IndexScaling</code> or <code>GridScaling</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L697-L707">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.surface_curl_cross!" href="#ImmersedLayers.surface_curl_cross!"><code>ImmersedLayers.surface_curl_cross!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">surface_curl_cross!(w::Nodes{Dual},f::ScalarData,cache::BasicILMCache)
surface_curl_cross!(w::Nodes{Dual},f::ScalarData,sys::ILMSystem)</code></pre><p>The operation <span>$w = \hat{C}_s^T f = C^T R_f \mathbf{n}\times f \mathbf{e}_z$</span>, which maps scalar surface data <code>f</code> (like a jump in streamfunction, multiplied by out-of-plane unit vector <span>$\mathbf{e}_z$</span>) to grid data <code>w</code> (like vorticity). This is the adjoint to <span>$\hat{C}_s$</span>, also given by <code>surface_curl_cross!</code> (but with arguments switched). Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether <code>sys</code> has been designated with <code>IndexScaling</code> or <code>GridScaling</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L456-L466">source</a></section><section><div><pre><code class="language-julia hljs">surface_curl_cross!(γ::ScalarData,s::Nodes{Dual},cache::BasicILMCache)
surface_curl_cross!(γ::ScalarData,s::Nodes{Dual},sys::ILMSystem)</code></pre><p>The operation <span>$\gamma = \hat{C}_s s = \mathbf{e}_z\cdot (\mathbf{n} \times R_f^T C s)$</span>, which maps grid data <code>s</code> (like streamfunction) to scalar surface data <code>γ</code> (like vorticity in the surface). This is the adjoint to <span>$\hat{C}_s^T$</span>, also given by <code>surface_curl_cross!</code>, but with arguments switched.  Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether <code>sys</code> has been designated with <code>IndexScaling</code> or <code>GridScaling</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L486-L497">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.mask!" href="#ImmersedLayers.mask!"><code>ImmersedLayers.mask!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mask!(w::GridData,cache::BasicILMCache)
mask!(w::GridData,sys::ILMSystem)</code></pre><p>Mask the data <code>w</code> in place by multiplying it by 1s inside of a surface (i.e., on a side opposite   the normal vectors) and 0s outside. The grid data <code>w</code> must be of the same type as the   output data type of <code>cache</code>. Only allows <code>cache</code> to have <code>GridScaling</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L780-L787">source</a></section><section><div><pre><code class="language-julia hljs">mask!(w::GridData,surface::Body,grid::PhysicalGrid)</code></pre><p>Mask the data <code>w</code> in place by multiplying it by 1s inside of surface <code>surface</code> (i.e., on a side opposite the normal vectors) and 0s outside.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L826-L831">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.mask" href="#ImmersedLayers.mask"><code>ImmersedLayers.mask</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mask(cache::BasicILMCache) -&gt; GridData
mask(sys::ILMSystem) -&gt; GridData</code></pre><p>Create grid data that consist of 1s inside of a surface (i.e., on a side opposite   the normal vectors) and 0s outside. The grid data are the same type as the   output data type of <code>sys</code>.  Only allows <code>sys</code> to have <code>GridScaling</code>.   If the cache has no immersed surface, then it reverts to 1s everywhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L728-L736">source</a></section><section><div><pre><code class="language-julia hljs">mask(w::GridData,surface::Body,grid::PhysicalGrid)</code></pre><p>Create grid data that consist of 1s inside of surface <code>surface</code> (i.e., on a side opposite the normal vectors) and 0s outside. The grid data are the same type as <code>w</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L753-L759">source</a></section><section><div><pre><code class="language-julia hljs">mask(ar::AreaRegionCache)</code></pre><p>Return the mask for the given area region <code>ar</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/forcing.jl#L301-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.complementary_mask!" href="#ImmersedLayers.complementary_mask!"><code>ImmersedLayers.complementary_mask!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">complementary_mask!(w::GridData,cache::BasicILMCache)
complementary_mask!(w::GridData,sys::ILMSystem)</code></pre><p>Mask the data <code>w</code> in place by multiplying it by 0s inside of a surface (i.e., on a side opposite   the normal vectors) and 1s outside. The grid data <code>w</code> must be of the same type as the   output data type of <code>cache</code>. Only allows <code>cache</code> to have <code>GridScaling</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L803-L810">source</a></section><section><div><pre><code class="language-julia hljs">complementary_mask!(w::GridData,surface::Body,grid::PhysicalGrid)</code></pre><p>Mask the data <code>w</code> in place by multiplying it by 0s inside of surface <code>surface</code> (i.e., on a side opposite the normal vectors) and 1s outside.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L840-L845">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.complementary_mask" href="#ImmersedLayers.complementary_mask"><code>ImmersedLayers.complementary_mask</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">complementary_mask(cache::BasicILMCache) -&gt; GridData
complementary_mask(sys::ILMSystem) -&gt; GridData</code></pre><p>Create grid data that consist of 0s inside of a surface (i.e., on a side opposite   the normal vectors) and 1s outside. The grid data are the same type as the   output data type of <code>cache</code>.  Only allows <code>cache</code> to have <code>GridScaling</code>.   If the cache has no immersed surface, then it reverts to 0s everywhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L740-L748">source</a></section><section><div><pre><code class="language-julia hljs">complementary_mask(w::GridData,surface::Body,grid::PhysicalGrid)</code></pre><p>Create grid data that consist of 0s inside of surface <code>surface</code> (i.e., on a side opposite the normal vectors) and 1s outside. The grid data are the same type as <code>w</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/6be67d52d1f3ffb196e445886e3c0e3ebc6de69b/src/surface_operators.jl#L766-L772">source</a></section></article><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../caches/">« Immersed layer caches</a><a class="docs-footer-nextpage" href="../multbodies/">Multiple bodies »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Monday 23 September 2024 21:39">Monday 23 September 2024</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
