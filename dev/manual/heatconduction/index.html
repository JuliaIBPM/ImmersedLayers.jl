<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Setting up a time-varying PDE · ImmersedLayers.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ImmersedLayers.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../caches/">Immersed layer caches</a></li><li><a class="tocitem" href="../surfaceops/">Surface-grid operations</a></li><li><a class="tocitem" href="../multbodies/">Multiple bodies</a></li><li><a class="tocitem" href="../gridops/">Grid operations</a></li><li><a class="tocitem" href="../helmholtz/">Helmholtz decomposition</a></li><li><a class="tocitem" href="../matrices/">Matrix operators</a></li><li><a class="tocitem" href="../dirichlet/">A Dirichlet Poisson problem</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li></ul></li><li><span class="tocitem">Setting up PDEs</span><ul><li><a class="tocitem" href="../problems/">Problems and the system</a></li><li><a class="tocitem" href="../neumann/">Poisson with Neumann conditions</a></li><li><a class="tocitem" href="../stokes/">Stokes flow</a></li><li class="is-active"><a class="tocitem" href>Setting up a time-varying PDE</a><ul class="internal"><li><a class="tocitem" href="#Set-up-the-constrained-ODE-system-operators"><span>Set up the constrained ODE system operators</span></a></li><li><a class="tocitem" href="#Set-up-the-extra-cache-and-extend-prob_cache"><span>Set up the extra cache and extend <code>prob_cache</code></span></a></li><li><a class="tocitem" href="#Solve-the-problem"><span>Solve the problem</span></a></li><li><a class="tocitem" href="#Motions"><span>Motions</span></a></li><li><a class="tocitem" href="#Time-varying-PDE-functions"><span>Time-varying PDE functions</span></a></li></ul></li><li><a class="tocitem" href="../heatconduction-unbounded/">A time-varying PDE with forcing</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Setting up PDEs</a></li><li class="is-active"><a href>Setting up a time-varying PDE</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Setting up a time-varying PDE</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Setting-up-a-time-varying-PDE"><a class="docs-heading-anchor" href="#Setting-up-a-time-varying-PDE">Setting up a time-varying PDE</a><a id="Setting-up-a-time-varying-PDE-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-a-time-varying-PDE" title="Permalink"></a></h1><p>In this example we will demonstrate the use of the package on a time-dependent PDE, a problem of unsteady heat conduction. We will use the package to solve for the interior diffusion of temperature from a circle held at constant temperature.</p><p>We seek to solve the heat conduction equation with Dirichlet boundary conditions</p><p class="math-container">\[\dfrac{\partial T}{\partial t} = \kappa \nabla^2 T + q + \delta(\chi) \sigma  - \kappa \nabla\cdot \left( \delta(\chi) \mathbf{n} [T] \right)\]</p><p>subject to <span>$T = T_b$</span> on the immersed surface. We might be solving this external to a surface, or it might be internal. The quantity <span>$\sigma$</span> is the Lagrange multiplier. In this context, it is the heat flux through the surface.</p><p>In the spatially discrete formulation, the problem takes the form</p><p class="math-container">\[\begin{bmatrix}
\mathcal{L}_C^\kappa &amp; R_C \\ R_C^T &amp; 0
\end{bmatrix}\begin{pmatrix}
T \\ -\sigma
\end{pmatrix} =
\begin{pmatrix}
q - \kappa D_s [T] \\ (T^+_b + T^-_b)/2
\end{pmatrix}\]</p><p>where <span>$\mathcal{L}_C^\kappa = \mathrm{d}/\mathrm{d}t - \kappa L_C$</span>, where <span>$[T] = T_b^+ - T_b^-$</span> is the jump in temperature across the surface. As in the time-independent problems, we can specify whether we are solving it external or internal to a surface by setting the boundary value to zero in the other region. However, in contrast to the time-independent problems, we have to advance this problem in time. The system above has the form of a <em>constrained ODE system</em>, which the <code>ConstrainedSystems.jl</code> package treats. We will make use of this package in the example below.</p><p>To support this, there are a few additional steps in our setup of the problem:</p><ul><li>we (as the implementers of the PDE) need to specify the functions that calculate the  various parts of this constrained ODE system.</li><li>we (as the users of this implementation) need to specify the time step size,  the initial conditions, the time integration range, and create the <em>integrator</em>  to advance the solution.</li></ul><p>The latter of these is very easy, as we&#39;ll find. Most of our attention will be on the first part: how to set up the constrained ODE system. For this, we will make use of the <code>ODEFunctionList</code>, which assembles the various functions and operators into a <code>ConstrainedODEFunction</code>, to be used by the <code>ConstrainedSystems.jl</code> package.</p><pre><code class="language-julia hljs">using ImmersedLayers
using Plots
using UnPack</code></pre><h2 id="Set-up-the-constrained-ODE-system-operators"><a class="docs-heading-anchor" href="#Set-up-the-constrained-ODE-system-operators">Set up the constrained ODE system operators</a><a id="Set-up-the-constrained-ODE-system-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-the-constrained-ODE-system-operators" title="Permalink"></a></h2><p>The problem type is generated with the usual macro call. In this example, we will make use of more of the capabilities of the resulting problem constructor for &quot;packing&quot; it with information about the problem.</p><pre><code class="language-julia hljs">@ilmproblem DirichletHeatConduction scalar</code></pre><p>The constrained ODE system requires us to provide functions that calculate the RHS of the ODE, the RHS of the constraint equation, the Lagrange multiplier force term in the ODE, and the action of the boundary operator on the state vector. (You can see the generic form of the system by typing <code>?ConstrainedODEFunction</code>) As you will see, in this example these are <em>in-place</em> operators: their first argument holds the result, which is changed (i.e., mutated) by the function. Below, we construct the function that calculates the RHS of the heat conduction ODE. We have omitted the volumetric heat flux here, supplying only the double-layer term. Note how this makes use of the physical parameters in <code>phys_params</code> and the boundary data via functions in <code>bc</code>. The functions for the boundary data supply the boundary values. Also, note that the function returns <code>dT</code> in the first argument. This represents this function&#39;s contribution to <span>$dT/dt$</span>.</p><pre><code class="language-julia hljs">function heatconduction_ode_rhs!(dT,T,sys::ILMSystem,t)
    @unpack bc, forcing, phys_params, extra_cache, base_cache = sys
    @unpack dTb = extra_cache

    κ = phys_params[&quot;diffusivity&quot;]

    # Calculate the double-layer term
    prescribed_surface_jump!(dTb,t,sys)
    surface_divergence!(dT,-κ*dTb,sys)

    return dT
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">heatconduction_ode_rhs! (generic function with 1 method)</code></pre><p>Now, we create the function that calculates the RHS of the boundary condition. For this Dirichlet condition, we simply take the average of the interior and exterior prescribed values. The first argument <code>dTb</code> holds the result.</p><pre><code class="language-julia hljs">function heatconduction_bc_rhs!(dTb,sys::ILMSystem,t)
    prescribed_surface_average!(dTb,t,sys)
    return dTb
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">heatconduction_bc_rhs! (generic function with 1 method)</code></pre><p>This function calculates the contribution to <span>$dT/dt$</span> from the Lagrange multiplier (the input σ). Here, we simply regularize the negative of this to the grid.</p><pre><code class="language-julia hljs">function heatconduction_constraint_force!(dT,σ,sys::ILMSystem)
    regularize!(dT,-σ,sys)
    return dT
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">heatconduction_constraint_force! (generic function with 1 method)</code></pre><p>Now, we provide the transpose term of the previous function: a function that interpolates the temperature (state vector) onto the boundary. The first argument <code>dTb</code> holds the result.</p><pre><code class="language-julia hljs">function heatconduction_bc_op!(dTb,T,sys::ILMSystem)
    interpolate!(dTb,T,sys)
    return dTb
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">heatconduction_bc_op! (generic function with 1 method)</code></pre><h2 id="Set-up-the-extra-cache-and-extend-prob_cache"><a class="docs-heading-anchor" href="#Set-up-the-extra-cache-and-extend-prob_cache">Set up the extra cache and extend <code>prob_cache</code></a><a id="Set-up-the-extra-cache-and-extend-prob_cache-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-the-extra-cache-and-extend-prob_cache" title="Permalink"></a></h2><p>Here, we construct an extra cache that holds a few extra intermediate variables, used in the routines above. But this cache also, crucially, holds the functions and operators of the constrained ODE function. We call the function <code>ODEFunctionList</code> to assemble these together.</p><p>The <code>prob_cache</code> function creates this ODE function, supplying the functions that we just defined. We also create a Laplacian operator with the heat diffusivity built into it. (This operator is singled out from the other terms in the heat conduction equation, because we account for it separately in the time marching using a matrix exponential.) We also create <em>prototypes</em> of the <em>state</em> and <em>constraint force</em> vectors. Here, the state is the grid temperature data and the constraint is the Lagrange multipliers on the boundary.</p><pre><code class="language-julia hljs">struct DirichletHeatConductionCache{DTT,FT} &lt;: AbstractExtraILMCache
   dTb :: DTT
   f :: FT
end

function ImmersedLayers.prob_cache(prob::DirichletHeatConductionProblem,
                                   base_cache::BasicILMCache{N,scaling}) where {N,scaling}
    @unpack phys_params = prob
    @unpack gdata_cache, g = base_cache

    dTb = zeros_surface(base_cache)

    # Construct a Lapacian outfitted with the diffusivity
    κ = phys_params[&quot;diffusivity&quot;]
    heat_L = Laplacian(base_cache,gdata_cache,κ)

    # State (grid temperature data) and constraint (surface Lagrange multipliers)
    f = ODEFunctionList(state = zeros_grid(base_cache),
                        constraint = zeros_surface(base_cache),
                        ode_rhs=heatconduction_ode_rhs!,
                        lin_op=heat_L,
                        bc_rhs=heatconduction_bc_rhs!,
                        constraint_force = heatconduction_constraint_force!,
                        bc_op = heatconduction_bc_op!)

    DirichletHeatConductionCache(dTb,f)
end</code></pre><p>Before we move on to solving the problem, we need to set up a function that will calculate the time step size. The time marching algorithm will call this function. Of course, this could just be used to specify a time step directly, e.g., by supplying it in <code>phys_params</code>. But it is better to use a stability condition (a Fourier condition) to determine it based on the other data.</p><pre><code class="language-julia hljs">function timestep_fourier(sys)
    @unpack phys_params = sys
    g = get_grid(sys)
    κ = phys_params[&quot;diffusivity&quot;]
    Fo = phys_params[&quot;Fourier&quot;]
    Δt = Fo*cellsize(g)^2/κ
    return Δt
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">timestep_fourier (generic function with 1 method)</code></pre><h2 id="Solve-the-problem"><a class="docs-heading-anchor" href="#Solve-the-problem">Solve the problem</a><a id="Solve-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-the-problem" title="Permalink"></a></h2><p>We will solve heat conduction inside a circular region with uniform temperature, with thermal diffusivity equal to 1.</p><h3 id="Set-up-the-grid"><a class="docs-heading-anchor" href="#Set-up-the-grid">Set up the grid</a><a id="Set-up-the-grid-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-the-grid" title="Permalink"></a></h3><pre><code class="language-julia hljs">Δx = 0.01
Lx = 4.0
xlim = (-Lx/2,Lx/2)
ylim = (-Lx/2,Lx/2)
g = PhysicalGrid(xlim,ylim,Δx);</code></pre><h3 id="Set-up-the-body-shape."><a class="docs-heading-anchor" href="#Set-up-the-body-shape.">Set up the body shape.</a><a id="Set-up-the-body-shape.-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-the-body-shape." title="Permalink"></a></h3><p>Here, we will demonstrate the solution on a circular shape of radius 1.</p><pre><code class="language-julia hljs">Δs = 1.4*cellsize(g)
body = Circle(1.0,Δs);</code></pre><h3 id="Specify-the-physical-parameters,-data,-etc."><a class="docs-heading-anchor" href="#Specify-the-physical-parameters,-data,-etc.">Specify the physical parameters, data, etc.</a><a id="Specify-the-physical-parameters,-data,-etc.-1"></a><a class="docs-heading-anchor-permalink" href="#Specify-the-physical-parameters,-data,-etc." title="Permalink"></a></h3><p>These can be changed later without having to regenerate the system.</p><p>Here, we create a dict with physical parameters to be passed in.</p><pre><code class="language-julia hljs">phys_params = Dict(&quot;diffusivity&quot; =&gt; 1.0, &quot;Fourier&quot; =&gt; 1.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Float64} with 2 entries:
  &quot;Fourier&quot;     =&gt; 1.0
  &quot;diffusivity&quot; =&gt; 1.0</code></pre><p>The temperature boundary functions on the exterior and interior are defined here and assembled into a dict. Note that these functions must have a slightly more complex signature than in time-invariant problems: for generality, they must accept the time argument and another argument accepting possible motions of the surfaces.</p><pre><code class="language-julia hljs">get_Tbplus(t,base_cache,phys_params,motions) = zeros_surface(base_cache)
get_Tbminus(t,base_cache,phys_params,motions) = ones_surface(base_cache)
bcdict = Dict(&quot;exterior&quot; =&gt; get_Tbplus,&quot;interior&quot; =&gt; get_Tbminus)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Function} with 2 entries:
  &quot;interior&quot; =&gt; get_Tbminus
  &quot;exterior&quot; =&gt; get_Tbplus</code></pre><p>Construct the problem, passing in the data and functions we&#39;ve just created.</p><pre><code class="language-julia hljs">prob = DirichletHeatConductionProblem(g,body,scaling=GridScaling,
                                             phys_params=phys_params,
                                             bc=bcdict,
                                             timestep_func=timestep_fourier);</code></pre><p>Construct the system</p><pre><code class="language- hljs">sys = construct_system(prob);
nothing #hide</code></pre><h3 id="Solving-the-problem"><a class="docs-heading-anchor" href="#Solving-the-problem">Solving the problem</a><a id="Solving-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-problem" title="Permalink"></a></h3><p>In contrast to the previous (time-independent) example, we have not extended the <code>solve</code> function here to serve us in solving this problem. Instead, we rely on the tools in <code>ConstrainedSystems.jl</code> to advance the solution forward in time. This package builds from the <code>OrdinaryDiffEq.jl</code> package, and leverages most of the tools of that package.</p><p>Set an initial condition. Here, we just get an initial (zeroed) copy of the solution prototype that we have stored in the extra cache. We also get the time step size for our own inspection.</p><pre><code class="language- hljs">u0 = init_sol(sys)
Δt = timestep_fourier(sys)</code></pre><p>It is instructive to note that <code>u0</code> has two parts: a <em>state</em> and a <em>constraint</em>, each obtained respectively with a convenience function. The state in this case is the temperature; the constraint is the Lagrange multiplier.</p><pre><code class="language- hljs">state(u0)</code></pre><pre><code class="language- hljs">constraint(u0)</code></pre><p>Now, create the integrator, with a time interval of 0 to 1. We have not specified the algorithm here explicitly; it defaults to the <code>LiskaIFHERK</code> time-marching algorithm, which is a second-order algorithm for constrained ODE systems that utilizes the matrix exponential (i.e., integrating factor) for the linear part of the problem. Another choice is the first-order Euler method, <code>IFHEEuler</code>, which one can specify by adding <code>alg=ConstrainedSystems.IFHEEuler()</code></p><pre><code class="language- hljs">tspan = (0.0,1.0)
integrator = init(u0,tspan,sys)</code></pre><p>Now advance the solution by 0.01 convective time units, by using the <code>step!</code> function, which steps through the solution.</p><pre><code class="language- hljs">step!(integrator,0.01)</code></pre><h3 id="Plot-the-solution"><a class="docs-heading-anchor" href="#Plot-the-solution">Plot the solution</a><a id="Plot-the-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-the-solution" title="Permalink"></a></h3><p>The integrator holds the most recent solution in the field <code>u</code>, which has the same type as our initial condition <code>u0</code>. Here, we plot the state of the system at the end of the interval.</p><pre><code class="language- hljs">plot(state(integrator.u),sys)</code></pre><p>It would be nice to just define a function called <code>temperature</code> to get this more explicitly. We will do that here, and also apply a macro <code>@snapshotoutput</code> that automatically extends this function with some convenient interfaces. For example, if we simply pass in the integrator to <code>temperature</code>, it will pick off the <code>u</code> field for us.</p><pre><code class="language-julia hljs">temperature(T,σ,sys::ILMSystem,t) = T
@snapshotoutput temperature</code></pre><p>Now we can write</p><pre><code class="language- hljs">plot(temperature(integrator),sys)</code></pre><p>The solution history is in the field <code>integrator.sol</code>. The macro we called earlier enables temperature to work for this, as well, and we can obtain the temperature at <em>any</em> time in the interval of our solution. For example, to get the solution at time 0.51:</p><pre><code class="language- hljs">sol = integrator.sol
plot(temperature(sol,sys,0.0051),sys)</code></pre><p>We can also get it for an array of times, e.g.,</p><pre><code class="language- hljs">temperature(sol,sys,0.0051:0.0001:0.0061);
nothing #hide</code></pre><h2 id="Motions"><a class="docs-heading-anchor" href="#Motions">Motions</a><a id="Motions-1"></a><a class="docs-heading-anchor-permalink" href="#Motions" title="Permalink"></a></h2><p>It is straightforward to make bodies move in time-varying problems. For each body that we create, we can provide a corresponding motion, via the <code>motions =</code> keyword. (If a <code>BodyList</code> is provided, then a corresponding <code>MotionList</code> must be provided.) The only caveat is that the time-stepping becomes considerably slower in such problems, since the system operators must be regenerated at every time step.</p><p>The <code>RigidBodyTools.jl</code> package provides a versatile set of motions, both rigid-body and deforming, and associated tools. For example, to simply make the body move at constant velocity 1 in the <code>x</code> direction.</p><pre><code class="language-julia hljs">m = RigidBodyMotion((1.0,0.0),0.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Rigid Body Motion:
  Constant rotation (żp = 1.0 + 0.0im, α̇ = 0.0) 
   about z̃p = 0.0 + 0.0im (in comoving coordinates) </code></pre><p>Here&#39;s an example of a deforming motion</p><pre><code class="language-julia hljs">ufcn(x,y,t) = 0.25*x*y*cos(t)
vfcn(x,y,t) = 0.25*(x^2-y^2)*cos(t)
m = DeformationMotion(ufcn,vfcn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DeformationMotion{typeof(Main.ufcn), typeof(Main.vfcn)}(Main.ufcn, Main.vfcn)</code></pre><p>Either of these would be provided in the <code>motions =</code> keyword of the problem construction. Consult the documentation of <code>RigidBodyTools.jl</code> to learn more about these. However, for time-marching purposes, it is helpful to know that the maximum surface velocity is provided by the <code>maxvelocity</code> function:</p><pre><code class="language-julia hljs">maxvelocity(body,m)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.24998770586539454, 1, 0.0)</code></pre><h2 id="Time-varying-PDE-functions"><a class="docs-heading-anchor" href="#Time-varying-PDE-functions">Time-varying PDE functions</a><a id="Time-varying-PDE-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Time-varying-PDE-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ImmersedLayers.ODEFunctionList" href="#ImmersedLayers.ODEFunctionList"><code>ImmersedLayers.ODEFunctionList</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ODEFunctionList</code></pre><p><strong>Constructor</strong></p><p><code>ODEFunctionList(state=nothing,constraint=nothing,ode_rhs=nothing,bc_rhs=nothing,constraint_force=nothing,bc_op=nothing,lin_op=nothing)</code></p><p>Supply functions and data types for a constrained ODE system. The specified functions must provide the various parts that comprise the constrained ODE system</p><p><span>$\dfrac{dy}{dt} = Ly - B_1 z + r_1(y,t)$</span></p><p><span>$B_2 y = r_2(t)$</span></p><p>The functions can be in in-place or out-of-place form, but they must all be consistently of the same form.</p><ul><li><p><code>state =</code> specifies a prototype of the state vector <span>$y$</span>.</p></li><li><p><code>constraint =</code> specifies a prototype of the constraint force vector <span>$z$</span>. If there are no constraints, this can be omitted.</p></li><li><p><code>ode_rhs =</code> specifies the right-hand side of the ODEs, <span>$r_1$</span>. The in-place form of the function is <code>r1(dy,y,sys::ILMSystem,t)</code>, the state vector <code>y</code>, IL system <code>sys</code>, time <code>t</code>, and returning <span>$dy/dt$</span>. The out-of-place form is <code>r1(y,sys,t)</code>.</p></li><li><p><code>bc_rhs =</code> specifies the right-hand side of the boundary conditions, <span>$r_2$</span>. If there are no constraints, this can be omitted. The in-place form is <code>r2(dz,sys,t)</code>, returning <code>dz</code>, the part of the boundary constraint not dependent on the state vector. The out-of-place form is <code>r2(sys,t)</code>.</p></li><li><p><code>constraint_force =</code> supplies the constraint force term in the ODEs, <span>$B_1 z$</span>. If there are no constraints, this can be omitted. The in-place form is <code>B1(dy,z,sys)</code>, returning the contribution to <span>$dy/dt$</span> (with the sign convention shown in the equations above) and the out-of-place form is <code>B1(z,sys)</code>.</p></li><li><p><code>bc_op =</code> supplies the left-hand side of the boundary constraint, <span>$B_2 y$</span>. If there are no constraints, this can be omitted. The in-place form is <code>B2(dz,y,sys)</code>, the out-of-place form is <code>B2(y,sys)</code>.</p></li><li><p><code>lin_op =</code> is optional and specifies a linear operator on the state vector <span>$L$</span>, to be treated with an exponential integral (i.e., integrating factor) in the time marching. (Alternatively, this part can simply be included in <code>r_1</code>). It should have an associated <code>mul!</code> operation that acts upon the state vector.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/2dfbc43bbd418ce046bd54420c1b304e8af03d28/src/timemarching.jl#L3-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImmersedLayers.zeros_sol" href="#ImmersedLayers.zeros_sol"><code>ImmersedLayers.zeros_sol</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">zeros_sol(sys::ILMSystem)</code></pre><p>Return a zeroed version of the solution vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/2dfbc43bbd418ce046bd54420c1b304e8af03d28/src/timemarching.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImmersedLayers.init_sol" href="#ImmersedLayers.init_sol"><code>ImmersedLayers.init_sol</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">init_sol(sys::ILMSystem)</code></pre><p>Return the initial solution vector, with the state component set to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/2dfbc43bbd418ce046bd54420c1b304e8af03d28/src/timemarching.jl#L124-L129">source</a></section><section><div><pre><code class="nohighlight hljs">init_sol(s::AbstractSpatialField,sys::ILMSystem)</code></pre><p>Return the initial solution vector, with the state component set to the field established by <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/2dfbc43bbd418ce046bd54420c1b304e8af03d28/src/timemarching.jl#L135-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CommonSolve.init" href="#CommonSolve.init"><code>CommonSolve.init</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ConstrainedSystems.init(u0,tspan,sys::ILMSystem,[alg=ConstrainedSystems.LiskaIFHERK()])</code></pre><p>Initialize the integrator for a time-varying immersed-layer system of PDEs, described in <code>sys</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/2dfbc43bbd418ce046bd54420c1b304e8af03d28/src/timemarching.jl#L207-L212">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>state</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>constraint</code>. Check Documenter&#39;s build log for details.</p></div></div><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../stokes/">« Stokes flow</a><a class="docs-footer-nextpage" href="../heatconduction-unbounded/">A time-varying PDE with forcing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 21 December 2022 04:15">Wednesday 21 December 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
