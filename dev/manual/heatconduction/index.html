<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Setting up a time-varying PDE · ImmersedLayers.jl</title><meta name="title" content="Setting up a time-varying PDE · ImmersedLayers.jl"/><meta property="og:title" content="Setting up a time-varying PDE · ImmersedLayers.jl"/><meta property="twitter:title" content="Setting up a time-varying PDE · ImmersedLayers.jl"/><meta name="description" content="Documentation for ImmersedLayers.jl."/><meta property="og:description" content="Documentation for ImmersedLayers.jl."/><meta property="twitter:description" content="Documentation for ImmersedLayers.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ImmersedLayers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../caches/">Immersed layer caches</a></li><li><a class="tocitem" href="../surfaceops/">Surface-grid operations</a></li><li><a class="tocitem" href="../multbodies/">Multiple bodies</a></li><li><a class="tocitem" href="../gridops/">Grid operations</a></li><li><a class="tocitem" href="../helmholtz/">Helmholtz decomposition</a></li><li><a class="tocitem" href="../matrices/">Matrix operators</a></li><li><a class="tocitem" href="../dirichlet/">A Dirichlet Poisson problem</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li></ul></li><li><span class="tocitem">Setting up PDEs</span><ul><li><a class="tocitem" href="../problems/">Problems and the system</a></li><li><a class="tocitem" href="../neumann/">Poisson with Neumann conditions</a></li><li><a class="tocitem" href="../stokes/">Stokes flow</a></li><li class="is-active"><a class="tocitem" href>Setting up a time-varying PDE</a><ul class="internal"><li><a class="tocitem" href="#Set-up-the-constrained-ODE-system-operators"><span>Set up the constrained ODE system operators</span></a></li><li><a class="tocitem" href="#Set-up-the-extra-cache-and-extend-prob_cache"><span>Set up the extra cache and extend <code>prob_cache</code></span></a></li><li><a class="tocitem" href="#Solve-the-problem"><span>Solve the problem</span></a></li><li><a class="tocitem" href="#Motions"><span>Motions</span></a></li><li><a class="tocitem" href="#Time-varying-PDE-functions"><span>Time-varying PDE functions</span></a></li></ul></li><li><a class="tocitem" href="../heatconduction-unbounded/">A time-varying PDE with forcing</a></li><li><a class="tocitem" href="../heatconduction-neumann/">A time-varying PDE with Neumann conditions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Setting up PDEs</a></li><li class="is-active"><a href>Setting up a time-varying PDE</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Setting up a time-varying PDE</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaIBPM/ImmersedLayers.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/main/test/literate/heatconduction.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Setting-up-a-time-varying-PDE"><a class="docs-heading-anchor" href="#Setting-up-a-time-varying-PDE">Setting up a time-varying PDE</a><a id="Setting-up-a-time-varying-PDE-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-a-time-varying-PDE" title="Permalink"></a></h1><p>In this example we will demonstrate the use of the package on a time-dependent PDE, a problem of unsteady heat conduction. We will use the package to solve for the interior diffusion of temperature from a circle held at constant temperature.</p><p>We seek to solve the heat conduction equation with Dirichlet boundary conditions</p><p class="math-container">\[\dfrac{\partial T}{\partial t} = \kappa \nabla^2 T + q + \delta(\chi) \sigma  - \kappa \nabla\cdot \left( \delta(\chi) \mathbf{n} [T] \right)\]</p><p>subject to <span>$T = T_b$</span> on the immersed surface. We might be solving this external to a surface, or it might be internal. The quantity <span>$\sigma$</span> is the Lagrange multiplier. In this context, it is the heat flux through the surface.</p><p>In the spatially discrete formulation, the problem takes the form</p><p class="math-container">\[\begin{bmatrix}
\mathcal{L}_C^\kappa &amp; R_C \\ R_C^T &amp; 0
\end{bmatrix}\begin{pmatrix}
T \\ -\sigma
\end{pmatrix} =
\begin{pmatrix}
q - \kappa D_s [T] \\ (T^+_b + T^-_b)/2
\end{pmatrix}\]</p><p>where <span>$\mathcal{L}_C^\kappa = \mathrm{d}/\mathrm{d}t - \kappa L_C$</span>, where <span>$[T] = T_b^+ - T_b^-$</span> is the jump in temperature across the surface. As in the time-independent problems, we can specify whether we are solving it external or internal to a surface by setting the boundary value to zero in the other region. However, in contrast to the time-independent problems, we have to advance this problem in time. The system above has the form of a <em>constrained ODE system</em>, which the <code>ConstrainedSystems.jl</code> package treats. We will make use of this package in the example below.</p><p>To support this, there are a few additional steps in our setup of the problem:</p><ul><li>we (as the implementers of the PDE) need to specify the functions that calculate the  various parts of this constrained ODE system.</li><li>we (as the users of this implementation) need to specify the time step size,  the initial conditions, the time integration range, and create the <em>integrator</em>  to advance the solution.</li></ul><p>The latter of these is very easy, as we&#39;ll find. Most of our attention will be on the first part: how to set up the constrained ODE system. For this, we will make use of the <code>ODEFunctionList</code>, which assembles the various functions and operators into a <code>ConstrainedODEFunction</code>, to be used by the <code>ConstrainedSystems.jl</code> package.</p><pre><code class="language-julia hljs">using ImmersedLayers
using Plots
using UnPack</code></pre><h2 id="Set-up-the-constrained-ODE-system-operators"><a class="docs-heading-anchor" href="#Set-up-the-constrained-ODE-system-operators">Set up the constrained ODE system operators</a><a id="Set-up-the-constrained-ODE-system-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-the-constrained-ODE-system-operators" title="Permalink"></a></h2><p>The problem type is generated with the usual macro call. In this example, we will make use of more of the capabilities of the resulting problem constructor for &quot;packing&quot; it with information about the problem.</p><pre><code class="language-julia hljs">@ilmproblem DirichletHeatConduction scalar</code></pre><p>The constrained ODE system requires us to provide functions that calculate the RHS of the ODE, the RHS of the constraint equation, the Lagrange multiplier force term in the ODE, and the action of the boundary operator on the state vector. (You can see the generic form of the system by typing <code>?ConstrainedODEFunction</code>) As you will see, in this example these are <em>in-place</em> operators: their first argument holds the result, which is changed (i.e., mutated) by the function. Below, we construct the function that calculates the RHS of the heat conduction ODE. We have omitted the volumetric heat flux here, supplying only the double-layer term. Note how this makes use of the physical parameters in <code>phys_params</code> and the boundary data via functions in <code>bc</code>. The functions for the boundary data supply the boundary values. Also, note that the function returns <code>dT</code> in the first argument. This represents this function&#39;s contribution to <span>$dT/dt$</span>. The argument <code>x</code> isn&#39;t used here, but would generally hold information about the body state.</p><pre><code class="language-julia hljs">function heatconduction_ode_rhs!(dT,T,x,sys::ILMSystem,t)
    @unpack bc, forcing, phys_params, extra_cache, base_cache = sys
    @unpack dTb = extra_cache

    κ = phys_params[&quot;diffusivity&quot;]

    # Calculate the double-layer term
    prescribed_surface_jump!(dTb,x,t,sys)
    surface_divergence!(dT,-κ*dTb,sys)

    return dT
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">heatconduction_ode_rhs! (generic function with 1 method)</code></pre><p>Now, we create the function that calculates the RHS of the boundary condition. For this Dirichlet condition, we simply take the average of the interior and exterior prescribed values. The first argument <code>dTb</code> holds the result. Again, <code>x</code> isn&#39;t used here.</p><pre><code class="language-julia hljs">function heatconduction_bc_rhs!(dTb,x,sys::ILMSystem,t)
    prescribed_surface_average!(dTb,x,t,sys)
    return dTb
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">heatconduction_bc_rhs! (generic function with 1 method)</code></pre><p>This function calculates the contribution to <span>$dT/dt$</span> from the Lagrange multiplier (the input σ). Here, we simply regularize the negative of this to the grid.</p><pre><code class="language-julia hljs">function heatconduction_constraint_force!(dT,σ,x,sys::ILMSystem)
    regularize!(dT,-σ,sys)
    return dT
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">heatconduction_constraint_force! (generic function with 1 method)</code></pre><p>Now, we provide the transpose term of the previous function: a function that interpolates the temperature (state vector) onto the boundary. The first argument <code>dTb</code> holds the result.</p><pre><code class="language-julia hljs">function heatconduction_bc_op!(dTb,T,x,sys::ILMSystem)
    interpolate!(dTb,T,sys)
    return dTb
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">heatconduction_bc_op! (generic function with 1 method)</code></pre><h2 id="Set-up-the-extra-cache-and-extend-prob_cache"><a class="docs-heading-anchor" href="#Set-up-the-extra-cache-and-extend-prob_cache">Set up the extra cache and extend <code>prob_cache</code></a><a id="Set-up-the-extra-cache-and-extend-prob_cache-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-the-extra-cache-and-extend-prob_cache" title="Permalink"></a></h2><p>Here, we construct an extra cache that holds a few extra intermediate variables, used in the routines above. But this cache also, crucially, holds the functions and operators of the constrained ODE function. We call the function <code>ODEFunctionList</code> to assemble these together.</p><p>The <code>prob_cache</code> function creates this ODE function, supplying the functions that we just defined. We also create a Laplacian operator with the heat diffusivity built into it. (This operator is singled out from the other terms in the heat conduction equation, because we account for it separately in the time marching using a matrix exponential.) We also create <em>prototypes</em> of the <em>state</em> and <em>constraint force</em> vectors. Here, the state is the grid temperature data and the constraint is the Lagrange multipliers on the boundary.</p><pre><code class="language-julia hljs">struct DirichletHeatConductionCache{DTT,FT} &lt;: AbstractExtraILMCache
   dTb :: DTT
   f :: FT
end

function ImmersedLayers.prob_cache(prob::DirichletHeatConductionProblem,
                                   base_cache::BasicILMCache{N,scaling}) where {N,scaling}
    @unpack phys_params = prob
    @unpack gdata_cache, g = base_cache

    dTb = zeros_surface(base_cache)

    # Construct a Lapacian outfitted with the diffusivity
    κ = phys_params[&quot;diffusivity&quot;]
    heat_L = Laplacian(base_cache,κ)

    # State (grid temperature data) and constraint (surface Lagrange multipliers)
    f = ODEFunctionList(state = zeros_grid(base_cache),
                        constraint = zeros_surface(base_cache),
                        ode_rhs=heatconduction_ode_rhs!,
                        lin_op=heat_L,
                        bc_rhs=heatconduction_bc_rhs!,
                        constraint_force = heatconduction_constraint_force!,
                        bc_op = heatconduction_bc_op!)

    DirichletHeatConductionCache(dTb,f)
end</code></pre><p>Before we move on to solving the problem, we need to set up a function that will calculate the time step size. The time marching algorithm will call this function. Of course, this could just be used to specify a time step directly, e.g., by supplying it in <code>phys_params</code>. But it is better to use a stability condition (a Fourier condition) to determine it based on the other data.</p><pre><code class="language-julia hljs">function timestep_fourier(u,sys)
    @unpack phys_params = sys
    g = get_grid(sys)
    κ = phys_params[&quot;diffusivity&quot;]
    Fo = phys_params[&quot;Fourier&quot;]
    Δt = Fo*cellsize(g)^2/κ
    return Δt
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">timestep_fourier (generic function with 1 method)</code></pre><h2 id="Solve-the-problem"><a class="docs-heading-anchor" href="#Solve-the-problem">Solve the problem</a><a id="Solve-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-the-problem" title="Permalink"></a></h2><p>We will solve heat conduction inside a circular region with uniform temperature, with thermal diffusivity equal to 1.</p><h3 id="Set-up-the-grid"><a class="docs-heading-anchor" href="#Set-up-the-grid">Set up the grid</a><a id="Set-up-the-grid-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-the-grid" title="Permalink"></a></h3><pre><code class="language-julia hljs">Δx = 0.01
Lx = 4.0
xlim = (-Lx/2,Lx/2)
ylim = (-Lx/2,Lx/2)
g = PhysicalGrid(xlim,ylim,Δx);</code></pre><h3 id="Set-up-the-body-shape."><a class="docs-heading-anchor" href="#Set-up-the-body-shape.">Set up the body shape.</a><a id="Set-up-the-body-shape.-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-the-body-shape." title="Permalink"></a></h3><p>Here, we will demonstrate the solution on a circular shape of radius 1.</p><pre><code class="language-julia hljs">Δs = 1.4*cellsize(g)
body = Circle(1.0,Δs);</code></pre><p>Though the body is stationary, we still need to provide some minimal information about its placement and (lack of) motion. We do this with the help of the <code>RigidBodyMotion</code> structure. Technically, the placement of a body constitutes a basic <em>joint</em> with the inertial coordinate system. the <code>MotionTransform</code> below places the joint at the origin of the inertial coordinate system (the first argument), with no relative rotation (the second argument).</p><pre><code class="language-julia hljs">X = MotionTransform([0,0],0)
joint = Joint(X)
m = RigidBodyMotion(joint,body)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1 linked system(s) of bodies
   1 bodies
   1 joints
</code></pre><p>We don&#39;t have to do anything more here because the placement of the body is trivial. However, to demonstrate how we might do it in other problems,</p><pre><code class="language-julia hljs">x = zero_motion_state(body,m)
update_body!(body,x,m)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Circular body with 448 points and radius 1.0
   Current position: (0.0,0.0)
   Current angle (rad): 0.0
</code></pre><h3 id="Specify-the-physical-parameters,-data,-etc."><a class="docs-heading-anchor" href="#Specify-the-physical-parameters,-data,-etc.">Specify the physical parameters, data, etc.</a><a id="Specify-the-physical-parameters,-data,-etc.-1"></a><a class="docs-heading-anchor-permalink" href="#Specify-the-physical-parameters,-data,-etc." title="Permalink"></a></h3><p>These can be changed later without having to regenerate the system.</p><p>Here, we create a dict with physical parameters to be passed in.</p><pre><code class="language-julia hljs">phys_params = Dict(&quot;diffusivity&quot; =&gt; 1.0, &quot;Fourier&quot; =&gt; 1.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Float64} with 2 entries:
  &quot;Fourier&quot;     =&gt; 1.0
  &quot;diffusivity&quot; =&gt; 1.0</code></pre><p>The temperature boundary functions on the exterior and interior are defined here and assembled into a dict. Note that these functions must have a slightly more complex signature than in time-invariant problems: for generality, they must accept the time argument and another argument accepting possible motions of the surfaces.</p><pre><code class="language-julia hljs">get_Tbplus(t,x,base_cache,phys_params,motions) = zeros_surface(base_cache)
get_Tbminus(t,x,base_cache,phys_params,motions) = ones_surface(base_cache)
bcdict = Dict(&quot;exterior&quot; =&gt; get_Tbplus,&quot;interior&quot; =&gt; get_Tbminus)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Function} with 2 entries:
  &quot;interior&quot; =&gt; get_Tbminus
  &quot;exterior&quot; =&gt; get_Tbplus</code></pre><p>Construct the problem, passing in the data and functions we&#39;ve just created. We pass in the body&#39;s motion (however trivial) via the <code>motions</code> keyword.</p><pre><code class="language-julia hljs">prob = DirichletHeatConductionProblem(g,body,scaling=GridScaling,
                                             phys_params=phys_params,
                                             bc=bcdict,
                                             motions=m,
                                             timestep_func=timestep_fourier);</code></pre><p>Construct the system</p><pre><code class="language-julia hljs">sys = construct_system(prob);</code></pre><h3 id="Solving-the-problem"><a class="docs-heading-anchor" href="#Solving-the-problem">Solving the problem</a><a id="Solving-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-problem" title="Permalink"></a></h3><p>In contrast to the previous (time-independent) example, we have not extended the <code>solve</code> function here to serve us in solving this problem. Instead, we rely on the tools in <code>ConstrainedSystems.jl</code> to advance the solution forward in time. This package builds from the <code>OrdinaryDiffEq.jl</code> package, and leverages most of the tools of that package.</p><p>Set an initial condition. Here, we just get an initial (zeroed) copy of the solution prototype that we have stored in the extra cache. We also get the time step size for our own inspection.</p><pre><code class="language-julia hljs">u0 = init_sol(sys)
Δt = timestep_fourier(u0,sys)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0001</code></pre><p>It is instructive to note that <code>u0</code> has two parts: a <em>state</em> and a <em>constraint</em>, each obtained respectively with a convenience function. The state in this case is the temperature; the constraint is the Lagrange multiplier.</p><pre><code class="language-julia hljs">state(u0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Nodes{Primal, 405, 405, Float64, Matrix{Float64}} data
Printing in grid orientation (lower left is (1,1))
404×404 Matrix{Float64}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 ⋮                        ⋮              ⋱                 ⋮              
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0</code></pre><pre><code class="language-julia hljs">constraint(u0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">448 points of scalar-valued Float64 data
448-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 ⋮
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0</code></pre><p>Now, create the integrator, with a time interval of 0 to 1. We have not specified the algorithm here explicitly; it defaults to the <code>LiskaIFHERK()</code> time-marching algorithm, which is a second-order algorithm for constrained ODE systems that utilizes a matrix exponential (i.e., integrating factor) for the linear part of the problem (the Laplacian), and a half-explicit Runge-Kutta method for the constrained part. This method is most suitable for problems in which there is no dependence on the Lagrange multipliers in the constraint. (Such a problem is an index-2 differential-algebraic equation.) Another possible choice for this problem is the first-order Euler method, <code>IFHEEuler()</code>, which can be specified with the keyword <code>alg=IFHEEuler()</code>.</p><p>For problems that <em>do</em> have a constraint that depends on the Lagrange multipliers such as the Neumann problem (in an upcoming example), then the default method switches to <code>HETrapezoidalAB2()</code>, which uses a half-explicit trapezoidal method for the constrained and linear parts, and 2nd-order Adams-Bashforth for the explicit part.</p><pre><code class="language-julia hljs">tspan = (0.0,1.0)
integrator = init(u0,tspan,sys)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">t: 0.0
u: (Primal nodes in a (nx = 405, ny = 405) cell grid of type Float64 data
  Number of Primal nodes: (nx = 404, ny = 404), [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0])</code></pre><p>Now advance the solution by 0.01 convective time units, by using the <code>step!</code> function, which steps through the solution.</p><pre><code class="language-julia hljs">step!(integrator,0.01)</code></pre><h3 id="Plot-the-solution"><a class="docs-heading-anchor" href="#Plot-the-solution">Plot the solution</a><a id="Plot-the-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-the-solution" title="Permalink"></a></h3><p>The integrator holds the most recent solution in the field <code>u</code>, which has the same type as our initial condition <code>u0</code>. Here, we plot the state of the system at the end of the interval.</p><pre><code class="language-julia hljs">plot(state(integrator.u),sys)</code></pre><img src="80cd7e2f.svg" alt="Example block output"/><p>It would be nice to just define a function called <code>temperature</code> to get this more explicitly. We will do that here, and also apply a macro <code>@snapshotoutput</code> that automatically extends this function with some convenient interfaces. For example, if we simply pass in the integrator to <code>temperature</code>, it will pick off the <code>u</code> field for us.</p><pre><code class="language-julia hljs">temperature(T,σ,x,sys::ILMSystem,t) = T
@snapshotoutput temperature</code></pre><p>Now we can write</p><pre><code class="language-julia hljs">plot(temperature(integrator),sys)</code></pre><img src="68baefe1.svg" alt="Example block output"/><p>The solution history is in the field <code>integrator.sol</code>. The macro we called earlier enables temperature to work for this, as well, and we can obtain the temperature at <em>any</em> time in the interval of our solution. For example, to get the solution at time 0.51:</p><pre><code class="language-julia hljs">sol = integrator.sol
plot(temperature(sol,sys,0.0051),sys)</code></pre><img src="56f152e0.svg" alt="Example block output"/><p>We can also get it for an array of times, e.g.,</p><pre><code class="language-julia hljs">temperature(sol,sys,0.0051:0.0001:0.0061);</code></pre><p>This also gives us a spatially-interpolated version of the temperature field. To get this interpolated version at <span>$t = 0.0051$</span>, for example,</p><pre><code class="language-julia hljs">Tfcn = temperature_xy(sol,sys,0.0051)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">404×404 extrapolate(scale(interpolate(OffsetArray(::Matrix{Float64}, 0:405, 0:405), BSpline(Cubic(Line(Interpolations.OnGrid())))), (-2.0100000000000002:0.01:2.02, -2.0100000000000002:0.01:2.02)), (Flat(), Flat())) with element type Float64:
 -2.7537e-18   -3.99813e-17  -3.65472e-17  …  -4.68104e-17  -5.05833e-17
 -1.74441e-17  -6.76923e-17  -7.74097e-17     -7.51961e-17  -6.82713e-17
 -3.1062e-17   -8.99705e-17  -1.12243e-16     -9.54533e-17  -7.67536e-17
 -4.34224e-17  -1.09607e-16  -1.42209e-16     -1.06694e-16  -7.7899e-17
 -5.38233e-17  -1.26443e-16  -1.66029e-16     -1.10536e-16  -7.55207e-17
 -6.12725e-17  -1.36771e-16  -1.82459e-16  …  -1.09833e-16  -7.22332e-17
 -6.46058e-17  -1.39455e-16  -1.9086e-16      -1.06826e-16  -6.8011e-17
 -6.48337e-17  -1.38841e-16  -1.93397e-16     -1.01305e-16  -6.27889e-17
 -6.56644e-17  -1.39301e-16  -1.93008e-16     -9.5566e-17   -5.87799e-17
 -6.85895e-17  -1.41641e-16  -1.93746e-16     -9.21362e-17  -5.68522e-17
  ⋮                                        ⋱                
  8.55246e-17   1.37708e-16   1.74801e-16  …  -1.99555e-17  -4.02151e-17
  7.30578e-17   1.16038e-16   1.48301e-16     -3.68497e-17  -5.15393e-17
  5.92352e-17   9.18419e-17   1.19415e-16     -5.08154e-17  -5.89327e-17
  4.66567e-17   6.85119e-17   8.88779e-17     -5.60286e-17  -6.04846e-17
  3.40532e-17   4.62141e-17   5.94741e-17     -5.2648e-17   -5.88369e-17
  2.11665e-17   2.452e-17     3.27638e-17  …  -4.12005e-17  -5.35524e-17
  9.60593e-18   4.70477e-18   1.00469e-17     -2.54438e-17  -4.42277e-17
 -2.68404e-19  -1.08696e-17  -5.14598e-18     -8.61569e-18  -3.19712e-17
 -7.51694e-18  -2.16372e-17  -1.17348e-17      9.01942e-18  -1.85712e-17</code></pre><p>And then, to get the temperature at location <span>$(x,y) = (-0.9,0)$</span>, for example,</p><pre><code class="language-julia hljs">Tfcn(-0.9,0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.3584147231951137</code></pre><p>We can also get a time array of these spatially-interpolated fields by supplying <code>temperature_xy</code> with an array of times.</p><pre><code class="language-julia hljs">Tfcn_array = temperature_xy(sol,sys,0.0051:0.0001:0.0061);</code></pre><p>Then, each element in <code>Tfcn_array</code> corresponds to an entry in the given time array, and can be accessed at an <span>$(x,y)$</span> point.</p><pre><code class="language-julia hljs">Tfcn_array[4](-0.9,0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.3728574046514253</code></pre><h2 id="Motions"><a class="docs-heading-anchor" href="#Motions">Motions</a><a id="Motions-1"></a><a class="docs-heading-anchor-permalink" href="#Motions" title="Permalink"></a></h2><p>It is straightforward to make bodies move in time-varying problems, using the <code>RigidBodyMotion</code> function. In the previous example we used this in a trivial fashion. Here, we will use it in a non-trivial example. The only caveat is that the time-stepping becomes slower in such problems, since the system operators must be regenerated at every time step.</p><p>The <code>RigidBodyTools.jl</code> package provides a versatile set of motions, both rigid-body and deforming, and associated tools.</p><h3 id="Rigid-body-motion"><a class="docs-heading-anchor" href="#Rigid-body-motion">Rigid body motion</a><a id="Rigid-body-motion-1"></a><a class="docs-heading-anchor-permalink" href="#Rigid-body-motion" title="Permalink"></a></h3><p>For example, to simply make the body move at constant velocity 1 in the <code>x</code> direction.</p><pre><code class="language-julia hljs">Xp_to_jp = MotionTransform([0,0],0)
Xc_to_jc = MotionTransform([0,0],0)
dofs = [ConstantVelocityDOF(0),ConstantVelocityDOF(1),ConstantVelocityDOF(0)]
joint = Joint(FreeJoint2d,0,Xp_to_jp,1,Xc_to_jc,dofs)
m = RigidBodyMotion(joint,body)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1 linked system(s) of bodies
   1 bodies
   1 joints
</code></pre><p>The <code>MotionTransform</code> operator <code>Xp_to_jp</code> places the parent side of the joint at the origin of the inertial coordinate system (body 0) with no rotation, and <code>Xc_to_jc</code> places the child side of the joint at the origin of the body&#39;s system (body 1), also with no rotation. We are creating a <em>free</em> joint, with all degrees of freedom possibly in motion.</p><p>These three degrees of freedom are all assigned a prescribed behavior in the <code>dofs</code> vector. They are ordered as [rotation, x position, y position]. The rotational and y degrees of freedom are all set to zero velocity and the x degree is set to velocity of 1.</p><h3 id="Surface-deformation"><a class="docs-heading-anchor" href="#Surface-deformation">Surface deformation</a><a id="Surface-deformation-1"></a><a class="docs-heading-anchor-permalink" href="#Surface-deformation" title="Permalink"></a></h3><p>Deformations to the body surface can be superposed on rigid body motions. Here&#39;s an example of a deforming motion on a stationary body</p><pre><code class="language-julia hljs">ufcn(x,y,t) = 0.25*x*y*cos(t)
vfcn(x,y,t) = 0.25*(x^2-y^2)*cos(t)
def = DeformationMotion(ufcn,vfcn)
X = MotionTransform([0,0],0)
joint = Joint(X)
m = RigidBodyMotion(joint,body,def)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1 linked system(s) of bodies
   1 bodies
   1 joints
</code></pre><p>Either of these would be provided in the <code>motions</code> keyword of the problem construction. Consult the documentation of <code>RigidBodyTools.jl</code> to learn more about these. However, for time-marching purposes, it is helpful to know that the maximum surface velocity is provided by the <code>maxvelocity</code> function:</p><pre><code class="language-julia hljs">x = zero_motion_state(body,m)
maxvelocity(body,x,m)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.24998770586539437, 225, 0.0, 1)</code></pre><p>The first element of the output is the maximum velocity, the second is the index on which it occurs, the third is the time at which it occurs, and the fourth is the body on which it occurs.</p><h2 id="Time-varying-PDE-functions"><a class="docs-heading-anchor" href="#Time-varying-PDE-functions">Time-varying PDE functions</a><a id="Time-varying-PDE-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Time-varying-PDE-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.ODEFunctionList" href="#ImmersedLayers.ODEFunctionList"><code>ImmersedLayers.ODEFunctionList</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ODEFunctionList</code></pre><p><strong>Constructor</strong></p><p><code>ODEFunctionList(state=nothing,constraint=nothing,ode_rhs=nothing,bc_rhs=nothing,constraint_force=nothing,bc_op=nothing,lin_op=nothing)</code></p><p>Supply functions and data types for a constrained ODE system. The specified functions must provide the various parts that comprise the constrained ODE system</p><p><span>$\dfrac{dy}{dt} = Ly - B_1 z + r_1(y,t)$</span></p><p><span>$B_2 y + C z = r_2(t)$</span></p><p>The functions can be in in-place or out-of-place form, but they must all be consistently of the same form.</p><ul><li><p><code>state =</code> specifies a prototype of the state vector <span>$y$</span>.</p></li><li><p><code>constraint =</code> specifies a prototype of the constraint force vector <span>$z$</span>. If there are no constraints, this can be omitted.</p></li><li><p><code>ode_rhs =</code> specifies the right-hand side of the ODEs, <span>$r_1$</span>. The in-place form of the function is <code>r1(dy,y,x,sys::ILMSystem,t)</code>, the state vector <code>y</code>, IL system <code>sys</code>, time <code>t</code>, and returning <span>$dy/dt$</span>. The out-of-place form is <code>r1(y,x,sys,t)</code>.</p></li><li><p><code>bc_rhs =</code> specifies the right-hand side of the boundary conditions, <span>$r_2$</span>. If there are no constraints, this can be omitted. The in-place form is <code>r2(dz,x,sys,t)</code>, returning <code>dz</code>, the part of the boundary constraint not dependent on the state vector. The out-of-place form is <code>r2(x,sys,t)</code>.</p></li><li><p><code>constraint_force =</code> supplies the constraint force term in the ODEs, <span>$B_1 z$</span>. If there are no constraints, this can be omitted. The in-place form is <code>B1(dy,z,x,sys)</code>, returning the contribution to <span>$dy/dt$</span> (with the sign convention shown in the equations above) and the out-of-place form is <code>B1(z,x,sys)</code>.</p></li><li><p><code>bc_op =</code> supplies the left-hand side of the boundary constraint, <span>$B_2 y$</span>. If there are no constraints, this can be omitted. The in-place form is <code>B2(dz,y,x,sys)</code>, the out-of-place form is <code>B2(y,x,sys)</code>.</p></li><li><p><code>bc_regulator =</code> supplies the boundary constraint&#39;s regulation operation, <span>$C z$</span>. If there is none, this can be omitted. The in-place form is <code>C(dz,z,x,sys)</code>, the out-of-place form is <code>C(z,x,sys)</code>.</p></li><li><p><code>ode_implicit_rhs =</code> specifies an optional part of the RHS to be treated implicitly. If there is none, this can be omitted. The in-place form is <code>r1imp(dy,x,sys,t)</code>, the out-of-place form is <code>r1imp(x,sys,t)</code>.</p></li><li><p><code>lin_op =</code> is optional and specifies a linear operator on the state vector <span>$L$</span>, to be treated with an exponential integral (i.e., integrating factor) in the time marching. (Alternatively, this part can simply be included in <code>r_1</code>). It should have an associated <code>mul!</code> operation that acts upon the state vector.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/2440c27883bc700d55e524b423e42c499da78694/src/timemarching.jl#L7-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.zeros_sol" href="#ImmersedLayers.zeros_sol"><code>ImmersedLayers.zeros_sol</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zeros_sol(sys::ILMSystem)</code></pre><p>Return a zeroed version of the solution vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/2440c27883bc700d55e524b423e42c499da78694/src/timemarching.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.init_sol" href="#ImmersedLayers.init_sol"><code>ImmersedLayers.init_sol</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_sol(sys::ILMSystem)</code></pre><p>Return the initial solution vector, with the state component set to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/2440c27883bc700d55e524b423e42c499da78694/src/timemarching.jl#L142-L147">source</a></section><section><div><pre><code class="language-julia hljs">init_sol(s::AbstractSpatialField,sys::ILMSystem)</code></pre><p>Return the initial solution vector, with the state component set to the field established by <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/2440c27883bc700d55e524b423e42c499da78694/src/timemarching.jl#L153-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CommonSolve.init" href="#CommonSolve.init"><code>CommonSolve.init</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConstrainedSystems.init(u0,tspan,sys::ILMSystem,[alg=LiskaIFHERK()/HETrapezoidalAB2()])</code></pre><p>Initialize the integrator for a time-varying immersed-layer system of PDEs, described in <code>sys</code>. The default time marching algorithm in the keyword algorithm is chosen automatically based on whether there is an invertible <code>bc_regulator</code> operator in the system. If so, then <code>HETrapezoidalAB2()</code> is chosen; otherwise, <code>LiskaIFHERK()</code> is chosen. Both are second-order accurate. Another choice is <code>IFHEEuler()</code>, also suitable for problems with no invertible <code>bc_regulator</code> matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/2440c27883bc700d55e524b423e42c499da78694/src/timemarching.jl#L244-L253">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.timestep" href="#ImmersedLayers.timestep"><code>ImmersedLayers.timestep</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">timestep(u,sys::ILMSystem) -&gt; Float64</code></pre><p>Return the timestep of the system <code>sys</code> with state vector <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/2440c27883bc700d55e524b423e42c499da78694/src/timemarching.jl#L237-L241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.evaluate_motion!" href="#ImmersedLayers.evaluate_motion!"><code>ImmersedLayers.evaluate_motion!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluate_motion!(motion::ILMMotion,x::AbstractVector,t::Real)</code></pre><p>Given the current joint state vector <code>x</code> and time <code>t</code>, update the body transforms and velocities in <code>motion</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/2440c27883bc700d55e524b423e42c499da78694/src/motions.jl#L27-L32">source</a></section><section><div><pre><code class="language-julia hljs">evaluate_motion!(sys::ILMSystem,x::AbstractVector,t::Real)</code></pre><p>Given the current joint state vector <code>x</code> and time <code>t</code>, update the body transforms and velocities in <code>sys.motions</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/2440c27883bc700d55e524b423e42c499da78694/src/motions.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.surface_velocity_in_translating_frame!" href="#ImmersedLayers.surface_velocity_in_translating_frame!"><code>ImmersedLayers.surface_velocity_in_translating_frame!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">surface_velocity_in_translating_frame!(vel,x,base_cache,motions,t)</code></pre><p>Evaluates the surface velocity when the problem is set up in a moving frame of reference (specified with the <code>reference_body</code> keyword). It removes the translational velocity of the reference body, since this is applied as a free stream velocity (with change of sign).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/2440c27883bc700d55e524b423e42c499da78694/src/system.jl#L108-L115">source</a></section></article><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../stokes/">« Stokes flow</a><a class="docs-footer-nextpage" href="../heatconduction-unbounded/">A time-varying PDE with forcing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Friday 18 April 2025 20:49">Friday 18 April 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
