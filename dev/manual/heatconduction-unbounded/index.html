<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>A time-varying PDE with forcing · ImmersedLayers.jl</title><meta name="title" content="A time-varying PDE with forcing · ImmersedLayers.jl"/><meta property="og:title" content="A time-varying PDE with forcing · ImmersedLayers.jl"/><meta property="twitter:title" content="A time-varying PDE with forcing · ImmersedLayers.jl"/><meta name="description" content="Documentation for ImmersedLayers.jl."/><meta property="og:description" content="Documentation for ImmersedLayers.jl."/><meta property="twitter:description" content="Documentation for ImmersedLayers.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ImmersedLayers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../caches/">Immersed layer caches</a></li><li><a class="tocitem" href="../surfaceops/">Surface-grid operations</a></li><li><a class="tocitem" href="../multbodies/">Multiple bodies</a></li><li><a class="tocitem" href="../gridops/">Grid operations</a></li><li><a class="tocitem" href="../helmholtz/">Helmholtz decomposition</a></li><li><a class="tocitem" href="../matrices/">Matrix operators</a></li><li><a class="tocitem" href="../dirichlet/">A Dirichlet Poisson problem</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li></ul></li><li><span class="tocitem">Setting up PDEs</span><ul><li><a class="tocitem" href="../problems/">Problems and the system</a></li><li><a class="tocitem" href="../neumann/">Poisson with Neumann conditions</a></li><li><a class="tocitem" href="../stokes/">Stokes flow</a></li><li><a class="tocitem" href="../heatconduction/">Setting up a time-varying PDE</a></li><li class="is-active"><a class="tocitem" href>A time-varying PDE with forcing</a><ul class="internal"><li><a class="tocitem" href="#Specifying-the-forcing-regions-and-models-and-convection-velocity-model"><span>Specifying the forcing regions and models and convection velocity model</span></a></li><li><a class="tocitem" href="#Construct-the-ODE-function-and-the-extra-cache"><span>Construct the ODE function and the extra cache</span></a></li><li><a class="tocitem" href="#Set-up-the-problem-and-system"><span>Set up the problem and system</span></a></li><li><a class="tocitem" href="#Solve-the-problem"><span>Solve the problem</span></a></li><li><a class="tocitem" href="#Forcing-functions"><span>Forcing functions</span></a></li></ul></li><li><a class="tocitem" href="../heatconduction-neumann/">A time-varying PDE with Neumann conditions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Setting up PDEs</a></li><li class="is-active"><a href>A time-varying PDE with forcing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>A time-varying PDE with forcing</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaIBPM/ImmersedLayers.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/main/test/literate/heatconduction-unbounded.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="A-time-varying-PDE-with-forcing"><a class="docs-heading-anchor" href="#A-time-varying-PDE-with-forcing">A time-varying PDE with forcing</a><a id="A-time-varying-PDE-with-forcing-1"></a><a class="docs-heading-anchor-permalink" href="#A-time-varying-PDE-with-forcing" title="Permalink"></a></h1><p>In a previous example of the Poisson equation we demonstrated the use of point forcing. In this example we will explore other ways to apply forcing to a PDE. Our target problem will be similar to the most recent example – transient heat conduction – but now it will be in an unbounded domain. Our forcing will comprise local <em>area heating</em> and <em>line heating</em>. We will also include convection by an externally-imposed velocity field.</p><p>The governing equations are</p><p class="math-container">\[\dfrac{\partial T}{\partial t} + \mathbf{v}\cdot\nabla T = \kappa \nabla^2 T + q\]</p><p>where <span>$\mathbf{v}$</span> is a known convection velocity field and <span>$q$</span> is a known heating field (scaled by the density and specific heat)</p><p>In our discrete formulation, the problem takes the form</p><p class="math-container">\[\mathcal{L}_C^\kappa T = -N(\mathbf{v},T) + q\]</p><p>where <span>$N$</span> is a discrete approximation for the convection term <span>$\mathbf{v}\cdot\nabla T$</span>, and <span>$\mathcal{L}_C^\kappa = \mathrm{d}/\mathrm{d}t - \kappa L_C$</span> is the same diffusion operator as in the previous example. Note that these equations are no longer constrained. We only need to supply the right-hand side function. Our job here is to provide everything needed to compute this right-hand side.</p><p>We will apply the heating and cooling inside of local regions. As we discussed before, for each forcing, we supply information about the <strong>shape</strong> of the forcing region and the <strong>model function</strong>, supplying the forcing strength whenever we need it. We package these together into a forcing model and provide it to the problem via the <code>forcing</code> keyword.</p><p>The convection velocity also must be provided. We also make use of the <code>forcing</code> keyword to supply this to the problem, as well, in the form of a function that returns the current convection velocity at a given time <code>t</code>. The convective derivative term <code>N</code> requires a special cache, which we also generate in the <code>prob_cache</code>.</p><p>We will highlight these aspects in the example that follows. In this example, we will create</p><ul><li>a square-shaped line forcing region that delivers a certain amount of heat per unit length of line</li><li>a circular-shaped area forcing region that supplies heat based on the heat-transfer model <span>$h\cdot(T_0\cos(2\pi f t)-T)$</span>, where <span>$h$</span> is the heat transfer coefficient, <span>$T$</span> is the current local temperature,</li></ul><p>and <span>$T_0$</span> is the amplitude of an oscillatory heater temperature, oscillating at frequency <span>$f$</span></p><ul><li>a background rotational velocity field, with angular velocity <span>$\Omega$</span>.</li></ul><pre><code class="language-julia hljs">using ImmersedLayers
using Plots
using UnPack</code></pre><h3 id="Set-up-the-grid"><a class="docs-heading-anchor" href="#Set-up-the-grid">Set up the grid</a><a id="Set-up-the-grid-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-the-grid" title="Permalink"></a></h3><p>Let&#39;s set up the grid first before we go any further</p><pre><code class="language-julia hljs">Δx = 0.01
Lx = 4.0
xlim = (-Lx/2,Lx/2)
ylim = (-Lx/2,Lx/2)
g = PhysicalGrid(xlim,ylim,Δx);</code></pre><h3 id="Specify-the-physical-parameters"><a class="docs-heading-anchor" href="#Specify-the-physical-parameters">Specify the physical parameters</a><a id="Specify-the-physical-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Specify-the-physical-parameters" title="Permalink"></a></h3><p>We supply here the diffusivity (<span>$\kappa$</span>) and the uniform convection velocity. We also supply the grid Fourier number and a CFL number, which we will make use of later to calculate the time step size.</p><pre><code class="language-julia hljs">phys_params = Dict(&quot;diffusivity&quot; =&gt; 0.005,
                    &quot;angular velocity&quot; =&gt; 0.5,
                    &quot;length scale&quot; =&gt; Lx/2,
                     &quot;Fourier&quot; =&gt; 1.0,
                     &quot;CFL&quot; =&gt; 0.5,
                     &quot;lineheater_flux&quot; =&gt; -2.0,
                     &quot;areaheater_freq&quot; =&gt; 1.0,
                     &quot;areaheater_temp&quot; =&gt; 2.0,
                     &quot;areaheater_coeff&quot; =&gt; 100.0
                     )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Float64} with 9 entries:
  &quot;areaheater_coeff&quot; =&gt; 100.0
  &quot;Fourier&quot;          =&gt; 1.0
  &quot;areaheater_temp&quot;  =&gt; 2.0
  &quot;CFL&quot;              =&gt; 0.5
  &quot;diffusivity&quot;      =&gt; 0.005
  &quot;length scale&quot;     =&gt; 2.0
  &quot;lineheater_flux&quot;  =&gt; -2.0
  &quot;angular velocity&quot; =&gt; 0.5
  &quot;areaheater_freq&quot;  =&gt; 1.0</code></pre><h2 id="Specifying-the-forcing-regions-and-models-and-convection-velocity-model"><a class="docs-heading-anchor" href="#Specifying-the-forcing-regions-and-models-and-convection-velocity-model">Specifying the forcing regions and models and convection velocity model</a><a id="Specifying-the-forcing-regions-and-models-and-convection-velocity-model-1"></a><a class="docs-heading-anchor-permalink" href="#Specifying-the-forcing-regions-and-models-and-convection-velocity-model" title="Permalink"></a></h2><p>We first create the square line heater and place it at <span>$(0,1)$</span>. Its associated model function is very simple, since it just sets the strength uniformly. But note the function signature, which must always take this form. It can make use of the current temperature, time, and physical parameters, to return the strength of the line forcing. We bundle these together using <a href="../problems/#ImmersedLayers.LineForcingModel"><code>LineForcingModel</code></a>.</p><pre><code class="language-julia hljs">fregion1 = Square(0.5,1.4*Δx)
tr1 = RigidTransform((0.0,1.0),0.0)

function model1!(σ,T,t,fr::LineRegionCache,phys_params)
    σ .= phys_params[&quot;lineheater_flux&quot;]
end
lfm = LineForcingModel(fregion1,tr1,model1!);</code></pre><p>Now the oscillatory heater, which we place at <span>$(0,-0.5)$</span>. This one has a few more parameters, since we provide the heat transfer coefficient and the amplitude and frequency of the target temperature. These are bundled with <a href="../problems/#ImmersedLayers.AreaForcingModel"><code>AreaForcingModel</code></a>.</p><pre><code class="language-julia hljs">fregion2 = Circle(0.2,1.4*Δx)
tr2 = RigidTransform((0.0,-0.5),0.0)

function model2!(σ,T,t,fr::AreaRegionCache,phys_params)
    f = phys_params[&quot;areaheater_freq&quot;]
    T0 = phys_params[&quot;areaheater_temp&quot;]
    h = phys_params[&quot;areaheater_coeff&quot;]
    σ .= h*(T0*cos(2π*f*t) - T)
end
afm = AreaForcingModel(fregion2,tr2,model2!);</code></pre><p>Finally, the convection velocity model. Here, we make use of the coordinate function <a href="../caches/#ImmersedLayers.x_gridgrad"><code>x_gridgrad</code></a> and <a href="../caches/#ImmersedLayers.y_gridgrad"><code>y_gridgrad</code></a> to supply the coordinates of the velocity grid points. Since this is a staggered grid, the velocity components live at different places. For example, <code>yg.u</code> denotes the <span>$y$</span> coordinates for the horizontal velocity components, and <code>xg.v</code> denotes the <span>$x$</span> coordinates for the vertical velocity components.</p><pre><code class="language-julia hljs">function my_velocity!(vel,t,cache,phys_params)
    xg, yg = x_gridgrad(cache), y_gridgrad(cache)
    Ω = phys_params[&quot;angular velocity&quot;]
    vel.u .= -Ω*yg.u
    vel.v .= Ω*xg.v
    return vel
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">my_velocity! (generic function with 1 method)</code></pre><p>We pack the forcing and convection together into the <em>forcing</em> <code>Dict</code>:</p><pre><code class="language-julia hljs">forcing_dict = Dict(&quot;heating models&quot; =&gt; [lfm,afm],
                    &quot;convection velocity model&quot; =&gt; my_velocity!)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Any} with 2 entries:
  &quot;convection velocity model&quot; =&gt; my_velocity!
  &quot;heating models&quot;            =&gt; AbstractForcingModel[LineForcingModel{Polygon{…</code></pre><h2 id="Construct-the-ODE-function-and-the-extra-cache"><a class="docs-heading-anchor" href="#Construct-the-ODE-function-and-the-extra-cache">Construct the ODE function and the extra cache</a><a id="Construct-the-ODE-function-and-the-extra-cache-1"></a><a class="docs-heading-anchor-permalink" href="#Construct-the-ODE-function-and-the-extra-cache" title="Permalink"></a></h2><p>For the RHS of the heat conduction equation, we calculate the convective derivative and the external heating.</p><pre><code class="language-julia hljs">function heatconduction_rhs!(dT,T,x,sys::ILMSystem,t)
    @unpack forcing, phys_params, extra_cache, base_cache = sys
    @unpack cdcache, fcache, v, dT_tmp = extra_cache

    # This provides the convection velocity at time `t`
    forcing[&quot;convection velocity model&quot;](v,t,base_cache,phys_params)

    # Compute the convective derivative term `N(v,T)`
    fill!(dT_tmp,0.0)
    convective_derivative!(dT_tmp,v,T,base_cache,cdcache)
    dT .= -dT_tmp

    # Compute the contribution from the forcing models to the right-hand side
    fill!(dT_tmp,0.0)
    apply_forcing!(dT_tmp,T,x,t,fcache,sys)
    dT .+= dT_tmp

    return dT
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">heatconduction_rhs! (generic function with 1 method)</code></pre><p>We create a problem type for this, define the extra cache, and extend <code>prob_cache</code></p><pre><code class="language-julia hljs">@ilmproblem UnboundedHeatConduction scalar

struct UnboundedHeatConductionCache{VT,CDT,FRT,DTT,FT} &lt;: AbstractExtraILMCache
   v :: VT
   cdcache :: CDT
   fcache :: FRT
   dT_tmp :: DTT
   f :: FT
end

function ImmersedLayers.prob_cache(prob::UnboundedHeatConductionProblem,
                                   base_cache::BasicILMCache{N,scaling}) where {N,scaling}
    @unpack phys_params, forcing = prob
    @unpack gdata_cache, g = base_cache

    # Construct a Lapacian outfitted with the diffusivity
    κ = phys_params[&quot;diffusivity&quot;]
    heat_L = Laplacian(base_cache,κ)

    # Create cache for the convective derivative
    v = zeros_gridgrad(base_cache)
    cdcache = ConvectiveDerivativeCache(base_cache)

    # Create cache for the forcing regions
    fcache = ForcingModelAndRegion(forcing[&quot;heating models&quot;],base_cache)

    dT_tmp = zeros_grid(base_cache)

    # The state here is temperature, and we just supply the RHS function
    f = ODEFunctionList(state = zeros_grid(base_cache),
                        ode_rhs=heatconduction_rhs!,
                        lin_op=heat_L)

    UnboundedHeatConductionCache(v,cdcache,fcache,dT_tmp,f)
end</code></pre><p>The last definition we need is for a timestep function. This time, we take into account both the Fourier and the CFL conditions:</p><pre><code class="language-julia hljs">function timestep_fourier_cfl(u,sys)
    @unpack phys_params = sys
    g = get_grid(sys)
    κ = phys_params[&quot;diffusivity&quot;]
    Ω = phys_params[&quot;angular velocity&quot;]
    L = phys_params[&quot;length scale&quot;]
    Fo = phys_params[&quot;Fourier&quot;]
    Co = phys_params[&quot;CFL&quot;]
    Δt = min(Fo*cellsize(g)^2/κ,Co*cellsize(g)/Ω/L)
    return Δt
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">timestep_fourier_cfl (generic function with 1 method)</code></pre><p>As in the last example, we also define the temperature output function for output</p><pre><code class="language-julia hljs">temperature(T,σ,x,sys::ILMSystem,t) = T
@snapshotoutput temperature</code></pre><h2 id="Set-up-the-problem-and-system"><a class="docs-heading-anchor" href="#Set-up-the-problem-and-system">Set up the problem and system</a><a id="Set-up-the-problem-and-system-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-the-problem-and-system" title="Permalink"></a></h2><p>This is similar to previous problems.</p><pre><code class="language-julia hljs">prob = UnboundedHeatConductionProblem(g,scaling=GridScaling,
                                        phys_params=phys_params,
                                        forcing=forcing_dict,
                                        timestep_func=timestep_fourier_cfl)

sys = construct_system(prob);</code></pre><h2 id="Solve-the-problem"><a class="docs-heading-anchor" href="#Solve-the-problem">Solve the problem</a><a id="Solve-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-the-problem" title="Permalink"></a></h2><p>As before, we first initialize the state, then we create an integrator, and finally, advance the solution in time</p><pre><code class="language-julia hljs">u0 = init_sol(sys)
tspan = (0.0,2.0)
integrator = init(u0,tspan,sys)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">t: 0.0
u: (Primal nodes in a (nx = 405, ny = 405) cell grid of type Float64 data
  Number of Primal nodes: (nx = 404, ny = 404), Float64[])</code></pre><p>Run the problem for one time unit</p><pre><code class="language-julia hljs">step!(integrator,1.0)</code></pre><p>Let&#39;s see what this looks like. We will plot a set of snapshots in an array.</p><pre><code class="language-julia hljs">sol = integrator.sol

plt = plot(layout = (2,3), size = (700, 500), legend=:false)
for (i,t) in enumerate(0:0.2:1.0)
   plot!(plt[i],temperature(sol,sys,t),sys,levels=range(-10,2,length=30),clim=(-10,2))
end
plt</code></pre><img src="1f419b55.svg" alt="Example block output"/><h2 id="Forcing-functions"><a class="docs-heading-anchor" href="#Forcing-functions">Forcing functions</a><a id="Forcing-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Forcing-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.points-Tuple{ImmersedLayers.PointCollectionCache}" href="#ImmersedLayers.points-Tuple{ImmersedLayers.PointCollectionCache}"><code>ImmersedLayers.points</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">points(cache::PointCollectionCache)</code></pre><p>Return the coordinates (as <code>VectorData</code>) of the surface points associated with <code>cache</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/2440c27883bc700d55e524b423e42c499da78694/src/cache.jl#L786-L790">source</a></section></article><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../heatconduction/">« Setting up a time-varying PDE</a><a class="docs-footer-nextpage" href="../heatconduction-neumann/">A time-varying PDE with Neumann conditions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Friday 18 April 2025 20:49">Friday 18 April 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
