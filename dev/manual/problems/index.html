<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Problems and the system · ImmersedLayers.jl</title><meta name="title" content="Problems and the system · ImmersedLayers.jl"/><meta property="og:title" content="Problems and the system · ImmersedLayers.jl"/><meta property="twitter:title" content="Problems and the system · ImmersedLayers.jl"/><meta name="description" content="Documentation for ImmersedLayers.jl."/><meta property="og:description" content="Documentation for ImmersedLayers.jl."/><meta property="twitter:description" content="Documentation for ImmersedLayers.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ImmersedLayers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../caches/">Immersed layer caches</a></li><li><a class="tocitem" href="../surfaceops/">Surface-grid operations</a></li><li><a class="tocitem" href="../multbodies/">Multiple bodies</a></li><li><a class="tocitem" href="../gridops/">Grid operations</a></li><li><a class="tocitem" href="../helmholtz/">Helmholtz decomposition</a></li><li><a class="tocitem" href="../matrices/">Matrix operators</a></li><li><a class="tocitem" href="../dirichlet/">A Dirichlet Poisson problem</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li></ul></li><li><span class="tocitem">Setting up PDEs</span><ul><li class="is-active"><a class="tocitem" href>Problems and the system</a><ul class="internal"><li><a class="tocitem" href="#Example-of-problem-and-system-use"><span>Example of problem and system use</span></a></li><li><a class="tocitem" href="#More-advanced-use,-with-keyword-arguments"><span>More advanced use, with keyword arguments</span></a></li><li><a class="tocitem" href="#Problem-types-and-functions"><span>Problem types and functions</span></a></li><li><a class="tocitem" href="#System-types-and-functions"><span>System types and functions</span></a></li><li><a class="tocitem" href="#Forcing-functions"><span>Forcing functions</span></a></li><li><a class="tocitem" href="#Output-functions-and-macros"><span>Output functions and macros</span></a></li></ul></li><li><a class="tocitem" href="../neumann/">Poisson with Neumann conditions</a></li><li><a class="tocitem" href="../stokes/">Stokes flow</a></li><li><a class="tocitem" href="../heatconduction/">Setting up a time-varying PDE</a></li><li><a class="tocitem" href="../heatconduction-unbounded/">A time-varying PDE with forcing</a></li><li><a class="tocitem" href="../heatconduction-neumann/">A time-varying PDE with Neumann conditions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Setting up PDEs</a></li><li class="is-active"><a href>Problems and the system</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Problems and the system</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaIBPM/ImmersedLayers.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/main/test/literate/problems.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Problems-and-the-system"><a class="docs-heading-anchor" href="#Problems-and-the-system">Problems and the system</a><a id="Problems-and-the-system-1"></a><a class="docs-heading-anchor-permalink" href="#Problems-and-the-system" title="Permalink"></a></h1><p>In specific problems that we wish to solve with immersed layers, there may be other data and operators that we would like to cache. We do this with an <em>extra cache</em>, which the user can define, along with a problem type associated with this cache. The basic cache and the extra cache are generated and associated together in a <em>system</em>.</p><p>There are a few basic ingredients to do this:</p><ul><li><strong>Create a problem type</strong>, using the macro <code>@ilmproblem</code>. This mostly just serves as a means of dispatching correctly, but also holds the grid and bodies so they can be passed along when the caches are constructed.</li><li><strong>Create an extra cache type</strong>, making it a subtype of <code>AbstractExtraILMCache</code>. This can hold pretty much anything you want it to.</li><li><strong>Extend the function <code>prob_cache(prob,base_cache)</code></strong> to serve as a constructor for your extra cache, when your problem type is passed in.</li></ul><p>Optionally, you can also extend the function <code>solve</code> in order to perform the steps of your algorithm. However, generically, you can just use pass in the system structure, which holds the basic ILM cache and your extra cache, into any function.</p><h2 id="Example-of-problem-and-system-use"><a class="docs-heading-anchor" href="#Example-of-problem-and-system-use">Example of problem and system use</a><a id="Example-of-problem-and-system-use-1"></a><a class="docs-heading-anchor-permalink" href="#Example-of-problem-and-system-use" title="Permalink"></a></h2><p>We will demonstrate the use of problems and systems with the example given in <a href="../dirichlet/#A-Dirichlet-Poisson-problem">A Dirichlet Poisson problem</a>. Here, we will assemble the various additional data structures and operators used to solve this problem into an extra cache. We will also create a problem type called <code>DirichletPoissonProblem</code>, which we make a subtype of <code>AbstractScalarILMProblem</code>.</p><pre><code class="language-julia hljs">using ImmersedLayers
using Plots
using UnPack</code></pre><h3 id="Create-your-problem-type"><a class="docs-heading-anchor" href="#Create-your-problem-type">Create your problem type</a><a id="Create-your-problem-type-1"></a><a class="docs-heading-anchor-permalink" href="#Create-your-problem-type" title="Permalink"></a></h3><p>For this job, we have a macro</p><pre><code class="language-julia hljs">@ilmproblem DirichletPoisson scalar</code></pre><p>This generates a type <code>DirichletPoissonProblem</code> for dispatch, and an associated constructor that we&#39;ll use later.</p><h3 id="Create-your-extra-cache"><a class="docs-heading-anchor" href="#Create-your-extra-cache">Create your extra cache</a><a id="Create-your-extra-cache-1"></a><a class="docs-heading-anchor-permalink" href="#Create-your-extra-cache" title="Permalink"></a></h3><p>Here, we&#39;d like this extra cache to hold the Schur complement and the filtering matrices, as well as some cache variables.</p><pre><code class="language-julia hljs">struct DirichletPoissonCache{SMT,CMT,FRT,ST,FT} &lt;: ImmersedLayers.AbstractExtraILMCache
   S :: SMT
   C :: CMT
   forcing_cache :: FRT
   fb :: ST
   fstar :: FT
end</code></pre><h3 id="Extend-the-prob_cache-function"><a class="docs-heading-anchor" href="#Extend-the-prob_cache-function">Extend the <code>prob_cache</code> function</a><a id="Extend-the-prob_cache-function-1"></a><a class="docs-heading-anchor-permalink" href="#Extend-the-prob_cache-function" title="Permalink"></a></h3><p>We need this to construct our extra cache. This will get called when the system is constructed. We can make use of the data available in the <code>base_cache</code> (which is already constructed before this is called) in order to create the extra cache. (In the example here, we aren&#39;t quite ready to use the <code>forcing_cache</code>, so we just keep it blank for now. We will use it later.)</p><pre><code class="language-julia hljs">function ImmersedLayers.prob_cache(prob::DirichletPoissonProblem,base_cache::BasicILMCache)
    S = create_RTLinvR(base_cache)
    C = create_surface_filter(base_cache)
    forcing_cache = nothing
    fb = zeros_surface(base_cache)
    fstar = zeros_grid(base_cache)
    DirichletPoissonCache(S,C,forcing_cache,fb,fstar)
end</code></pre><h3 id="Extend-the-solve-function"><a class="docs-heading-anchor" href="#Extend-the-solve-function">Extend the <code>solve</code> function</a><a id="Extend-the-solve-function-1"></a><a class="docs-heading-anchor-permalink" href="#Extend-the-solve-function" title="Permalink"></a></h3><p>Here, we actually do the work of the algorithm, making use of all of the operators and data structures that we have cached for efficiency. The example below takes in some surface Dirichlet data <code>fbplus</code>, and returns the solutions <code>f</code> and <code>s</code> (filtered).</p><pre><code class="language-julia hljs">function ImmersedLayers.solve(fbplus,prob::DirichletPoissonProblem,sys::ILMSystem)
    @unpack extra_cache, base_cache = sys
    @unpack S, C, fb, fstar = extra_cache

    f = zeros_grid(base_cache)
    s = zeros_surface(base_cache)

    surface_divergence!(fstar,fbplus,base_cache)
    fb .= 0.5*fbplus

    inverse_laplacian!(fstar,base_cache)

    interpolate!(s,fstar,base_cache)
    s .= fb - s
    s .= -(S\s);

    regularize!(f,s,base_cache)
    inverse_laplacian!(f,base_cache)
    f .+= fstar;

    s .= C^6*s

    return f, s
end</code></pre><h3 id="Set-up-the-grid,-shape,-and-cache"><a class="docs-heading-anchor" href="#Set-up-the-grid,-shape,-and-cache">Set up the grid, shape, and cache</a><a id="Set-up-the-grid,-shape,-and-cache-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-the-grid,-shape,-and-cache" title="Permalink"></a></h3><p>We do this just as we did in <a href="../caches/#Immersed-layer-caches">Immersed layer caches</a>, but now we don&#39;t create a cache, since it will be done internally.</p><pre><code class="language-julia hljs">Δx = 0.01
Lx = 4.0
xlim = (-Lx/2,Lx/2)
ylim = (-Lx/2,Lx/2)
g = PhysicalGrid(xlim,ylim,Δx)
RadC = 1.0
Δs = 1.4*cellsize(g)
body = Circle(RadC,Δs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Circular body with 448 points and radius 1.0
   Current position: (0.0,0.0)
   Current angle (rad): 0.0
</code></pre><h3 id="Do-the-work"><a class="docs-heading-anchor" href="#Do-the-work">Do the work</a><a id="Do-the-work-1"></a><a class="docs-heading-anchor-permalink" href="#Do-the-work" title="Permalink"></a></h3><p>We do this in three steps:</p><ul><li>Create the problem instance. This is where we use the constructor generated by <code>@ilmproblem</code></li><li>Call <code>construct_system</code> to create the caches, assembled into a system</li><li>Call <code>solve</code> to solve the problem.</li></ul><p>Also, note that pretty much any function that accepts <code>base_cache</code> as an argument also accepts <code>sys</code>.</p><pre><code class="language-julia hljs">prob = DirichletPoissonProblem(g,body,scaling=GridScaling)
sys = construct_system(prob)

pts = points(sys)
f, s = solve(pts.u,prob,sys)

plot(f,sys)</code></pre><img src="6ba1341c.svg" alt="Example block output"/><pre><code class="language-julia hljs">plot(s,sys)</code></pre><img src="032f04ad.svg" alt="Example block output"/><h2 id="More-advanced-use,-with-keyword-arguments"><a class="docs-heading-anchor" href="#More-advanced-use,-with-keyword-arguments">More advanced use, with keyword arguments</a><a id="More-advanced-use,-with-keyword-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#More-advanced-use,-with-keyword-arguments" title="Permalink"></a></h2><p>In the previous example, we supplied the surface data as an argument directly to the <code>solve</code> function. We also didn&#39;t have any right-hand side forcing. But in a more general case we might have more complicated boundary conditions or forcing information. This will be particularly true when we get to time varying problems.</p><p>So in this next example, we will demonstrate how the problem constructor can be used to supply more sophisticated information to the <code>solve</code> function. In particular, we will use three keywords:</p><ul><li>The <code>bc</code> keyword to supply boundary condition information.</li><li>The <code>forcing</code> keyword to supply forcing.</li><li>The <code>phys_params</code> keyword to supply physical parameters.</li></ul><p>In general, the philosophy is that we wish to enable the user to provide a function that supplies the required boundary or forcing data. There is a lot of freedom in this approach, as we will demonstrate.</p><h3 id="Boundary-conditions"><a class="docs-heading-anchor" href="#Boundary-conditions">Boundary conditions</a><a id="Boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions" title="Permalink"></a></h3><p>Here, we wish to construct functions that return the value of <code>f</code> on the outside and inside of the surface. These functions will get called in the <code>solve</code> function, and they will be passed the base cache, the physical parameters. So we can make use of both of these to return the boundary data, e.g., here we return the <code>x</code> coordinate of the surface points on the outside of the surface, and zeros on the inside.</p><pre><code class="language-julia hljs">get_fbplus(base_cache,phys_params) = points(base_cache).u
get_fbminus(base_cache,phys_params) = zeros_surface(base_cache)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">get_fbminus (generic function with 1 method)</code></pre><p>Using the <code>bc</code> keyword, we can pass these along to the problem specification by various means. To make use of some routines that automate the application of these functions, we must pass them in a <code>Dict</code>, with the keys <code>exterior</code> and <code>interior</code>, respectively.</p><pre><code class="language-julia hljs">bcdict = Dict(&quot;exterior&quot;=&gt;get_fbplus,&quot;interior&quot;=&gt;get_fbminus)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Function} with 2 entries:
  &quot;interior&quot; =&gt; get_fbminus
  &quot;exterior&quot; =&gt; get_fbplus</code></pre><h3 id="Forcing"><a class="docs-heading-anchor" href="#Forcing">Forcing</a><a id="Forcing-1"></a><a class="docs-heading-anchor-permalink" href="#Forcing" title="Permalink"></a></h3><p>Forcing can come in several forms. It can be</p><ul><li><strong>area forcing</strong>, in which the forcing is distributed over a whole region, possibly confined</li><li><strong>line forcing</strong>, in which the forcing is distributed along a curve (but singular in the orthogonal direction)</li><li><strong>point forcing</strong>, in which the forcing is singular at one or more points</li></ul><p>In all cases, the user needs to supply some information about the <strong>shape</strong> of the forcing region and some information about the instantaneous strength of the forcing, in the form of a <strong>model function</strong>. These get bundled together into a <strong>forcing model</strong>.</p><p>For confined area forcing and for line forcing, the <strong>shape</strong> is supplied as a <code>Body</code> or <code>BodyList</code>, similar to bodies (serving as the mask for confined-area forcing and as the curve for line forcing). For point forcing, the <strong>shape</strong> is the set of discrete points at which we want to apply forcing. We can either supply these points&#39; coordinates directly or provide them via a <strong>position function</strong> that returns the point coordinates. The advantage of the latter is that it allows the points to be changed later without regenerating the system.</p><p>In the example shown here, we apply point forcing at two points: one at (-1.0,1.5) and the other at (1.0,1.5), with respective strengths -1 and 1. We use a <strong>position function</strong> to provide the positions. This function must have the signature as shown here, accepting a general <code>state</code> argument, a time argument <code>t</code>, the cache for this forcing, and physical parameters. Any of these can be used to help determine the point positions. In this case, we just simply provide the coordinates directly. However, it is straightforward to pass these in via the <code>state</code> argument (or perhaps to update the positions by some velocity).</p><pre><code class="language-julia hljs">function my_point_positions(state,t,fr::PointRegionCache,phys_params)
    x = [-1.0,1.0]
    y = [1.5,1.5]
    return x, y
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">my_point_positions (generic function with 1 method)</code></pre><p>The <strong>model function</strong> returns the strength of the forcing. In this point forcing example, it must return the strength of each point. It must be set up as an in-place function, accepting the vector of strengths and mutating (i.e. changing) this vector. Beyond that, it has the same signature as the position function.</p><pre><code class="language-julia hljs">function my_point_strengths!(σ,state,t,fr::PointRegionCache,phys_params)
    σ .= [-1.0,1.0]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">my_point_strengths! (generic function with 1 method)</code></pre><p>Now we bundle these together into the forcing model. We also tell it what kind of regularized DDF we want to use. We use the <span>$M_4&#39;$</span> DDF here. <code>pfm</code> will get passed into the problem setup via the <code>forcing</code> keyword.</p><pre><code class="language-julia hljs">pfm = PointForcingModel(my_point_positions,my_point_strengths!;ddftype=CartesianGrids.M4prime);</code></pre><p>Now, we need to make sure that the forcing data is used. When we generate the extra cache, we use the function <code>ForcingModelAndRegion</code> to assemble the forcing&#39;s cache.</p><pre><code class="language-julia hljs">function ImmersedLayers.prob_cache(prob::DirichletPoissonProblem,base_cache::BasicILMCache)
    @unpack phys_params, forcing = prob
    S = create_RTLinvR(base_cache)
    C = create_surface_filter(base_cache)
    forcing_cache = ForcingModelAndRegion(forcing,base_cache)
    fb = zeros_surface(base_cache)
    fstar = zeros_grid(base_cache)
    DirichletPoissonCache(S,C,forcing_cache,fb,fstar)
end</code></pre><p>We now redefine the <code>solve</code> function and use the boundary condition and forcing information. For the forcing, we make use of the function <code>apply_forcing!</code> which takes the forcing and automatically calculates the right-hand side field</p><pre><code class="language-julia hljs">function ImmersedLayers.solve(prob::DirichletPoissonProblem,sys::ILMSystem)
    @unpack bc, forcing, phys_params, extra_cache, base_cache = sys
    @unpack gdata_cache = base_cache
    @unpack S, C, forcing_cache, fb, fstar = extra_cache

    f = zeros_grid(base_cache)
    s = zeros_surface(base_cache)

    # apply_forcing! evaluates the forcing field on the grid and put
    # the result in the `gdata_cache`.
    fill!(gdata_cache,0.0)
    x, t = nothing, 0.0
    apply_forcing!(gdata_cache,f,x,t,forcing_cache,sys)

    # Get the prescribed jump in boundary data across the interface using
    # the functions we supplied via the `Dict`.
    prescribed_surface_jump!(fb,sys)

    # Evaluate the double-layer term and add it to the right-hand side
    surface_divergence!(fstar,fb,base_cache)
    fstar .+= gdata_cache

    # Intermediate solution
    inverse_laplacian!(fstar,base_cache)

    # Get the prescribed average of boundary data on the interface using
    # the functions we supplied via the `Dict`.
    prescribed_surface_average!(fb,sys)

    # Correction
    interpolate!(s,fstar,base_cache)
    s .= fb - s
    s .= -(S\s);

    regularize!(f,s,base_cache)
    inverse_laplacian!(f,base_cache)
    f .+= fstar;

    return f, C^6*s
end</code></pre><h3 id="Set-up-the-problem"><a class="docs-heading-anchor" href="#Set-up-the-problem">Set up the problem</a><a id="Set-up-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-the-problem" title="Permalink"></a></h3><p>Now we specify the problem, create the system, and solve it, as before, but now supplying the boundary condition and forcing information with the <code>bc</code> and <code>forcing</code> keywords:</p><pre><code class="language-julia hljs">prob = DirichletPoissonProblem(g,body,scaling=GridScaling,bc=bcdict,forcing=pfm)
sys = construct_system(prob)
f, s = solve(prob,sys)
plot(f,sys)</code></pre><img src="ceb7b27a.svg" alt="Example block output"/><p>So we get the additional features from the sources. Now, suppose we wish to change the the boundary conditions or source points? We can do it easily without regenerating the cache and system, simply by redefining our bc and forcing model functions. For example, to create an internal solution, with surface data equal to the <span>$y$</span> coordinate, and four sources inside.</p><pre><code class="language-julia hljs">get_fbplus(base_cache,phys_params) = zeros_surface(base_cache)
get_fbminus(base_cache,phys_params) = points(base_cache).v

function my_point_positions(state,t,fr::PointRegionCache,phys_params)
    x = [-0.2,0.2,-0.2,0.2]
    y = [0.2,0.2,-0.2,-0.2]
    return x, y
end
function my_point_strengths!(σ,state,t,fr::PointRegionCache,phys_params)
    σ .= [-1.0,1.0,-1.0,1.0]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">my_point_strengths! (generic function with 1 method)</code></pre><p>We can solve immediately without having to reconstruct the system, so it&#39;s very fast.</p><pre><code class="language-julia hljs">@time f, s = solve(prob,sys)
plot(f,sys)</code></pre><img src="9a4f7d20.svg" alt="Example block output"/><h2 id="Problem-types-and-functions"><a class="docs-heading-anchor" href="#Problem-types-and-functions">Problem types and functions</a><a id="Problem-types-and-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-types-and-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.AbstractScalarILMProblem" href="#ImmersedLayers.AbstractScalarILMProblem"><code>ImmersedLayers.AbstractScalarILMProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractScalarILMProblem{DT, ST, DTP} &lt;: ImmersedLayers.AbstractILMProblem{DT, ST, DTP}</code></pre><p>When defining a problem type with scalar data, make it a subtype of this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/problem.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.AbstractVectorILMProblem" href="#ImmersedLayers.AbstractVectorILMProblem"><code>ImmersedLayers.AbstractVectorILMProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractVectorILMProblem{DT, ST, DTP} &lt;: ImmersedLayers.AbstractILMProblem{DT, ST, DTP}</code></pre><p>When defining a problem type with vector data, make it a subtype of this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/problem.jl#L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.@ilmproblem" href="#ImmersedLayers.@ilmproblem"><code>ImmersedLayers.@ilmproblem</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>The <code>@ilmproblem</code> macro is used to automatically generate a type particular to an immersed-layer problem, which can then be used for dispatch on those types of problems. It takes two arguments: the name of the problem (to which <code>Problem</code> will be automatically appended), and whether the problem is of scalar or vector type. For example,</p><pre><code class="nohighlight hljs">@ilmproblem(StokesFlow,vector)</code></pre><p>would generate a type <code>StokesFlowProblem</code> dealing with vector-valued data. The resulting type then automatically has a constructor that allows one to pass in the grid information and bodies, as well as optional choices for the DDF function and the scaling type. For the example, this constructor would be</p><pre><code class="nohighlight hljs">StokesFlowProblem(grid,bodies[,ddftype=CartesianGrids.Yang3][,scaling=GridScaling])</code></pre><p>Note that there is another constructor for problems with no surfaces that only requires that the grid information be passed, e.g.,</p><pre><code class="nohighlight hljs">StokesFlowProblem(grid)</code></pre><p>There are several keyword arguments for the problem constructor</p><ul><li><code>ddftype =</code> to set the DDF type. The default is <code>Yang3</code>.</li><li><code>scaling =</code> to set the scaling type, <code>GridScaling</code> (default) or <code>IndexScaling</code>.</li><li><code>dtype =</code> to set the element type to <code>Float64</code> (default) or <code>ComplexF64</code>.</li><li><code>phys_params =</code> to pass in physical parameters</li><li><code>bc =</code> to pass in boundary condition data or functions</li><li><code>forcing =</code> to pass in forcing functions or data</li><li><code>motions =</code> to provide function(s) that specify the velocity of the immersed surface(s). Note: if this keyword is used, it is assumed that surfaces will move.</li><li><code>reference_body =</code> to provide the ID of the body whose axes the problem is solved in</li><li><code>timestep_func =</code> to pass in a function for time-dependent problems that provides the time-step size.                 It is expected that this function takes in two arguments,                 the <code>grid::PhysicalGrid</code> and <code>phys_params</code>, and returns the time step. It is up to the                 user to decide how to determine this. It could also simply return a                 constant value, regardless of the arguments.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/problem.jl#L20-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.BasicScalarILMProblem" href="#ImmersedLayers.BasicScalarILMProblem"><code>ImmersedLayers.BasicScalarILMProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BasicScalarILMProblem</code></pre><p>ILM problem type dealing with scalar-type data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/problem.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.BasicVectorILMProblem" href="#ImmersedLayers.BasicVectorILMProblem"><code>ImmersedLayers.BasicVectorILMProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BasicVectorILMProblem</code></pre><p>ILM problem type dealing with vector-type data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/problem.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.prob_cache" href="#ImmersedLayers.prob_cache"><code>ImmersedLayers.prob_cache</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prob_cache(prob,base_cache::BasicILMCache)</code></pre><p>This function is called automatically by <a href="#ImmersedLayers.construct_system"><code>construct_system</code></a> to generate a problem-specific extra cache. Extend this function in order to generate an extra cache for a user-defined problem type. The user must also define the cache type itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/problem.jl#L129-L135">source</a></section></article><h2 id="System-types-and-functions"><a class="docs-heading-anchor" href="#System-types-and-functions">System types and functions</a><a id="System-types-and-functions-1"></a><a class="docs-heading-anchor-permalink" href="#System-types-and-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.ILMSystem" href="#ImmersedLayers.ILMSystem"><code>ImmersedLayers.ILMSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct ILMSystem{static, PT, N, PHT, BCF, FF, DTF, MTF, BCT, ECT}</code></pre><p>A system of operators and caches for immersed layer problems. This is constructed by <a href="#ImmersedLayers.construct_system"><code>construct_system</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/ImmersedLayers.jl#L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.construct_system" href="#ImmersedLayers.construct_system"><code>ImmersedLayers.construct_system</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">construct_system(prob::AbstractILMProblem) -&gt; ILMSystem</code></pre><p>Return a system of type of type <code>ILMSystem</code> from the given problem instance <code>prob</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/system.jl#L12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.update_system" href="#ImmersedLayers.update_system"><code>ImmersedLayers.update_system</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_system(sysold::ILMSystem,body::Body/BodyList)</code></pre><p>From an existing system <code>sysold</code>, return a new system based on the Body or BodyList <code>body</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/system.jl#L20-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.update_system!" href="#ImmersedLayers.update_system!"><code>ImmersedLayers.update_system!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_system!(sys::ILMSystem,u,sysold,t)</code></pre><p>From an existing system <code>sysold</code> at time <code>t</code>, return a new system <code>sys</code> in place, based on the solution vector <code>u</code>, whose body state information will be used to replace the body information and subsequent operators in <code>sysold</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/system.jl#L31-L38">source</a></section></article><h2 id="Forcing-functions"><a class="docs-heading-anchor" href="#Forcing-functions">Forcing functions</a><a id="Forcing-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Forcing-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.AreaForcingModel" href="#ImmersedLayers.AreaForcingModel"><code>ImmersedLayers.AreaForcingModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">  AreaForcingModel(shape::Union{Body,BodyList},transform::MotionTransform,model_function!)</code></pre><p>Bundles a <code>shape</code> (i.e., a <code>Body</code>, <code>BodyList</code>,), a <code>transform</code> (to specify where to   place the shape), and a <code>model_function!</code> (a function   that returns the strength of the forcing) for area-type forcing.   <code>model_function!</code> must be in-place with a signature of the form</p><pre><code class="nohighlight hljs">  model_function!(str,state,t,fcache,phys_params)</code></pre><p>where <code>str</code> is the strength to be returned, <code>state</code> the state vector,   <code>t</code> is time, <code>fcache</code> is a corresponding <code>AreaRegionCache</code>   and <code>phys_params</code> are user-supplied physical parameters. Any of these can   be utilized to compute the strength.</p><p>There are a number of keyword arguments that can be passed in:   <code>ddftype =</code>,specifying the type of DDF; <code>spatialfield =</code> to provide   an <code>AbstractSpatialField</code> to help in evaluating the strength.   (The resulting field is available to <code>model_function!</code> in the <code>generated_field</code> field     of <code>fcache</code>.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/forcing.jl#L36-L56">source</a></section><section><div><pre><code class="language-julia hljs">AreaForcingModel(model_function!)</code></pre><p>Creates area-type forcing over the entire domain, using a <code>model_function!</code> (a function   that returns the strength of the forcing).</p><p><code>model_function!</code> must be in-place with a signature of the form</p><pre><code class="nohighlight hljs">  model_function!(str,state,t,fcache,phys_params)</code></pre><p>where <code>str</code> is the strength to be returned, <code>state</code> the state vector,   <code>t</code> is time, <code>fcache</code> is a corresponding <code>AreaRegionCache</code>   and <code>phys_params</code> are user-supplied physical parameters. Any of these can   be utilized to compute the strength.</p><p>The keyword <code>spatialfield =</code> can provide   an <code>AbstractSpatialField</code> to help in evaluating the strength.   (The resulting field is available to <code>model_function!</code> in the <code>generated_field</code> field     of <code>fcache</code>.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/forcing.jl#L58-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.LineForcingModel" href="#ImmersedLayers.LineForcingModel"><code>ImmersedLayers.LineForcingModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">  LineForcingModel(shape::Union{Body,BodyList},transform::MotionTransform,model_function!)</code></pre><p>Bundles a <code>shape</code> (i.e., a <code>Body</code>, <code>BodyList</code>,), a <code>transform</code> (to specify where to   place the shape), and a <code>model_function!</code> (a function   that returns the strength of the forcing) for line-type forcing.   <code>model_function!</code> must be in-place with a signature of the form</p><pre><code class="nohighlight hljs">  model_function!(str,state,t,fcache,phys_params)</code></pre><p>where <code>str</code> is the strength to be returned, <code>state</code> the state vector,   <code>t</code> is time, <code>fcache</code> is a corresponding <code>LineRegionCache</code>   and <code>phys_params</code> are user-supplied physical parameters. Any of these can   be utilized to compute the strength.</p><p>The keyword <code>ddftype =</code> can be used to specify the type of DDF.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/forcing.jl#L80-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.PointForcingModel" href="#ImmersedLayers.PointForcingModel"><code>ImmersedLayers.PointForcingModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">  PointForcingModel(pts::VectorData,transform::MotionTransform,model_function!)</code></pre><p>Bundles point coordinates <code>pts</code>, a <code>transform</code> (to specify where the origin of the points&#39;   coordinate system is relative to the inertial system&#39;s origin), and a <code>model_function!</code> (a function   that returns the strength of the forcing) for point-type forcing.   <code>model_function!</code> must be in-place with a signature of the form</p><pre><code class="nohighlight hljs">  model_function!(str,state,t,fcache,phys_params)</code></pre><p>where <code>str</code> is the strength to be returned, <code>state</code> the state vector,   <code>t</code> is time, <code>fcache</code> is a corresponding <code>PointRegionCache</code>   and <code>phys_params</code> are user-supplied physical parameters. Any of these can   be utilized to compute the strength.</p><p>The keyword <code>ddftype =</code> can be used to specify the type of DDF.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/forcing.jl#L98-L114">source</a></section><section><div><pre><code class="language-julia hljs">PointForcingModel(point_function::Function,transform::MotionTransform,model_function!::Function)</code></pre><p>Bundles a <code>point_function</code> (a function that returns the positions of forcing points), a <code>transform</code> (to specify where the origin of the points&#39; coordinate system is relative to the inertial system&#39;s origin), and a <code>model_function</code> (a function that returns the strength of the forcing) for point-type forcing.</p><p><code>point_function</code> must have an out-of-place signature of the form</p><pre><code class="nohighlight hljs">  point_function(state,t,fcache,phys_params)</code></pre><p>where <code>state</code> the state vector, <code>t</code> is time, <code>fcache</code> is a corresponding <code>PointRegionCache</code>   and <code>phys_params</code> are user-supplied physical parameters. Any of these can   be utilized to compute the positions. It must return either a vector for   each coordinate or <code>VectorData</code>.</p><p><code>model_function!</code> must have an in-place signature of the form</p><pre><code class="nohighlight hljs">  model_function!(str,state,t,fcache,phys_params)</code></pre><p>where <code>str</code> is the strength to be returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/forcing.jl#L116-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.AreaRegionCache" href="#ImmersedLayers.AreaRegionCache"><code>ImmersedLayers.AreaRegionCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AreaRegionCache(shape::Body/BodyList,cache::BasicILMCache)</code></pre><p>Create an area region (basically, a mask) of the shape(s) <code>shape</code>, using the data in <code>cache</code> to provide the details of the grid and regularization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/forcing.jl#L144-L149">source</a></section><section><div><pre><code class="language-julia hljs">AreaRegionCache(cache::BasicILMCache)</code></pre><p>Create an area region that spans the entire domain, using the data in <code>cache</code> to provide the grid details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/forcing.jl#L151-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.LineRegionCache" href="#ImmersedLayers.LineRegionCache"><code>ImmersedLayers.LineRegionCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LineRegionCache(shape::Body/BodyList,cache::BasicILMCache)</code></pre><p>Create a line region of the shape(s) <code>shape</code>, using the data in <code>cache</code> to provide the details of the regularization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/forcing.jl#L159-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.PointRegionCache" href="#ImmersedLayers.PointRegionCache"><code>ImmersedLayers.PointRegionCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PointRegionCache(pts::VectorData,cache::BasicILMCache[,kwargs])</code></pre><p>Create a regularized point collection based on points <code>pts</code>, using the data in <code>cache</code> to provide the details of the regularization. The <code>kwargs</code> can be used to override the regularization choices, such as ddf.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/forcing.jl#L166-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.ForcingModelAndRegion" href="#ImmersedLayers.ForcingModelAndRegion"><code>ImmersedLayers.ForcingModelAndRegion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ForcingModelAndRegion</code></pre><p>A type that holds the forcing model function, region, and cache</p><p><strong>Constructors</strong></p><p><code>ForcingModelAndRegion(model::AbstractForcingModel,cache::BasicILMCache)</code></p><p><code>ForcingModelAndRegion(modellist::Vector{AbstractForcingModel},cache::BasicILMCache)</code></p><p>These forms generally get called when building the extra cache. They also gracefully generate an empty list of models if one passes along <code>nothing</code> in the first argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/forcing.jl#L326-L339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.arcs-Tuple{LineRegionCache}" href="#ImmersedLayers.arcs-Tuple{LineRegionCache}"><code>ImmersedLayers.arcs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">arcs(lr::LineRegionCache)</code></pre><p>Return the vector of arc length coordinates for the given line region <code>lr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/forcing.jl#L308-L312">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.mask-Tuple{AreaRegionCache}" href="#ImmersedLayers.mask-Tuple{AreaRegionCache}"><code>ImmersedLayers.mask</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mask(ar::AreaRegionCache)</code></pre><p>Return the mask for the given area region <code>ar</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/forcing.jl#L301-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.points-Tuple{PointRegionCache}" href="#ImmersedLayers.points-Tuple{PointRegionCache}"><code>ImmersedLayers.points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">points(pr::PointRegionCache)</code></pre><p>Return the vector of coordinates of points associated with <code>pr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/forcing.jl#L315-L319">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.apply_forcing!" href="#ImmersedLayers.apply_forcing!"><code>ImmersedLayers.apply_forcing!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply_forcing!(out,y,x,t,fv::Vector{ForcingModelAndRegion},sys::ILMSystem)</code></pre><p>Return the total contribution of forcing in the vector <code>fv</code> to <code>out</code>, based on the current state <code>y</code>, auxiliary state <code>x</code>, time <code>t</code>, and ILM system <code>sys</code>. Note that <code>out</code> is zeroed before the contributions are added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/forcing.jl#L396-L402">source</a></section><section><div><pre><code class="language-julia hljs">apply_forcing!(dy,y,x,t,f::ForcingModelAndRegion,sys::ILMSystem)</code></pre><p>Return the contribution of forcing in <code>f</code> to the right-hand side <code>dy</code> based on the current state <code>y</code>, auxiliary state <code>x</code>, time <code>t</code>, and ILM system <code>sys</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/forcing.jl#L439-L444">source</a></section></article><h2 id="Output-functions-and-macros"><a class="docs-heading-anchor" href="#Output-functions-and-macros">Output functions and macros</a><a id="Output-functions-and-macros-1"></a><a class="docs-heading-anchor-permalink" href="#Output-functions-and-macros" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.@snapshotoutput" href="#ImmersedLayers.@snapshotoutput"><code>ImmersedLayers.@snapshotoutput</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@snapshotoutput(name)</code></pre><p>A function that returns some instantaneous output about a time-varying solution should have the signature <code>name(state,constraint,aux_state,sys::ILMSystem,t[,kwargs...])</code>, where <code>state</code> is a solution vector (of the same type as returned by <code>state(zeros_sol(sys))</code>), <code>constraint</code> is of the same type as returned by <code>constraint(zeros_sol(sys))</code>), <code>sys</code> is the system struct, <code>t</code> is time, and <code>kwargs</code> are any additional keyword arguments. This macro extends that function so that it will also operate on the integrator e.g, <code>name(integrator)</code>, and the solution history array <code>sol</code>, e.g., <code>name(sol::ODESolution,sys,t)</code>, using interpolation for values of <code>t</code> that are not explicitly in the solution array. It can also take a range of values of <code>t</code>, e.g, <code>name(sol::ODESolution,sys,0.1:0.01:0.2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/output.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.@scalarsurfacemetric" href="#ImmersedLayers.@scalarsurfacemetric"><code>ImmersedLayers.@scalarsurfacemetric</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@scalarsurfacemetric(name)</code></pre><p>A function that returns a time-varying scalar surface metric should have the signature <code>name(state,constraint,sys::ILMSystem,t,bodyid,[,kwargs...])</code>, where <code>state</code> is a solution vector (of the same type as returned by <code>state(zeros_sol(sys))</code>), <code>constraint</code> is of the same type as returned by <code>constraint(zeros_sol(sys))</code>), <code>sys</code> is the system struct, <code>t</code> is time, <code>bodyid</code> is the body ID, and <code>kwargs</code> are any additional keyword arguments. This macro extends that function so that it will also operate on the integrator e.g, <code>name(integrator,bodyid)</code>, and the solution history array <code>sol</code>, e.g., <code>name(sol::ODESolution,sys,t,bodyid)</code>, using interpolation for values of <code>t</code> that are not explicitly in the solution array. It can also take a range of values of <code>t</code>, e.g, <code>name(sol::ODESolution,sys,0.1:0.01:0.2,bodyid)</code>. And finally, it can simply take <code>name(sol::ODESolution,sys,bodyid)</code> to return the entire history.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/output.jl#L37-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.@vectorsurfacemetric" href="#ImmersedLayers.@vectorsurfacemetric"><code>ImmersedLayers.@vectorsurfacemetric</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@vectorsurfacemetric(name)</code></pre><p>A function that returns a time-varying scalar surface metric should have the signature <code>name(state,constraint,sys::ILMSystem,t,bodyid,[,kwargs...])</code>, where <code>state</code> is a solution vector (of the same type as returned by <code>state(zeros_sol(sys))</code>), <code>constraint</code> is of the same type as returned by <code>constraint(zeros_sol(sys))</code>), <code>sys</code> is the system struct, <code>t</code> is time, <code>bodyid</code> is the body ID, and <code>kwargs</code> are any additional keyword arguments. This macro extends that function so that it will also operate on the integrator e.g, <code>name(integrator,bodyid)</code>, and the solution history array <code>sol</code>, e.g., <code>name(sol::ODESolution,sys,t,bodyid)</code>, using interpolation for values of <code>t</code> that are not explicitly in the solution array. It can also take a range of values of <code>t</code>, e.g, <code>name(sol::ODESolution,sys,0.1:0.01:0.2,bodyid)</code>. And finally, it can simply take <code>name(sol::ODESolution,sys,bodyid)</code> to return the entire history.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/output.jl#L65-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImmersedLayers.surfaces" href="#ImmersedLayers.surfaces"><code>ImmersedLayers.surfaces</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">surfaces(u::ConstrainedSystems.ArrayPartition,sys::ILMSystem,t) -&gt; BodyList</code></pre><p>Return the list of surfaces (as a <code>BodyList</code>) in the solution vector <code>u</code>. If the surfaces are stationary, then this simply returns them from <code>sys</code> and ignores the time argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/system.jl#L147-L153">source</a></section><section><div><pre><code class="language-julia hljs">surfaces(sys::ILMSystem) -&gt; BodyList</code></pre><p>Return the list of surfaces (as a <code>BodyList</code>) in the system <code>sys</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/system.jl#L171-L175">source</a></section><section><div><pre><code class="language-julia hljs">surfaces(sol::ODESolution,sys::ILMSystem,t) -&gt; BodyList</code></pre><p>Return the list of surfaces (as a <code>BodyList</code>) at the time <code>t</code>, using the ODE solution array <code>sol</code>. If the surfaces are stationary, then this simply returns them and ignores the time argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/output.jl#L97-L103">source</a></section><section><div><pre><code class="language-julia hljs">surfaces(int::ConstrainedSystems.OrdinaryDiffEq.ODEIntegrator) -&gt; BodyList</code></pre><p>Return the list of surfaces (as a <code>BodyList</code>) in the integrator <code>int</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/e1ee88d0632e81fd2c1e973614d9fabc0f026579/src/output.jl#L107-L111">source</a></section></article><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../utilities/">« Utilities</a><a class="docs-footer-nextpage" href="../neumann/">Poisson with Neumann conditions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Wednesday 8 November 2023 05:06">Wednesday 8 November 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
