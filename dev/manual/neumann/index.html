<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Poisson with Neumann conditions · ImmersedLayers.jl</title><meta name="title" content="Poisson with Neumann conditions · ImmersedLayers.jl"/><meta property="og:title" content="Poisson with Neumann conditions · ImmersedLayers.jl"/><meta property="twitter:title" content="Poisson with Neumann conditions · ImmersedLayers.jl"/><meta name="description" content="Documentation for ImmersedLayers.jl."/><meta property="og:description" content="Documentation for ImmersedLayers.jl."/><meta property="twitter:description" content="Documentation for ImmersedLayers.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ImmersedLayers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../caches/">Immersed layer caches</a></li><li><a class="tocitem" href="../surfaceops/">Surface-grid operations</a></li><li><a class="tocitem" href="../multbodies/">Multiple bodies</a></li><li><a class="tocitem" href="../gridops/">Grid operations</a></li><li><a class="tocitem" href="../helmholtz/">Helmholtz decomposition</a></li><li><a class="tocitem" href="../matrices/">Matrix operators</a></li><li><a class="tocitem" href="../dirichlet/">A Dirichlet Poisson problem</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li></ul></li><li><span class="tocitem">Setting up PDEs</span><ul><li><a class="tocitem" href="../problems/">Problems and the system</a></li><li class="is-active"><a class="tocitem" href>Poisson with Neumann conditions</a><ul class="internal"><li><a class="tocitem" href="#Set-up-the-extra-cache-and-solve-function"><span>Set up the extra cache and solve function</span></a></li><li><a class="tocitem" href="#Solve-the-problem"><span>Solve the problem</span></a></li><li><a class="tocitem" href="#Multiple-bodies"><span>Multiple bodies</span></a></li></ul></li><li><a class="tocitem" href="../stokes/">Stokes flow</a></li><li><a class="tocitem" href="../heatconduction/">Setting up a time-varying PDE</a></li><li><a class="tocitem" href="../heatconduction-unbounded/">A time-varying PDE with forcing</a></li><li><a class="tocitem" href="../heatconduction-neumann/">A time-varying PDE with Neumann conditions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Setting up PDEs</a></li><li class="is-active"><a href>Poisson with Neumann conditions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Poisson with Neumann conditions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaIBPM/ImmersedLayers.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/main/test/literate/neumann.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Poisson-with-Neumann-conditions"><a class="docs-heading-anchor" href="#Poisson-with-Neumann-conditions">Poisson with Neumann conditions</a><a id="Poisson-with-Neumann-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Poisson-with-Neumann-conditions" title="Permalink"></a></h1><p>Here, we&#39;ll demonstrate a solution of Laplace&#39;s equation, with Neumann boundary conditions on a surface. Similar to the Dirichlet problem in <a href="../dirichlet/#A-Dirichlet-Poisson-problem">A Dirichlet Poisson problem</a>, we will solve the problem with one Neumann condition external to the surface, and another Neumann value internal to the surface.</p><p>Our underlying problem is still</p><p class="math-container">\[\nabla^2\varphi^+ = 0,\qquad \nabla^2\varphi^- = 0\]</p><p>where <span>$+$</span> denotes the exterior and <span>$-$</span> the interior of the surface. (We will consider a circle of radius 1.) The boundary conditions on this surface are</p><p class="math-container">\[\mathbf{n}\cdot\nabla\varphi^+ = v^+_n, \qquad \mathbf{n}\cdot\nabla\varphi^- = v^-_n\]</p><p>In other words, we seek to set the value on the exterior normal derivative to <span>$v_n$</span> of the local normal vector on the surface, while the interior should have zero normal derivative.</p><p>Discretizing this problem by the usual techniques, we seek to solve</p><p class="math-container">\[\begin{bmatrix} L &amp; D_s \\ G_s &amp; R_n^T R_n \end{bmatrix} \begin{pmatrix} f \\ -[\phi] \end{pmatrix} = \begin{pmatrix} R [v_n] \\ \overline{v}_n \end{pmatrix}\]</p><p>where <span>$\overline{v}_n = (v^+_n + v^-_n)/2$</span> and <span>$[v_n] = v^+_n - v^-_n$</span>. The resulting <span>$[\phi]$</span> is <span>$f^+-f^-$</span>.</p><p>As with the Dirichlet problem, this saddle-point problem can be solved by block-LU decomposition. First solve</p><p class="math-container">\[L f^{*} = R [v_n]\]</p><p>for <span>$f^*$</span>. Then solve</p><p class="math-container">\[-S [\phi] = \overline{v}_n - G_s f^{*}\]</p><p>for <span>$[\phi]$</span>, where <span>$S = R_n^T R_n - G_s L^{-1} D_s = -C_s L^{-1}C_s^T$</span>, and finally, compute</p><p class="math-container">\[f = f^{*} + L^{-1}D_s [\phi]\]</p><p>It should be remembered that, for any scalar potential field, there is a corresponding streamfunction <span>$\psi$</span> that generates the same flow. We can get that field, as well, with only a little bit more effort:</p><p class="math-container">\[S [\psi] = C_s f^{*}\]</p><p>and then solve</p><p class="math-container">\[L s = C_s^T [\phi] - \hat{C}_s^T [\psi]\]</p><p>.</p><p>for the streamfunction <span>$s$</span>.</p><pre><code class="language-julia hljs">using ImmersedLayers
using Plots
using LinearAlgebra
using UnPack</code></pre><h2 id="Set-up-the-extra-cache-and-solve-function"><a class="docs-heading-anchor" href="#Set-up-the-extra-cache-and-solve-function">Set up the extra cache and solve function</a><a id="Set-up-the-extra-cache-and-solve-function-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-the-extra-cache-and-solve-function" title="Permalink"></a></h2><p>The problem type takes the usual basic form</p><pre><code class="language-julia hljs">@ilmproblem NeumannPoisson scalar</code></pre><p>The extra cache holds additional intermediate data, as well as the Schur complement. We don&#39;t bother creating a filtering matrix here.</p><pre><code class="language-julia hljs">struct NeumannPoissonCache{SMT,DVT,VNT,FT,ST} &lt;: AbstractExtraILMCache
   S :: SMT
   dvn :: DVT
   vn :: VNT
   fstar :: FT
   sstar :: ST
end</code></pre><p>The function <code>prob_cache</code>, as before, constructs the operators and extra cache data structures</p><pre><code class="language-julia hljs">function ImmersedLayers.prob_cache(prob::NeumannPoissonProblem,base_cache::BasicILMCache)
    S = create_CLinvCT(base_cache)
    dvn = zeros_surface(base_cache)
    vn = zeros_surface(base_cache)
    fstar = zeros_grid(base_cache)
    sstar = zeros_gridcurl(base_cache)
    NeumannPoissonCache(S,dvn,vn,fstar,sstar)
end</code></pre><p>And finally, here&#39;s the steps we outlined above, used to extend the <code>solve</code> function</p><pre><code class="language-julia hljs">function ImmersedLayers.solve(prob::NeumannPoissonProblem,sys::ILMSystem)
    @unpack extra_cache, base_cache, bc, phys_params = sys
    @unpack S, dvn, vn, fstar, sstar = extra_cache

    fill!(fstar,0.0)
    fill!(sstar,0.0)

    f = zeros_grid(base_cache)
    s = zeros_gridcurl(base_cache)
    df = zeros_surface(base_cache)
    ds = zeros_surface(base_cache)

    # Get the precribed jump and average of the surface normal derivatives
    prescribed_surface_jump!(dvn,sys)
    prescribed_surface_average!(vn,sys)

    # Find the potential
    regularize!(fstar,dvn,base_cache)
    inverse_laplacian!(fstar,base_cache)

    surface_grad!(df,fstar,base_cache)
    df .= vn - df
    df .= -(S\df);

    surface_divergence!(f,df,base_cache)
    inverse_laplacian!(f,base_cache)
    f .+= fstar

    # Find the streamfunction
    surface_curl!(sstar,df,base_cache)

    surface_grad_cross!(ds,fstar,base_cache)
    ds .= S\ds

    surface_curl_cross!(s,ds,base_cache)
    s .-= sstar
    s .*= -1.0

    inverse_laplacian!(s,base_cache)

    return f, df, s, ds
end</code></pre><h2 id="Solve-the-problem"><a class="docs-heading-anchor" href="#Solve-the-problem">Solve the problem</a><a id="Solve-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-the-problem" title="Permalink"></a></h2><p>Here, we will demonstrate the solution on a circular shape of radius 1, with <span>$v_n^+ = n_x$</span> and <span>$v_n^- = 0$</span>. This is actually the set of conditions used to compute the unit scalar potential field (and, as we will see, the added mass) in potential flow.</p><p>Set up the grid</p><pre><code class="language-julia hljs">Δx = 0.01
Lx = 4.0
xlim = (-Lx/2,Lx/2)
ylim = (-Lx/2,Lx/2)
g = PhysicalGrid(xlim,ylim,Δx)
Δs = 1.4*cellsize(g)
body = Circle(1.0,Δs);</code></pre><p>Set the boundary condition functions</p><pre><code class="language-julia hljs">function get_vnplus(base_cache,phys_params)
    nrm = normals(base_cache)
    vnplus = zeros_surface(base_cache)
    vnplus .= nrm.u
    return vnplus
end
get_vnminus(base_cache,phys_params) = zeros_surface(base_cache)

bcdict = Dict(&quot;exterior&quot;=&gt;get_vnplus,&quot;interior&quot;=&gt;get_vnminus)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Function} with 2 entries:
  &quot;interior&quot; =&gt; get_vnminus
  &quot;exterior&quot; =&gt; get_vnplus</code></pre><p>Create the system</p><pre><code class="language-julia hljs">prob = NeumannPoissonProblem(g,body,scaling=GridScaling,bc=bcdict)
sys = construct_system(prob)</code></pre><p>Solve it</p><pre><code class="language-julia hljs">@time f, df, s, ds = solve(prob,sys);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">  0.054371 seconds (3.06 k allocations: 15.957 MiB, 27.11% compilation time)</code></pre><p>and plot the field</p><pre><code class="language-julia hljs">plot(plot(f,sys,layers=true,levels=30,title=&quot;ϕ&quot;),
plot(s,sys,layers=true,levels=30,title=&quot;ψ&quot;))</code></pre><img src="4180cb41.svg" alt="Example block output"/><p>and the Lagrange multiplier field, <span>$[\phi]$</span>, on the surface</p><pre><code class="language-julia hljs">plot(df,sys)</code></pre><img src="8e25e82d.svg" alt="Example block output"/><p>If, instead, we set the inner boundary condition to <span>$n_x$</span> and the outer to zero, then we get the flow <em>inside</em> of a translating circle. All we need to do is re-define the boundary functions</p><pre><code class="language-julia hljs">function get_vnplus(base_cache,phys_params)
    vnplus = zeros_surface(base_cache)
    return vnplus
end
function get_vnminus(base_cache,phys_params)
    nrm = normals(base_cache)
    vnminus = zeros_surface(base_cache)
    vnminus .= nrm.u
    return vnminus
end

f, df, s, ds = solve(prob,sys);
plot(plot(f,sys,layers=true,levels=30,title=&quot;ϕ&quot;),
plot(s,sys,layers=true,levels=30,title=&quot;ψ&quot;))</code></pre><img src="bac1119a.svg" alt="Example block output"/><h2 id="Multiple-bodies"><a class="docs-heading-anchor" href="#Multiple-bodies">Multiple bodies</a><a id="Multiple-bodies-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-bodies" title="Permalink"></a></h2><p>The cache and solve function we created above can be applied for any body or set of bodies. Let&#39;s apply it here to a circle of radius 0.25 inside of a square of half-side length 2, where our goal is to find the effect of the enclosing square on the motion of the circle. As such, we will set the Neumann conditions both internal to and external to the square to be 0, but for the exterior of the circle, we set it to <span>$n_x$</span>.</p><pre><code class="language-julia hljs">bl = BodyList();
push!(bl,Square(1.0,Δs))
push!(bl,Circle(0.25,Δs))</code></pre><p>We don&#39;t actually have to transform these shapes, but it is illustrative to show how we would move them.</p><pre><code class="language-julia hljs">t1 = MotionTransform([0.0,0.0],0.0)
t2 = MotionTransform([0.0,0.0],0.0)
tl = MotionTransformList([t1,t2])
update_body!(bl,tl)</code></pre><p>Set the boundary conditions. We set only the exterior Neumann value of body 2 (the circle). This gives us an opportunity to demonstrate the  <a href="../caches/#Base.copyto!-Tuple{PointData, PointData, BasicILMCache, Int64}"><code>copyto!</code></a> function, which is useful for setting only the part of  the overall surface data associated with a certain body.</p><pre><code class="language-julia hljs">function get_vnplus(base_cache,phys_params)
    nrm = normals(base_cache)
    vnplus = zeros_surface(base_cache)
    copyto!(vnplus,nrm.u,base_cache,2)
    return vnplus
end
function get_vnminus(base_cache,phys_params)
    vnminus = zeros_surface(base_cache)
    return vnminus
end
bcdict = Dict(&quot;exterior&quot;=&gt;get_vnplus,&quot;interior&quot;=&gt;get_vnminus)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Function} with 2 entries:
  &quot;interior&quot; =&gt; get_vnminus
  &quot;exterior&quot; =&gt; get_vnplus</code></pre><p>Create the problem and system</p><pre><code class="language-julia hljs">prob = NeumannPoissonProblem(g,bl,scaling=GridScaling,bc=bcdict)
sys = construct_system(prob)</code></pre><p>Solve it and plot</p><pre><code class="language-julia hljs">f, df, s, ds  = solve(prob,sys)
plot(plot(f,sys,layers=true,levels=30,title=&quot;ϕ&quot;),
plot(s,sys,layers=true,levels=30,title=&quot;ψ&quot;))</code></pre><img src="963b56e5.svg" alt="Example block output"/><p>Now, let&#39;s compute the added mass components of the circle associated with this motion. We are approximating</p><p class="math-container">\[M = -\int_{C_2} f^+ \mathbf{n}\mathrm{d}s\]</p><p>where <span>$C_2$</span> is shape 2 (the circle), and <span>$f^+$</span> is simply <span>$[\phi]$</span> on body 2.</p><pre><code class="language-julia hljs">nrm = normals(sys)
M = -integrate(df∘nrm,sys,2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
  0.2264927752791399
 -4.407177743679259e-10</code></pre><p>As one would expect, the circle has added mass in the <span>$x$</span> direction associated with moving in that direction.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../problems/">« Problems and the system</a><a class="docs-footer-nextpage" href="../stokes/">Stokes flow »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Wednesday 8 November 2023 05:06">Wednesday 8 November 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
