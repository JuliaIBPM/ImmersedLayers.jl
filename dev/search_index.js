var documenterSearchIndex = {"docs":
[{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"EditURL = \"<unknown>/literate/heatconduction.jl\"","category":"page"},{"location":"manual/heatconduction/#Setting-up-a-time-varying-PDE","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"","category":"section"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"In this example we will demonstrate the use of the package on a time-dependent PDE, a problem of unsteady heat conduction. We will use the package to solve for the interior diffusion of temperature from a circle held at constant temperature.","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"We seek to solve the heat conduction equation with Dirichlet boundary conditions","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"dfracpartial Tpartial t = kappa nabla^2 T + q + delta(chi) sigma  - kappa nablacdot left( delta(chi) mathbfn T right)","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"subject to T = T_b on the immersed surface. We might be solving this external to a surface, or it might be internal. The quantity sigma is the Lagrange multiplier. In this context, it is the heat flux through the surface.","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"In the spatially discrete formulation, the problem takes the form","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"beginbmatrix\nmathcalL_C^kappa  R_C  R_C^T  0\nendbmatrixbeginpmatrix\nT  -sigma\nendpmatrix =\nbeginpmatrix\nq - kappa D_s T  (T^+_b + T^-_b)2\nendpmatrix","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"where mathcalL_C^kappa = mathrmdmathrmdt - kappa L_C, where T = T_b^+ - T_b^- is the jump in temperature across the surface. As in the time-independent problems, we can specify whether we are solving it external or internal to a surface by setting the boundary value to zero in the other region. However, in contrast to the time-independent problems, we have to advance this problem in time. The system above has the form of a constrained ODE system, which the ConstrainedSystems.jl package treats. We will make use of this package in the example below.","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"To support this, there are a few additional steps in our setup of the problem:","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"we (as the implementers of the PDE) need to specify the functions that calculate the  various parts of this constrained ODE system.\nwe (as the users of this implementation) need to specify the time step size,  the initial conditions, the time integration range, and create the integrator  to advance the solution.","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"The latter of these is very easy, as we'll find. Most of our attention will be on the first part: how to set up the constrained ODE system. For this, we will make use of the ODEFunctionList, which assembles the various functions and operators into a ConstrainedODEFunction, to be used by the ConstrainedSystems.jl package.","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"using ImmersedLayers\nusing Plots\nusing UnPack","category":"page"},{"location":"manual/heatconduction/#Set-up-the-constrained-ODE-system-operators","page":"Setting up a time-varying PDE","title":"Set up the constrained ODE system operators","text":"","category":"section"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"The problem type is generated with the usual macro call. In this example, we will make use of more of the capabilities of the resulting problem constructor for \"packing\" it with information about the problem.","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"@ilmproblem DirichletHeatConduction scalar","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"The constrained ODE system requires us to provide functions that calculate the RHS of the ODE, the RHS of the constraint equation, the Lagrange multiplier force term in the ODE, and the action of the boundary operator on the state vector. (You can see the generic form of the system by typing ?ConstrainedODEFunction) As you will see, in this example these are in-place operators: their first argument holds the result, which is changed (i.e., mutated) by the function. Below, we construct the function that calculates the RHS of the heat conduction ODE. We have omitted the volumetric heat flux here, supplying only the double-layer term. Note how this makes use of the physical parameters in phys_params and the boundary data via functions in bc. The functions for the boundary data supply the boundary values. Also, note that the function returns dT in the first argument. This represents this function's contribution to dTdt.","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"function heatconduction_ode_rhs!(dT,T,sys::ILMSystem,t)\n    @unpack bc, forcing, phys_params, extra_cache, base_cache = sys\n    @unpack dTb = extra_cache\n\n    κ = phys_params[\"diffusivity\"]\n\n    # Calculate the double-layer term\n    prescribed_surface_jump!(dTb,t,sys)\n    surface_divergence!(dT,-κ*dTb,sys)\n\n    return dT\nend","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Now, we create the function that calculates the RHS of the boundary condition. For this Dirichlet condition, we simply take the average of the interior and exterior prescribed values. The first argument dTb holds the result.","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"function heatconduction_bc_rhs!(dTb,sys::ILMSystem,t)\n    prescribed_surface_average!(dTb,t,sys)\n    return dTb\nend","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"This function calculates the contribution to dTdt from the Lagrange multiplier (the input σ). Here, we simply regularize the negative of this to the grid.","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"function heatconduction_constraint_force!(dT,σ,sys::ILMSystem)\n    regularize!(dT,-σ,sys)\n    return dT\nend","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Now, we provide the transpose term of the previous function: a function that interpolates the temperature (state vector) onto the boundary. The first argument dTb holds the result.","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"function heatconduction_bc_op!(dTb,T,sys::ILMSystem)\n    interpolate!(dTb,T,sys)\n    return dTb\nend","category":"page"},{"location":"manual/heatconduction/#Set-up-the-extra-cache-and-extend-prob_cache","page":"Setting up a time-varying PDE","title":"Set up the extra cache and extend prob_cache","text":"","category":"section"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Here, we construct an extra cache that holds a few extra intermediate variables, used in the routines above. But this cache also, crucially, holds the functions and operators of the constrained ODE function. We call the function ODEFunctionList to assemble these together.","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"The prob_cache function creates this ODE function, supplying the functions that we just defined. We also create a Laplacian operator with the heat diffusivity built into it. (This operator is singled out from the other terms in the heat conduction equation, because we account for it separately in the time marching using a matrix exponential.) We also create prototypes of the state and constraint force vectors. Here, the state is the grid temperature data and the constraint is the Lagrange multipliers on the boundary.","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"struct DirichletHeatConductionCache{DTT,FT} <: AbstractExtraILMCache\n   dTb :: DTT\n   f :: FT\nend\n\nfunction ImmersedLayers.prob_cache(prob::DirichletHeatConductionProblem,\n                                   base_cache::BasicILMCache{N,scaling}) where {N,scaling}\n    @unpack phys_params = prob\n    @unpack gdata_cache, g = base_cache\n\n    dTb = zeros_surface(base_cache)\n\n    # Construct a Lapacian outfitted with the diffusivity\n    κ = phys_params[\"diffusivity\"]\n    heat_L = Laplacian(base_cache,gdata_cache,κ)\n\n    # State (grid temperature data) and constraint (surface Lagrange multipliers)\n    f = ODEFunctionList(state = zeros_grid(base_cache),\n                        constraint = zeros_surface(base_cache),\n                        ode_rhs=heatconduction_ode_rhs!,\n                        lin_op=heat_L,\n                        bc_rhs=heatconduction_bc_rhs!,\n                        constraint_force = heatconduction_constraint_force!,\n                        bc_op = heatconduction_bc_op!)\n\n    DirichletHeatConductionCache(dTb,f)\nend","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Before we move on to solving the problem, we need to set up a function that will calculate the time step size. The time marching algorithm will call this function. Of course, this could just be used to specify a time step directly, e.g., by supplying it in phys_params. But it is better to use a stability condition (a Fourier condition) to determine it based on the other data.","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"function timestep_fourier(sys)\n    @unpack phys_params = sys\n    g = get_grid(sys)\n    κ = phys_params[\"diffusivity\"]\n    Fo = phys_params[\"Fourier\"]\n    Δt = Fo*cellsize(g)^2/κ\n    return Δt\nend","category":"page"},{"location":"manual/heatconduction/#Solve-the-problem","page":"Setting up a time-varying PDE","title":"Solve the problem","text":"","category":"section"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"We will solve heat conduction inside a circular region with uniform temperature, with thermal diffusivity equal to 1.","category":"page"},{"location":"manual/heatconduction/#Set-up-the-grid","page":"Setting up a time-varying PDE","title":"Set up the grid","text":"","category":"section"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Δx = 0.01\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx);\nnothing #hide","category":"page"},{"location":"manual/heatconduction/#Set-up-the-body-shape.","page":"Setting up a time-varying PDE","title":"Set up the body shape.","text":"","category":"section"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Here, we will demonstrate the solution on a circular shape of radius 1.","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Δs = 1.4*cellsize(g)\nbody = Circle(1.0,Δs);\nnothing #hide","category":"page"},{"location":"manual/heatconduction/#Specify-the-physical-parameters,-data,-etc.","page":"Setting up a time-varying PDE","title":"Specify the physical parameters, data, etc.","text":"","category":"section"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"These can be changed later without having to regenerate the system.","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Here, we create a dict with physical parameters to be passed in.","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"phys_params = Dict(\"diffusivity\" => 1.0, \"Fourier\" => 1.0)","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"The temperature boundary functions on the exterior and interior are defined here and assembled into a dict. Note that these functions must have a slightly more complex signature than in time-invariant problems: for generality, they must accept the time argument and another argument accepting possible motions of the surfaces.","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"get_Tbplus(t,base_cache,phys_params,motions) = zeros_surface(base_cache)\nget_Tbminus(t,base_cache,phys_params,motions) = ones_surface(base_cache)\nbcdict = Dict(\"exterior\" => get_Tbplus,\"interior\" => get_Tbminus)","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Construct the problem, passing in the data and functions we've just created.","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"prob = DirichletHeatConductionProblem(g,body,scaling=GridScaling,\n                                             phys_params=phys_params,\n                                             bc=bcdict,\n                                             timestep_func=timestep_fourier);\nnothing #hide","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Construct the system","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"sys = construct_system(prob);\nnothing #hide","category":"page"},{"location":"manual/heatconduction/#Solving-the-problem","page":"Setting up a time-varying PDE","title":"Solving the problem","text":"","category":"section"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"In contrast to the previous (time-independent) example, we have not extended the solve function here to serve us in solving this problem. Instead, we rely on the tools in ConstrainedSystems.jl to advance the solution forward in time. This package builds from the OrdinaryDiffEq.jl package, and leverages most of the tools of that package.","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Set an initial condition. Here, we just get an initial (zeroed) copy of the solution prototype that we have stored in the extra cache. We also get the time step size for our own inspection.","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"u0 = init_sol(sys)\nΔt = timestep_fourier(sys)","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"It is instructive to note that u0 has two parts: a state and a constraint, each obtained respectively with a convenience function. The state in this case is the temperature; the constraint is the Lagrange multiplier.","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"state(u0)","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"constraint(u0)","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Now, create the integrator, with a time interval of 0 to 1. We have not specified the algorithm here explicitly; it defaults to the LiskaIFHERK time-marching algorithm, which is a second-order algorithm for constrained ODE systems that utilizes the matrix exponential (i.e., integrating factor) for the linear part of the problem. Another choice is the first-order Euler method, IFHEEuler, which one can specify by adding alg=ConstrainedSystems.IFHEEuler()","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"tspan = (0.0,1.0)\nintegrator = init(u0,tspan,sys)","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Now advance the solution by 0.01 convective time units, by using the step! function, which steps through the solution.","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"step!(integrator,0.01)","category":"page"},{"location":"manual/heatconduction/#Plot-the-solution","page":"Setting up a time-varying PDE","title":"Plot the solution","text":"","category":"section"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"The integrator holds the most recent solution in the field u, which has the same type as our initial condition u0. Here, we plot the state of the system at the end of the interval.","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"plot(state(integrator.u),sys)","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"It would be nice to just define a function called temperature to get this more explicitly. We will do that here, and also apply a macro @snapshotoutput that automatically extends this function with some convenient interfaces. For example, if we simply pass in the integrator to temperature, it will pick off the u field for us.","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"temperature(T,σ,sys::ILMSystem,t) = T\n@snapshotoutput temperature","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Now we can write","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"plot(temperature(integrator),sys)","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"The solution history is in the field integrator.sol. The macro we called earlier enables temperature to work for this, as well, and we can obtain the temperature at any time in the interval of our solution. For example, to get the solution at time 0.51:","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"sol = integrator.sol\nplot(temperature(sol,sys,0.0051),sys)","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"We can also get it for an array of times, e.g.,","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"temperature(sol,sys,0.0051:0.0001:0.0061);\nnothing #hide","category":"page"},{"location":"manual/heatconduction/#Motions","page":"Setting up a time-varying PDE","title":"Motions","text":"","category":"section"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"It is straightforward to make bodies move in time-varying problems. For each body that we create, we can provide a corresponding motion, via the motions = keyword. (If a BodyList is provided, then a corresponding MotionList must be provided.) The only caveat is that the time-stepping becomes considerably slower in such problems, since the system operators must be regenerated at every time step.","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"The RigidBodyTools.jl package provides a versatile set of motions, both rigid-body and deforming, and associated tools. For example, to simply make the body move at constant velocity 1 in the x direction.","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"m = RigidBodyMotion((1.0,0.0),0.0)","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Here's an example of a deforming motion","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"ufcn(x,y,t) = 0.25*x*y*cos(t)\nvfcn(x,y,t) = 0.25*(x^2-y^2)*cos(t)\nm = DeformationMotion(ufcn,vfcn)","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Either of these would be provided in the motions = keyword of the problem construction. Consult the documentation of RigidBodyTools.jl to learn more about these. However, for time-marching purposes, it is helpful to know that the maximum surface velocity is provided by the maxvelocity function:","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"maxvelocity(body,m)","category":"page"},{"location":"manual/heatconduction/#Time-varying-PDE-functions","page":"Setting up a time-varying PDE","title":"Time-varying PDE functions","text":"","category":"section"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"ODEFunctionList\nzeros_sol\ninit_sol\ninit\nstate\nconstraint","category":"page"},{"location":"manual/heatconduction/#ImmersedLayers.ODEFunctionList","page":"Setting up a time-varying PDE","title":"ImmersedLayers.ODEFunctionList","text":"ODEFunctionList\n\nConstructor\n\nODEFunctionList(state=nothing,constraint=nothing,ode_rhs=nothing,bc_rhs=nothing,constraint_force=nothing,bc_op=nothing,lin_op=nothing)\n\nSupply functions and data types for a constrained ODE system. The specified functions must provide the various parts that comprise the constrained ODE system\n\ndfracdydt = Ly - B_1 z + r_1(yt)\n\nB_2 y = r_2(t)\n\nThe functions can be in in-place or out-of-place form, but they must all be consistently of the same form.\n\nstate = specifies a prototype of the state vector y.\nconstraint = specifies a prototype of the constraint force vector z. If there are no constraints, this can be omitted.\node_rhs = specifies the right-hand side of the ODEs, r_1. The in-place form of the function is r1(dy,y,sys::ILMSystem,t), the state vector y, IL system sys, time t, and returning dydt. The out-of-place form is r1(y,sys,t).\nbc_rhs = specifies the right-hand side of the boundary conditions, r_2. If there are no constraints, this can be omitted. The in-place form is r2(dz,sys,t), returning dz, the part of the boundary constraint not dependent on the state vector. The out-of-place form is r2(sys,t).\nconstraint_force = supplies the constraint force term in the ODEs, B_1 z. If there are no constraints, this can be omitted. The in-place form is B1(dy,z,sys), returning the contribution to dydt (with the sign convention shown in the equations above) and the out-of-place form is B1(z,sys).\nbc_op = supplies the left-hand side of the boundary constraint, B_2 y. If there are no constraints, this can be omitted. The in-place form is B2(dz,y,sys), the out-of-place form is B2(y,sys).\nlin_op = is optional and specifies a linear operator on the state vector L, to be treated with an exponential integral (i.e., integrating factor) in the time marching. (Alternatively, this part can simply be included in r_1). It should have an associated mul! operation that acts upon the state vector.\n\n\n\n\n\n","category":"type"},{"location":"manual/heatconduction/#ImmersedLayers.zeros_sol","page":"Setting up a time-varying PDE","title":"ImmersedLayers.zeros_sol","text":"zeros_sol(sys::ILMSystem)\n\nReturn a zeroed version of the solution vector.\n\n\n\n\n\n","category":"function"},{"location":"manual/heatconduction/#ImmersedLayers.init_sol","page":"Setting up a time-varying PDE","title":"ImmersedLayers.init_sol","text":"init_sol(sys::ILMSystem)\n\nReturn the initial solution vector, with the state component set to zero.\n\n\n\n\n\ninit_sol(s::AbstractSpatialField,sys::ILMSystem)\n\nReturn the initial solution vector, with the state component set to the field established by s.\n\n\n\n\n\n","category":"function"},{"location":"manual/heatconduction/#CommonSolve.init","page":"Setting up a time-varying PDE","title":"CommonSolve.init","text":"ConstrainedSystems.init(u0,tspan,sys::ILMSystem,[alg=ConstrainedSystems.LiskaIFHERK()])\n\nInitialize the integrator for a time-varying immersed-layer system of PDEs, described in sys.\n\n\n\n\n\n","category":"function"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"","category":"page"},{"location":"manual/heatconduction/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"EditURL = \"<unknown>/literate/multbodies.jl\"","category":"page"},{"location":"manual/multbodies/#Multiple-bodies","page":"Multiple bodies","title":"Multiple bodies","text":"","category":"section"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"Under the hood, the cache uses the concept of a Body (from the RigidBodyTools.jl package) to perform certain calculations, like normal vectors and surface panel areas, which may specialize depending on the type of body shape. Note that most immersed layer operations do not depend on whether there is one or more bodies; rather, they only depend on the discrete points, and their associated normals and areas. However, some post-processing operations, like surface integrals, do depend on distinguishing one body from another. For this reason, the cache stores points in a BodyList, and several operations can exploit this.","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"using ImmersedLayers\nusing Plots","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"For the demonstration, we use the same grid.","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"Δx = 0.01\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx)","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"We will create a 2 x 2 array of circles, each of radius 0.5, centered at (11), (1-1), (-11), (-1-1).","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"RadC = 0.5\nΔs = 1.4*cellsize(g)\nbody = Circle(RadC,Δs)","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"We set up the body list by pushing copies of the same body onto the list. (We use deepcopy to ensure that these are copies, rather than pointers to the same body.)","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"bl = BodyList()\npush!(bl,deepcopy(body))\npush!(bl,deepcopy(body))\npush!(bl,deepcopy(body))\npush!(bl,deepcopy(body))","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"Now we move them into position. We also use a RigidTransform for each, which we also assemble into a list. (The ! is for convenience, using Julia convention, to remind us that each transform operates in-place on the body.)","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"t1! = RigidTransform((1.0,1.0),0.0)\nt2! = RigidTransform((1.0,-1.0),0.0)\nt3! = RigidTransform((-1.0,1.0),0.0)\nt4! = RigidTransform((-1.0,-1.0),0.0)\ntl! = RigidTransformList([t1!,t2!,t3!,t4!])\nnothing #hide","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"Finally, we apply the transform. We can apply the transform list directly to the body list:","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"tl!(bl)","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"Now we can create the cache, and inspect it by plotting","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"cache = SurfaceScalarCache(bl,g,scaling=GridScaling)\nplot(cache,xlims=(-2,2),ylims=(-2,2))","category":"page"},{"location":"manual/multbodies/#Body-by-body-calculations","page":"Multiple bodies","title":"Body-by-body calculations","text":"","category":"section"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"We can now perform operations on data that exploit the division into distinct bodies. For example, let's compute the integral of mathbfxcdotmathbfn, for body 3. For any of the bodies, this integral should be approximately equal to the area enclosed by the body (or volume in 3-d), multiplied by 2 (or 3 in 3-d). For a circle of radius 12, this area is pi4, so we expect the result to be nearly pi2. We use the pointwise_dot operation in CartesianGrids.jl to perform the dot product at each point.","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"pts = points(cache)\nnrm = normals(cache)\nV3 = integrate(pointwise_dot(pts,nrm),cache,3)","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"We can also integrate VectorData over individual bodies, and the result is simply a vector with the integral in each coordinate direction. Let's demonstrate on another geometric integral, this time of (mathbfxcdotmathbfx)mathbfn, This integral, when divided by the enclosed area (volume) of the body, is equal to the centroid of the body. Let's demonstrate on body 3, which we expect to be centered at (-1,1)","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"Xc = integrate(pointwise_dot(pts,pts)∘nrm,cache,3)/V3","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"Other operations we can perform body-by-body are dot and norm","category":"page"},{"location":"manual/multbodies/#Copying-data-body-by-body","page":"Multiple bodies","title":"Copying data body by body","text":"","category":"section"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"It is common that we will want to assign values to surface data, one body at a time. For this, we can make use of an extension of the copyto! function. Let's see some examples. Suppose we wish to set the value of a surface scalar u to the x component of the normal vectors for points on body 3, but leave the values zero for all other bodies. Then we just do the following:","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"u = zeros_surface(cache)\ncopyto!(u,nrm.u,cache,3)\nnothing #hide","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"Let's plot the data to verify this worked","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"plot(u)","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"We can also plot just the data on body 3 (versus the arclength)","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"plot(u,cache,bodyid=3,xlabel=\"arc length\")","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"It is also possible to use copyto! to copy a vector of just the right size of the subarray associated with the body.","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"EditURL = \"<unknown>/literate/dirichlet.jl\"","category":"page"},{"location":"manual/dirichlet/#A-Dirichlet-Poisson-problem","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"","category":"section"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Now, let's put together a lot of the tools we've discussed earlier to solve a standard problem: the solution of Laplace's equation, with Dirichlet boundary conditions on a surface. Our objective is to solve this problem with one Dirichlet value for the region external to the surface, and another Dirichlet value internal to the surface.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"To be specific, our problem is","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"nabla^2varphi^+ = 0qquad nabla^2varphi^- = 0","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"where + denotes the exterior and - the interior of the surface. (We will consider a circle of radius 1.) The boundary conditions on this surface are","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"varphi^+ = x qquad varphi^- = 0","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"In other words, we seek to set the value on the exterior to the local x coordinate of the surface, while the interior should have zero field.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Discretizing this problem by the techniques developed in [1], we seek to solve","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"beginbmatrix L  R  R^T  0 endbmatrix beginpmatrix f  -s endpmatrix = beginpmatrix D_s d  overlinef_b endpmatrix","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"where overlinef_b = (f^+_b + f^-_b)2 = x2 and d = f^+_b - f^-_b = x.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"This saddle-point problem can be solved by block-LU decomposition. First solve","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"L f^* = D_s d","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"for f^*. Then solve","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"R^TL^-1R s = overlinef_b - R^T f^*","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"for s, and finally, compute","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"f = f^* + L^-1R s","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"We will demonstrate these steps here.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"using ImmersedLayers\nusing Plots\nusing LinearAlgebra","category":"page"},{"location":"manual/dirichlet/#Set-up-the-grid,-shape,-and-cache","page":"A Dirichlet Poisson problem","title":"Set up the grid, shape, and cache","text":"","category":"section"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"We do this just as we did in Immersed layer caches","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Δx = 0.01\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx)\nRadC = 1.0\nΔs = 1.4*cellsize(g)\nbody = Circle(RadC,Δs)\ncache = SurfaceScalarCache(body,g,scaling=GridScaling);\nnothing #hide","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Let's set up the right-hand side values, D_s d and overlinef_b. We will use fstar as a placeholder for the right-hand side of the upper equations.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"pts = points(cache)\nx = zeros_surface(cache)\nfb = zeros_surface(cache)\nfstar = zeros_grid(cache)\nx .= pts.u\nsurface_divergence!(fstar,x,cache)\nfb .= 0.5*x;\nnothing #hide","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"First step in the algorithm, find f^*","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"inverse_laplacian!(fstar,cache);\nnothing #hide","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Now, generate the Schur complement matrix, S = -R^TL^-1R, using create_RTLinvR,","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"S = create_RTLinvR(cache);\nnothing #hide","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Now we set up the right-hand side of the Schur complement system, and solve for the Lagrange multipliers, s. We will use s as a placeholder for the right-hand side, first holding R^T f^*, then overlinef_b - R^T f^*, and finally, the solution of - S s = overlinef_b - R^T f^*.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"s = zeros_surface(cache)\ninterpolate!(s,fstar,cache)\ns .= fb - s\ns .= -(S\\s);\nnothing #hide","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Finally, correct f^* with L^-1Rs","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"f = zeros_grid(cache)\nregularize!(f,s,cache)\ninverse_laplacian!(f,cache)\nf .+= fstar;\nnothing #hide","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Now, let's look at the resulting field","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"plot(f,cache)","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"We can see that the field external to the circle has the expected behavior, and the solution inside the circle is blank, indicating it is zero.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Let's also plot the solution for s on the surface. We will plot the 'raw' result, which is rather noisy, and also apply the filtering matrix C = tildeR^T R several times to smooth it out.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"C = create_surface_filter(cache)\nplot(s,cache,label=\"Original solution\")\ns .= C^5*s;\nplot!(s,cache,label=\"Filtered solution\")","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"[1]: Eldredge, J. D. (2021) \"A method of immersed layers on Cartesian grids, with application to incompressible flows,\" arXiv:2103.04521.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/helmholtz/","page":"Helmholtz decomposition","title":"Helmholtz decomposition","text":"EditURL = \"<unknown>/literate/helmholtz.jl\"","category":"page"},{"location":"manual/helmholtz/#Helmholtz-decomposition","page":"Helmholtz decomposition","title":"Helmholtz decomposition","text":"","category":"section"},{"location":"manual/helmholtz/","page":"Helmholtz decomposition","title":"Helmholtz decomposition","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/helmholtz/","page":"Helmholtz decomposition","title":"Helmholtz decomposition","text":"For vector fields on the grid, we often prefer to work with potentials of that field and compose the vector field from these potentials. This is the so-called Helmholtz decomposition","category":"page"},{"location":"manual/helmholtz/","page":"Helmholtz decomposition","title":"Helmholtz decomposition","text":"mathbfv = nablaphi + nablatimespsi","category":"page"},{"location":"manual/helmholtz/","page":"Helmholtz decomposition","title":"Helmholtz decomposition","text":"where psi is a vector potential (or streamfunction in two dimensions) and phi is a scalar potential. Note that, in an unbounded domain, phi satisfies a Poisson equation:","category":"page"},{"location":"manual/helmholtz/","page":"Helmholtz decomposition","title":"Helmholtz decomposition","text":"nabla^2phi = nablacdotmathbfv","category":"page"},{"location":"manual/helmholtz/","page":"Helmholtz decomposition","title":"Helmholtz decomposition","text":"and, assuming that psi has zero 'gauge' (i.e., its divergence is zero), then psi also satisfies a Poisson equation:","category":"page"},{"location":"manual/helmholtz/","page":"Helmholtz decomposition","title":"Helmholtz decomposition","text":"nabla^2psi = -nablatimesmathbfv","category":"page"},{"location":"manual/helmholtz/","page":"Helmholtz decomposition","title":"Helmholtz decomposition","text":"So we can recover the velocity field from the divergence and curl of the vector field (in fluid dynamics, these are the rate of dilatation and the vorticity, respectively) by solving these equations for the potentials and then evaluating their gradient and curl.","category":"page"},{"location":"manual/helmholtz/","page":"Helmholtz decomposition","title":"Helmholtz decomposition","text":"With immersed layers, these are extendable to domains with surfaces and their associated jump in the vector field mathbfv = mathbfv^+ - mathbfv^-. The crucial relationships are","category":"page"},{"location":"manual/helmholtz/","page":"Helmholtz decomposition","title":"Helmholtz decomposition","text":"nablacdotoverlinemathbfv = overlinenablacdotmathbfv + delta(chi)mathbfncdotmathbfv","category":"page"},{"location":"manual/helmholtz/","page":"Helmholtz decomposition","title":"Helmholtz decomposition","text":"and","category":"page"},{"location":"manual/helmholtz/","page":"Helmholtz decomposition","title":"Helmholtz decomposition","text":"nablatimesoverlinemathbfv = overlinenablatimesmathbfv + delta(chi)mathbfntimesmathbfv","category":"page"},{"location":"manual/helmholtz/","page":"Helmholtz decomposition","title":"Helmholtz decomposition","text":"These are, respectively, the divergence and curl of the masked vector field, overlinemathbfv. In ImmersedLayers.jl, we are always working with the masked form of a field, whether we acknowledge it or not. In contrast, the first terms on the right-hand sides of these are the masked divergence and curl of the vector field in each side of the surface. The difference between these is a type of single-layer surface term–-a 'source sheet' or a 'vortex sheet', respectively–- due to the jump in vector field. If we omit the overbar notation, then the Helmholtz decomposition and the Poisson equations all still hold.","category":"page"},{"location":"manual/helmholtz/","page":"Helmholtz decomposition","title":"Helmholtz decomposition","text":"This package has a number of routines that can be used to perform the operations described here. They rely on two caches, ScalarPotentialCache and VectorPotentialCache, each of which supports one of the respective potentials. The function vecfield_helmholtz! carries out all of these operations in order to assemble the vector field mathbfv from the masked divergence and curl fields and the jump in the vector field. (We can also add an additional irrotational, divergence-free vector field during this assembly.","category":"page"},{"location":"manual/helmholtz/#Helmholtz-decomposition-functions","page":"Helmholtz decomposition","title":"Helmholtz decomposition functions","text":"","category":"section"},{"location":"manual/helmholtz/","page":"Helmholtz decomposition","title":"Helmholtz decomposition","text":"ScalarPotentialCache\nVectorPotentialCache\nvectorpotential_from_masked_curlv!\nscalarpotential_from_masked_divv!\nvectorpotential_from_curlv!\nvecfield_from_vectorpotential!\nmasked_curlv_from_curlv_masked!\ncurlv_masked_from_masked_curlv!\nscalarpotential_from_divv!\nmasked_divv_from_divv_masked!\ndivv_masked_from_masked_divv!\nvecfield_from_scalarpotential!\nvecfield_helmholtz!\nvectorpotential_uniformvecfield!\nscalarpotential_uniformvecfield!\nvecfield_uniformvecfield!","category":"page"},{"location":"manual/helmholtz/#ImmersedLayers.ScalarPotentialCache","page":"Helmholtz decomposition","title":"ImmersedLayers.ScalarPotentialCache","text":"ScalarPotentialCache(base_cache::BasicILMCache)\n\nCreate a cache for calculations involving the scalar potential field that induces a vector field on the grid. The base cache must be in support of vector field data.\n\n\n\n\n\n","category":"type"},{"location":"manual/helmholtz/#ImmersedLayers.VectorPotentialCache","page":"Helmholtz decomposition","title":"ImmersedLayers.VectorPotentialCache","text":"VectorPotentialCache(base_cache::BasicILMCache)\n\nCreate a cache for calculations involving the vector potential field (i.e. streamfunction) that induces a vector field on the grid. The base cache must be in support of vector field data.\n\n\n\n\n\n","category":"type"},{"location":"manual/helmholtz/#ImmersedLayers.vectorpotential_from_masked_curlv!","page":"Helmholtz decomposition","title":"ImmersedLayers.vectorpotential_from_masked_curlv!","text":"vectorpotential_from_masked_curlv!(ψ::Nodes{Dual},masked_curlv::Nodes{Dual},dv::VectorData,base_cache::BasicILMCache,wcache::VectorPotentialCache)\n\nReturn the vector potential field ψ from the masked curl of the vector field, masked_curlv (overlinenablatimesmathbfv), the jump in the vector field across immersed surface dv. It solves\n\nL_npsi = -overlinenablatimesmathbfv - R_nmathbfntimesmathbfv\n\nand returns psi.\n\n\n\n\n\n","category":"function"},{"location":"manual/helmholtz/#ImmersedLayers.scalarpotential_from_masked_divv!","page":"Helmholtz decomposition","title":"ImmersedLayers.scalarpotential_from_masked_divv!","text":"scalarpotential_from_masked_divv!(ϕ::Nodes{Primal},masked_divv::Nodes{Primal},dv::VectorData,base_cache::BasicILMCache,dcache::ScalarPotentialCache)\n\nReturn the scalar potential field ϕ from the masked divergence of the vector field, masked_divv (overlinenablacdotmathbfv) the jump in the vector field across immersed surface dv. It solves\n\nL_cphi = overlinenablacdotmathbfv + R_cmathbfncdotmathbfv\n\nand returns phi.\n\n\n\n\n\n","category":"function"},{"location":"manual/helmholtz/#ImmersedLayers.vectorpotential_from_curlv!","page":"Helmholtz decomposition","title":"ImmersedLayers.vectorpotential_from_curlv!","text":"vectorpotential_from_curlv!(ψ::Nodes{Dual},curlv::Nodes{Dual},base_cache::BasicILMCache)\n\nReturn the vector potential field ψ from the curl of the masked vector field, curlv (nablatimesoverlinemathbfv), the jump in the vector field across immersed surface dv. It solves\n\nL_npsi = -nablatimesoverlinemathbfv\n\nand returns psi.\n\n\n\n\n\n","category":"function"},{"location":"manual/helmholtz/#ImmersedLayers.vecfield_from_vectorpotential!","page":"Helmholtz decomposition","title":"ImmersedLayers.vecfield_from_vectorpotential!","text":"vecfield_from_vectorpotential!(v::Edges{Primal},ψ::Nodes{Dual},base_cache::BasicILMCache)\n\nReturn the vector field v associated with vector potential field ψ (in 2-d, a scalar streamfunction), via the curl\n\nmathbfv = nablatimespsi mathbfe_z\n\n\n\n\n\n","category":"function"},{"location":"manual/helmholtz/#ImmersedLayers.masked_curlv_from_curlv_masked!","page":"Helmholtz decomposition","title":"ImmersedLayers.masked_curlv_from_curlv_masked!","text":"masked_curlv_from_curlv_masked!(masked_curlv::Nodes{Dual},curlv::Nodes{Dual},dv::VectorData,base_cache::BasicILMCache,wcache::VectorPotentialCache)\n\nReturn the masked curl of the vector field overlinenablatimesmathbfv (masked_curlv) from the curl of the masked vector field nablatimesoverlinemathbfv (curlv). It obtains this from\n\noverlinenablatimesmathbfv = nablatimesoverlinemathbfv - R_nmathbfntimesmathbfv\n\n\n\n\n\n","category":"function"},{"location":"manual/helmholtz/#ImmersedLayers.curlv_masked_from_masked_curlv!","page":"Helmholtz decomposition","title":"ImmersedLayers.curlv_masked_from_masked_curlv!","text":"curlv_masked_from_masked_curlv!(curlv::Nodes{Dual},masked_curlv::Nodes{Dual},dv::VectorData,base_cache::BasicILMCache,wcache::VectorPotentialCache)\n\nReturn the curl of the masked vector field nablatimesoverlinemathbfv (curlv) from the masked curl of the vector field overlinenablatimesmathbfv (masked_curlv). It obtains this from\n\nnablatimesoverlinemathbfv = overlinenablatimesmathbfv + R_nmathbfntimesmathbfv\n\n\n\n\n\n","category":"function"},{"location":"manual/helmholtz/#ImmersedLayers.scalarpotential_from_divv!","page":"Helmholtz decomposition","title":"ImmersedLayers.scalarpotential_from_divv!","text":"scalarpotential_from_divv!(ϕ::Nodes{Primal},divv::Nodes{Primal},base_cache::BasicILMCache,dcache::ScalarPotentialCache)\n\nReturn the scalar potential field ϕ from the divergence of the masked vector field, divv (nablacdotoverlinemathbfv) the jump in the vector field across immersed surface dv. It solves\n\nL_cphi = nablacdotoverlinemathbfv\n\nand returns phi.\n\n\n\n\n\n","category":"function"},{"location":"manual/helmholtz/#ImmersedLayers.masked_divv_from_divv_masked!","page":"Helmholtz decomposition","title":"ImmersedLayers.masked_divv_from_divv_masked!","text":"masked_divv_from_divv_masked!(masked_divv::Nodes{Primal},divv::Nodes{Primal},dv::VectorData,base_cache::BasicILMCache,dcache::ScalarPotentialCache)\n\nReturn the masked divergence of the vector field overlinenablacdotmathbfv (masked_divv) from the divergence of the masked vector field nablacdotoverlinemathbfv (divv). It obtains this from\n\noverlinenablacdotmathbfv = nablacdotoverlinemathbfv - R_cmathbfncdotmathbfv\n\n\n\n\n\n","category":"function"},{"location":"manual/helmholtz/#ImmersedLayers.divv_masked_from_masked_divv!","page":"Helmholtz decomposition","title":"ImmersedLayers.divv_masked_from_masked_divv!","text":"divv_masked_from_masked_divv!(divv::Nodes{Primal},masked_divv::Nodes{Primal},dv::VectorData,base_cache::BasicILMCache,dcache::ScalarPotentialCache)\n\nReturn the divergence of the masked vector field nablacdotoverlinemathbfv (divv) from the masked divergence of the vector field overlinenablacdotmathbfv (masked_divv). It obtains this from\n\nnablacdotoverlinemathbfv = overlinenablacdotmathbfv + R_cmathbfncdotmathbfv\n\n\n\n\n\n","category":"function"},{"location":"manual/helmholtz/#ImmersedLayers.vecfield_from_scalarpotential!","page":"Helmholtz decomposition","title":"ImmersedLayers.vecfield_from_scalarpotential!","text":"vecfield_from_scalarpotential!(v::Edges{Primal},ϕ::Nodes{Primal},base_cache::BasicILMCache)\n\nReturn the vector field v associated with scalar potential field ϕ, via the gradient\n\nmathbfv = nablaphi\n\n\n\n\n\n","category":"function"},{"location":"manual/helmholtz/#ImmersedLayers.vecfield_helmholtz!","page":"Helmholtz decomposition","title":"ImmersedLayers.vecfield_helmholtz!","text":"vecfield_helmholtz!(v::Edges{Primal},curlv::Nodes{Dual},divv::Nodes{Primal},dv::VectorData,vp::Union{Edges{Primal},Nothing},base_cache::BasicILMCache,veccache::VectorFieldCache)\n\nRecover the vector field v from the masked curl field curlv (overlinenablatimesmathbfv), divergence field divv (overlinenablacdotmathbfv), surface vector jump dv (mathbfv), and additional irrotational, divergence-free vector field vp. It obtains this from the Helmholtz decomposition,\n\nmathbfv = nablatimespsi + nablaphi + mathbfv_p\n\nin which psi is the solution of\n\nL_noverlinepsi = -overlinenablatimesmathbfv - R_nmathbfntimesmathbfv\n\nin which phi is the solution of\n\nL_coverlinephi = overlinenablacdotmathbfv + R_cmathbfncdotmathbfv\n\nIt is important to stress that curlv is the masked curl of the vector field, not the curl of the masked vector field. To get this the former from the latter, use masked_curlv_from_curlv_masked!. Similarly for divv, which is the masked divergence of the vector field, not the divergence of the masked vector field. One can use masked_divv_from_divv_masked! for this.\n\nTo specify the irrotational, divergence-free vector field vp, one can also simply provide a tuple, e.g., (1.0,0.0), to specify a uniform vector field.\n\n\n\n\n\n","category":"function"},{"location":"manual/helmholtz/#ImmersedLayers.vectorpotential_uniformvecfield!","page":"Helmholtz decomposition","title":"ImmersedLayers.vectorpotential_uniformvecfield!","text":"vectorpotential_uniformvecfield!(ψ::Nodes{Dual},Vx::Real,Vy::Real,base_cache::BasicILMCache)\n\nReturn a vector potential field ψ associated with a uniform vector field with the components Vx and Vy.\n\n\n\n\n\n","category":"function"},{"location":"manual/helmholtz/#ImmersedLayers.scalarpotential_uniformvecfield!","page":"Helmholtz decomposition","title":"ImmersedLayers.scalarpotential_uniformvecfield!","text":"scalarpotential_uniformvecfield!(ϕ::Nodes{Primal},Vx::Real,Vy::Real,base_cache::BasicILMCache)\n\nReturn a vector potential field ϕ associated with a uniform vector field with the components Vx and Vy.\n\n\n\n\n\n","category":"function"},{"location":"manual/helmholtz/#ImmersedLayers.vecfield_uniformvecfield!","page":"Helmholtz decomposition","title":"ImmersedLayers.vecfield_uniformvecfield!","text":"vecfield_uniformvecfield!(v::Edges{Primal},Vx::Real,Vy::Real,base_cache::BasicILMCache)\n\nReturn a vector field v filled with the uniform components Vx and Vy, respectively.\n\n\n\n\n\n","category":"function"},{"location":"manual/helmholtz/","page":"Helmholtz decomposition","title":"Helmholtz decomposition","text":"","category":"page"},{"location":"manual/helmholtz/","page":"Helmholtz decomposition","title":"Helmholtz decomposition","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"EditURL = \"<unknown>/literate/neumann.jl\"","category":"page"},{"location":"manual/neumann/#Poisson-with-Neumann-conditions","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"","category":"section"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"Here, we'll demonstrate a solution of Laplace's equation, with Neumann boundary conditions on a surface. Similar to the Dirichlet problem in A Dirichlet Poisson problem, we will solve the problem with one Neumann condition external to the surface, and another Neumann value internal to the surface.","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"Our underlying problem is still","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"nabla^2varphi^+ = 0qquad nabla^2varphi^- = 0","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"where + denotes the exterior and - the interior of the surface. (We will consider a circle of radius 1.) The boundary conditions on this surface are","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"mathbfncdotnablavarphi^+ = v^+_n qquad mathbfncdotnablavarphi^- = v^-_n","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"In other words, we seek to set the value on the exterior normal derivative to v_n of the local normal vector on the surface, while the interior should have zero normal derivative.","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"Discretizing this problem by the usual techniques, we seek to solve","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"beginbmatrix L  D_s  G_s  R_n^T R_n endbmatrix beginpmatrix f  -phi endpmatrix = beginpmatrix R v_n  overlinev_n endpmatrix","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"where overlinev_n = (v^+_n + v^-_n)2 and v_n = v^+_n - v^-_n. The resulting phi is f^+-f^-.","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"As with the Dirichlet problem, this saddle-point problem can be solved by block-LU decomposition. First solve","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"L f^* = R v_n","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"for f^*. Then solve","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"-S phi = overlinev_n - G_s f^*","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"for phi, where S = R_n^T R_n - G_s L^-1 D_s = -C_s L^-1C_s^T, and finally, compute","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"f = f^* + L^-1D_s phi","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"It should be remembered that, for any scalar potential field, there is a corresponding streamfunction psi that generates the same flow. We can get that field, as well, with only a little bit more effort:","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"S psi = C_s f^*","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"and then solve","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"L s = C_s^T phi - hatC_s^T psi","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":".","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"for the streamfunction s.","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"using ImmersedLayers\nusing Plots\nusing LinearAlgebra\nusing UnPack","category":"page"},{"location":"manual/neumann/#Set-up-the-extra-cache-and-solve-function","page":"Poisson with Neumann conditions","title":"Set up the extra cache and solve function","text":"","category":"section"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"The problem type takes the usual basic form","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"@ilmproblem NeumannPoisson scalar","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"The extra cache holds additional intermediate data, as well as the Schur complement. We don't bother creating a filtering matrix here.","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"struct NeumannPoissonCache{SMT,DVT,VNT,FT,ST} <: AbstractExtraILMCache\n   S :: SMT\n   dvn :: DVT\n   vn :: VNT\n   fstar :: FT\n   sstar :: ST\nend","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"The function prob_cache, as before, constructs the operators and extra cache data structures","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"function ImmersedLayers.prob_cache(prob::NeumannPoissonProblem,base_cache::BasicILMCache)\n    S = create_CLinvCT(base_cache)\n    dvn = zeros_surface(base_cache)\n    vn = zeros_surface(base_cache)\n    fstar = zeros_grid(base_cache)\n    sstar = zeros_gridcurl(base_cache)\n    NeumannPoissonCache(S,dvn,vn,fstar,sstar)\nend\nnothing #hide","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"And finally, here's the steps we outlined above, used to extend the solve function","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"function ImmersedLayers.solve(prob::NeumannPoissonProblem,sys::ILMSystem)\n    @unpack extra_cache, base_cache, bc, phys_params = sys\n    @unpack S, dvn, vn, fstar, sstar = extra_cache\n\n    fill!(fstar,0.0)\n    fill!(sstar,0.0)\n\n    f = zeros_grid(base_cache)\n    s = zeros_gridcurl(base_cache)\n    df = zeros_surface(base_cache)\n    ds = zeros_surface(base_cache)\n\n    # Get the precribed jump and average of the surface normal derivatives\n    prescribed_surface_jump!(dvn,sys)\n    prescribed_surface_average!(vn,sys)\n\n    # Find the potential\n    regularize!(fstar,dvn,base_cache)\n    inverse_laplacian!(fstar,base_cache)\n\n    surface_grad!(df,fstar,base_cache)\n    df .= vn - df\n    df .= -(S\\df);\n\n    surface_divergence!(f,df,base_cache)\n    inverse_laplacian!(f,base_cache)\n    f .+= fstar\n\n    # Find the streamfunction\n    surface_curl!(sstar,df,base_cache)\n\n    surface_grad_cross!(ds,fstar,base_cache)\n    ds .= S\\ds\n\n    surface_curl_cross!(s,ds,base_cache)\n    s .-= sstar\n    s .*= -1.0\n\n    inverse_laplacian!(s,base_cache)\n\n    return f, df, s, ds\nend\nnothing #hide","category":"page"},{"location":"manual/neumann/#Solve-the-problem","page":"Poisson with Neumann conditions","title":"Solve the problem","text":"","category":"section"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"Here, we will demonstrate the solution on a circular shape of radius 1, with v_n^+ = n_x and v_n^- = 0. This is actually the set of conditions used to compute the unit scalar potential field (and, as we will see, the added mass) in potential flow.","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"Set up the grid","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"Δx = 0.01\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx)\nΔs = 1.4*cellsize(g)\nbody = Circle(1.0,Δs);\nnothing #hide","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"Set the boundary condition functions","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"function get_vnplus(base_cache,phys_params)\n    nrm = normals(base_cache)\n    vnplus = zeros_surface(base_cache)\n    vnplus .= nrm.u\n    return vnplus\nend\nget_vnminus(base_cache,phys_params) = zeros_surface(base_cache)\n\nbcdict = Dict(\"exterior\"=>get_vnplus,\"interior\"=>get_vnminus)","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"Create the system","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"prob = NeumannPoissonProblem(g,body,scaling=GridScaling,bc=bcdict)\nsys = construct_system(prob)\nnothing #hide","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"Solve it","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"solve(prob,sys) #hide\n@time f, df, s, ds = solve(prob,sys);\nnothing #hide","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"and plot the field","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"plot(plot(f,sys,layers=true,levels=30,title=\"ϕ\"),\nplot(s,sys,layers=true,levels=30,title=\"ψ\"))","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"and the Lagrange multiplier field, phi, on the surface","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"plot(df,sys)","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"If, instead, we set the inner boundary condition to n_x and the outer to zero, then we get the flow inside of a translating circle. All we need to do is re-define the boundary functions","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"function get_vnplus(base_cache,phys_params)\n    vnplus = zeros_surface(base_cache)\n    return vnplus\nend\nfunction get_vnminus(base_cache,phys_params)\n    nrm = normals(base_cache)\n    vnminus = zeros_surface(base_cache)\n    vnminus .= nrm.u\n    return vnminus\nend\n\nf, df, s, ds = solve(prob,sys);\nplot(plot(f,sys,layers=true,levels=30,title=\"ϕ\"),\nplot(s,sys,layers=true,levels=30,title=\"ψ\"))","category":"page"},{"location":"manual/neumann/#Multiple-bodies","page":"Poisson with Neumann conditions","title":"Multiple bodies","text":"","category":"section"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"The cache and solve function we created above can be applied for any body or set of bodies. Let's apply it here to a circle of radius 0.25 inside of a square of half-side length 2, where our goal is to find the effect of the enclosing square on the motion of the circle. As such, we will set the Neumann conditions both internal to and external to the square to be 0, but for the exterior of the circle, we set it to n_x.","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"bl = BodyList();\npush!(bl,Square(1.0,Δs))\npush!(bl,Circle(0.25,Δs))\nnothing #hide","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"We don't actually have to transform these shapes, but it is illustrative to show how we would move them.","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"t1 = RigidTransform((0.0,0.0),0.0)\nt2 = RigidTransform((0.0,0.0),0.0)\ntl = RigidTransformList([t1,t2])\ntl(bl)\nnothing #hide","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"Set the boundary conditions. We set only the exterior Neumann value of body 2 (the circle). This gives us an opportunity to demonstrate the  copyto! function, which is useful for setting only the part of  the overall surface data associated with a certain body.","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"function get_vnplus(base_cache,phys_params)\n    nrm = normals(base_cache)\n    vnplus = zeros_surface(base_cache)\n    copyto!(vnplus,nrm.u,base_cache,2)\n    return vnplus\nend\nfunction get_vnminus(base_cache,phys_params)\n    vnminus = zeros_surface(base_cache)\n    return vnminus\nend\nbcdict = Dict(\"exterior\"=>get_vnplus,\"interior\"=>get_vnminus)","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"Create the problem and system","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"prob = NeumannPoissonProblem(g,bl,scaling=GridScaling,bc=bcdict)\nsys = construct_system(prob)\nnothing #hide","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"Solve it and plot","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"f, df, s, ds  = solve(prob,sys)\nplot(plot(f,sys,layers=true,levels=30,title=\"ϕ\"),\nplot(s,sys,layers=true,levels=30,title=\"ψ\"))","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"Now, let's compute the added mass components of the circle associated with this motion. We are approximating","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"M = -int_C_2 f^+ mathbfnmathrmds","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"where C_2 is shape 2 (the circle), and f^+ is simply phi on body 2.","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"nrm = normals(sys)\nM = -integrate(df∘nrm,sys,2)","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"As one would expect, the circle has added mass in the x direction associated with moving in that direction.","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"","category":"page"},{"location":"manual/neumann/","page":"Poisson with Neumann conditions","title":"Poisson with Neumann conditions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"manual/utilities/","page":"Utilities","title":"Utilities","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/utilities/#Surface-point-utilities","page":"Utilities","title":"Surface point utilities","text":"","category":"section"},{"location":"manual/utilities/","page":"Utilities","title":"Utilities","text":"areas(::Body)\nnormals(::Body)\npoints(::Body)\narcs(::Body)\ndot(::ScalarData{N},::ScalarData{N},::ScalarData{N}) where {N}\nnorm(::PointData{N},::ScalarData{N}) where {N}\nintegrate(::ScalarData{N},::ScalarData{N}) where {N}\nones(::ScalarData)","category":"page"},{"location":"manual/utilities/#ImmersedLayers.areas-Tuple{Body}","page":"Utilities","title":"ImmersedLayers.areas","text":"areas(b::Body/BodyList)\n\nReturn ScalarData filled with the 1-d areas (via midpoint rule) associated with b.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#ImmersedLayers.normals-Tuple{Body}","page":"Utilities","title":"ImmersedLayers.normals","text":"normals(b::Body/BodyList)\n\nReturn VectorData filled with the normal vectors (via midpoint rule) associated with b.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#ImmersedLayers.points-Tuple{Body}","page":"Utilities","title":"ImmersedLayers.points","text":"points(b::Body/BodyList)\n\nReturn VectorData filled with the coordinates of the points associated with b.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#ImmersedLayers.arcs-Tuple{Body}","page":"Utilities","title":"ImmersedLayers.arcs","text":"arcs(b::Body/BodyList)\n\nReturn ScalarData filled with the arclength coordinates associated with b.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#LinearAlgebra.dot-Union{Tuple{N}, Tuple{ScalarData{N, T, DT} where {T, DT<:(AbstractVector{T} where T)}, ScalarData{N, T, DT} where {T, DT<:(AbstractVector{T} where T)}, ScalarData{N, T, DT} where {T, DT<:(AbstractVector{T} where T)}}} where N","page":"Utilities","title":"LinearAlgebra.dot","text":"dot(u1::PointData,u2::PointData,ds::ScalarData)\n\nReturn the inner product between u1 and u2, weighted by ds.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#LinearAlgebra.norm-Union{Tuple{N}, Tuple{PointData{N, T} where T, ScalarData{N, T, DT} where {T, DT<:(AbstractVector{T} where T)}}} where N","page":"Utilities","title":"LinearAlgebra.norm","text":"norm(u::PointData,ds::ScalarData)\n\nReturn the norm of u, weighted by ds.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#CartesianGrids.integrate-Union{Tuple{N}, Tuple{ScalarData{N, T, DT} where {T, DT<:(AbstractVector{T} where T)}, ScalarData{N, T, DT} where {T, DT<:(AbstractVector{T} where T)}}} where N","page":"Utilities","title":"CartesianGrids.integrate","text":"integrate(u::PointData,ds::ScalarData)\n\nCalculate the discrete surface integral of data u, using the surface element areas in ds. This uses trapezoidal rule quadrature. If u is VectorData, then this returns a vector of the integrals in each coordinate direction.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#Base.ones-Tuple{ScalarData}","page":"Utilities","title":"Base.ones","text":"ones(u::PointData)\n\nReturns PointData of the same type as u filled with ones.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#Surface-point-utilities-on-body-lists","page":"Utilities","title":"Surface point utilities on body lists","text":"","category":"section"},{"location":"manual/utilities/","page":"Utilities","title":"Utilities","text":"copyto!(::PointData,::PointData,::BodyList,::Int)\ncopyto!(::ScalarData,::AbstractVector,::BodyList,::Int)","category":"page"},{"location":"manual/utilities/#Base.copyto!-Tuple{PointData, PointData, BodyList, Int64}","page":"Utilities","title":"Base.copyto!","text":"copyto!(u::PointData,v::PointData,bl::BodyList,i::Int)\n\nCopy the data in the elements of v associated with body i in body list bl to the corresponding elements in u. These data must be of the same type (e.g., ScalarData or VectorData) and have the same length.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#Base.copyto!-Tuple{ScalarData, AbstractVector{T} where T, BodyList, Int64}","page":"Utilities","title":"Base.copyto!","text":"copyto!(u::ScalarData,v::AbstractVector,bl::BodyList,i::Int)\n\nCopy the data in v to the elements in u associated with body i in body list bl. v must have the same length as this subarray of u associated with i.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#Grid-utilities","page":"Utilities","title":"Grid utilities","text":"","category":"section"},{"location":"manual/utilities/","page":"Utilities","title":"Utilities","text":"dot(::GridData{NX,NY},::GridData{NX,NY},::PhysicalGrid) where {NX,NY}\nnorm(::GridData,::PhysicalGrid)","category":"page"},{"location":"manual/utilities/#LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{GridData{NX, NY, T} where T, GridData{NX, NY, T} where T, PhysicalGrid}} where {NX, NY}","page":"Utilities","title":"LinearAlgebra.dot","text":"dot(u1::GridData,u2::GridData,g::PhysicalGrid)\n\nReturn the inner product between u1 and u2 weighted by the volume (area) of the cell in grid g.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#LinearAlgebra.norm-Tuple{GridData, PhysicalGrid}","page":"Utilities","title":"LinearAlgebra.norm","text":"norm(u::GridData,g::PhysicalGrid)\n\nReturn the L2 norm of u, weighted by the volume (area) of the cell in grid g.\n\n\n\n\n\n","category":"method"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"EditURL = \"<unknown>/literate/problems.jl\"","category":"page"},{"location":"manual/problems/#Problems-and-the-system","page":"Problems and the system","title":"Problems and the system","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"In specific problems that we wish to solve with immersed layers, there may be other data and operators that we would like to cache. We do this with an extra cache, which the user can define, along with a problem type associated with this cache. The basic cache and the extra cache are generated and associated together in a system.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"There are a few basic ingredients to do this:","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Create a problem type, using the macro @ilmproblem. This mostly just serves as a means of dispatching correctly, but also holds the grid and bodies so they can be passed along when the caches are constructed.\nCreate an extra cache type, making it a subtype of AbstractExtraILMCache. This can hold pretty much anything you want it to.\nExtend the function prob_cache(prob,base_cache) to serve as a constructor for your extra cache, when your problem type is passed in.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Optionally, you can also extend the function solve in order to perform the steps of your algorithm. However, generically, you can just use pass in the system structure, which holds the basic ILM cache and your extra cache, into any function.","category":"page"},{"location":"manual/problems/#Example-of-problem-and-system-use","page":"Problems and the system","title":"Example of problem and system use","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"We will demonstrate the use of problems and systems with the example given in A Dirichlet Poisson problem. Here, we will assemble the various additional data structures and operators used to solve this problem into an extra cache. We will also create a problem type called DirichletPoissonProblem, which we make a subtype of AbstractScalarILMProblem.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"using ImmersedLayers\nusing Plots\nusing UnPack","category":"page"},{"location":"manual/problems/#Create-your-problem-type","page":"Problems and the system","title":"Create your problem type","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"For this job, we have a macro","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"@ilmproblem DirichletPoisson scalar","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"This generates a type DirichletPoissonProblem for dispatch, and an associated constructor that we'll use later.","category":"page"},{"location":"manual/problems/#Create-your-extra-cache","page":"Problems and the system","title":"Create your extra cache","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Here, we'd like this extra cache to hold the Schur complement and the filtering matrices, as well as some cache variables.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"struct DirichletPoissonCache{SMT,CMT,FRT,ST,FT} <: ImmersedLayers.AbstractExtraILMCache\n   S :: SMT\n   C :: CMT\n   forcing_cache :: FRT\n   fb :: ST\n   fstar :: FT\nend","category":"page"},{"location":"manual/problems/#Extend-the-prob_cache-function","page":"Problems and the system","title":"Extend the prob_cache function","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"We need this to construct our extra cache. This will get called when the system is constructed. We can make use of the data available in the base_cache (which is already constructed before this is called) in order to create the extra cache. (In the example here, we aren't quite ready to use the forcing_cache, so we just keep it blank for now. We will use it later.)","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"function ImmersedLayers.prob_cache(prob::DirichletPoissonProblem,base_cache::BasicILMCache)\n    S = create_RTLinvR(base_cache)\n    C = create_surface_filter(base_cache)\n    forcing_cache = nothing\n    fb = zeros_surface(base_cache)\n    fstar = zeros_grid(base_cache)\n    DirichletPoissonCache(S,C,forcing_cache,fb,fstar)\nend","category":"page"},{"location":"manual/problems/#Extend-the-solve-function","page":"Problems and the system","title":"Extend the solve function","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Here, we actually do the work of the algorithm, making use of all of the operators and data structures that we have cached for efficiency. The example below takes in some surface Dirichlet data fbplus, and returns the solutions f and s (filtered).","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"function ImmersedLayers.solve(fbplus,prob::DirichletPoissonProblem,sys::ILMSystem)\n    @unpack extra_cache, base_cache = sys\n    @unpack S, C, fb, fstar = extra_cache\n\n    f = zeros_grid(base_cache)\n    s = zeros_surface(base_cache)\n\n    surface_divergence!(fstar,fbplus,base_cache)\n    fb .= 0.5*fbplus\n\n    inverse_laplacian!(fstar,base_cache)\n\n    interpolate!(s,fstar,base_cache)\n    s .= fb - s\n    s .= -(S\\s);\n\n    regularize!(f,s,base_cache)\n    inverse_laplacian!(f,base_cache)\n    f .+= fstar;\n\n    s .= C^6*s\n\n    return f, s\nend","category":"page"},{"location":"manual/problems/#Set-up-the-grid,-shape,-and-cache","page":"Problems and the system","title":"Set up the grid, shape, and cache","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"We do this just as we did in Immersed layer caches, but now we don't create a cache, since it will be done internally.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Δx = 0.01\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx)\nRadC = 1.0\nΔs = 1.4*cellsize(g)\nbody = Circle(RadC,Δs)","category":"page"},{"location":"manual/problems/#Do-the-work","page":"Problems and the system","title":"Do the work","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"We do this in three steps:","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Create the problem instance. This is where we use the constructor generated by @ilmproblem\nCall construct_system to create the caches, assembled into a system\nCall solve to solve the problem.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Also, note that pretty much any function that accepts base_cache as an argument also accepts sys.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"prob = DirichletPoissonProblem(g,body,scaling=GridScaling)\nsys = construct_system(prob)\n\npts = points(sys)\nf, s = solve(pts.u,prob,sys)\n\nplot(f,sys)","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"plot(s,sys)","category":"page"},{"location":"manual/problems/#More-advanced-use,-with-keyword-arguments","page":"Problems and the system","title":"More advanced use, with keyword arguments","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"In the previous example, we supplied the surface data as an argument directly to the solve function. We also didn't have any right-hand side forcing. But in a more general case we might have more complicated boundary conditions or forcing information. This will be particularly true when we get to time varying problems.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"So in this next example, we will demonstrate how the problem constructor can be used to supply more sophisticated information to the solve function. In particular, we will use three keywords:","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"The bc keyword to supply boundary condition information.\nThe forcing keyword to supply forcing.\nThe phys_params keyword to supply physical parameters.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"In general, the philosophy is that we wish to enable the user to provide a function that supplies the required boundary or forcing data. There is a lot of freedom in this approach, as we will demonstrate.","category":"page"},{"location":"manual/problems/#Boundary-conditions","page":"Problems and the system","title":"Boundary conditions","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Here, we wish to construct functions that return the value of f on the outside and inside of the surface. These functions will get called in the solve function, and they will be passed the base cache, the physical parameters. So we can make use of both of these to return the boundary data, e.g., here we return the x coordinate of the surface points on the outside of the surface, and zeros on the inside.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"get_fbplus(base_cache,phys_params) = points(base_cache).u\nget_fbminus(base_cache,phys_params) = zeros_surface(base_cache)","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Using the bc keyword, we can pass these along to the problem specification by various means. To make use of some routines that automate the application of these functions, we must pass them in a Dict, with the keys exterior and interior, respectively.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"bcdict = Dict(\"exterior\"=>get_fbplus,\"interior\"=>get_fbminus)","category":"page"},{"location":"manual/problems/#Forcing","page":"Problems and the system","title":"Forcing","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Forcing can come in several forms. It can be","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"area forcing, in which the forcing is distributed over a whole region, possibly confined\nline forcing, in which the forcing is distributed along a curve (but singular in the orthogonal direction)\npoint forcing, in which the forcing is singular at one or more points","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"In all cases, the user needs to supply some information about the shape of the forcing region and some information about the instantaneous strength of the forcing, in the form of a model function. These get bundled together into a forcing model.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"For confined area forcing and for line forcing, the shape is supplied as a Body or BodyList, similar to bodies (serving as the mask for confined-area forcing and as the curve for line forcing). For point forcing, the shape is the set of discrete points at which we want to apply forcing. We can either supply these points' coordinates directly or provide them via a position function that returns the point coordinates. The advantage of the latter is that it allows the points to be changed later without regenerating the system.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"In the example shown here, we apply point forcing at two points: one at (-1.0,1.5) and the other at (1.0,1.5), with respective strengths -1 and 1. We use a position function to provide the positions. This function must have the signature as shown here, accepting a general state argument, a time argument t, the cache for this forcing, and physical parameters. Any of these can be used to help determine the point positions. In this case, we just simply provide the coordinates directly. However, it is straightforward to pass these in via the state argument (or perhaps to update the positions by some velocity).","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"function my_point_positions(state,t,fr::PointRegionCache,phys_params)\n    x = [-1.0,1.0]\n    y = [1.5,1.5]\n    return x, y\nend","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"The model function returns the strength of the forcing. In this point forcing example, it must return the strength of each point. It must be set up as an in-place function, accepting the vector of strengths and mutating (i.e. changing) this vector. Beyond that, it has the same signature as the position function.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"function my_point_strengths!(σ,state,t,fr::PointRegionCache,phys_params)\n    σ .= [-1.0,1.0]\nend","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Now we bundle these together into the forcing model. We also tell it what kind of regularized DDF we want to use. We use the M_4 DDF here. pfm will get passed into the problem setup via the forcing keyword.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"pfm = PointForcingModel(my_point_positions,my_point_strengths!;ddftype=CartesianGrids.M4prime);\nnothing #hide","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Now, we need to make sure that the forcing data is used. When we generate the extra cache, we use the function ForcingModelAndRegion to assemble the forcing's cache.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"function ImmersedLayers.prob_cache(prob::DirichletPoissonProblem,base_cache::BasicILMCache)\n    @unpack phys_params, forcing = prob\n    S = create_RTLinvR(base_cache)\n    C = create_surface_filter(base_cache)\n    forcing_cache = ForcingModelAndRegion(forcing,base_cache)\n    fb = zeros_surface(base_cache)\n    fstar = zeros_grid(base_cache)\n    DirichletPoissonCache(S,C,forcing_cache,fb,fstar)\nend","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"We now redefine the solve function and use the boundary condition and forcing information. For the forcing, we make use of the function apply_forcing! which takes the forcing and automatically calculates the right-hand side field","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"function ImmersedLayers.solve(prob::DirichletPoissonProblem,sys::ILMSystem)\n    @unpack bc, forcing, phys_params, extra_cache, base_cache = sys\n    @unpack gdata_cache = base_cache\n    @unpack S, C, forcing_cache, fb, fstar = extra_cache\n\n    f = zeros_grid(base_cache)\n    s = zeros_surface(base_cache)\n\n    # apply_forcing! evaluates the forcing field on the grid and put\n    # the result in the `gdata_cache`.\n    fill!(gdata_cache,0.0)\n    apply_forcing!(gdata_cache,f,0.0,forcing_cache,phys_params)\n\n    # Get the prescribed jump in boundary data across the interface using\n    # the functions we supplied via the `Dict`.\n    prescribed_surface_jump!(fb,sys)\n\n    # Evaluate the double-layer term and add it to the right-hand side\n    surface_divergence!(fstar,fb,base_cache)\n    fstar .+= gdata_cache\n\n    # Intermediate solution\n    inverse_laplacian!(fstar,base_cache)\n\n    # Get the prescribed average of boundary data on the interface using\n    # the functions we supplied via the `Dict`.\n    prescribed_surface_average!(fb,sys)\n\n    # Correction\n    interpolate!(s,fstar,base_cache)\n    s .= fb - s\n    s .= -(S\\s);\n\n    regularize!(f,s,base_cache)\n    inverse_laplacian!(f,base_cache)\n    f .+= fstar;\n\n    return f, C^6*s\nend","category":"page"},{"location":"manual/problems/#Set-up-the-problem","page":"Problems and the system","title":"Set up the problem","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Now we specify the problem, create the system, and solve it, as before, but now supplying the boundary condition and forcing information with the bc and forcing keywords:","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"prob = DirichletPoissonProblem(g,body,scaling=GridScaling,bc=bcdict,forcing=pfm)\nsys = construct_system(prob)\nf, s = solve(prob,sys)\nplot(f,sys)","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"So we get the additional features from the sources. Now, suppose we wish to change the the boundary conditions or source points? We can do it easily without regenerating the cache and system, simply by redefining our bc and forcing model functions. For example, to create an internal solution, with surface data equal to the y coordinate, and four sources inside.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"get_fbplus(base_cache,phys_params) = zeros_surface(base_cache)\nget_fbminus(base_cache,phys_params) = points(base_cache).v\n\nfunction my_point_positions(state,t,fr::PointRegionCache,phys_params)\n    x = [-0.2,0.2,-0.2,0.2]\n    y = [0.2,0.2,-0.2,-0.2]\n    return x, y\nend\nfunction my_point_strengths!(σ,state,t,fr::PointRegionCache,phys_params)\n    σ .= [-1.0,1.0,-1.0,1.0]\nend","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"We can solve immediately without having to reconstruct the system, so it's very fast.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"@time f, s = solve(prob,sys)\nplot(f,sys)","category":"page"},{"location":"manual/problems/#Problem-types-and-functions","page":"Problems and the system","title":"Problem types and functions","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"AbstractScalarILMProblem\nAbstractVectorILMProblem\n@ilmproblem\nBasicScalarILMProblem\nBasicVectorILMProblem\nprob_cache","category":"page"},{"location":"manual/problems/#ImmersedLayers.AbstractScalarILMProblem","page":"Problems and the system","title":"ImmersedLayers.AbstractScalarILMProblem","text":"abstract type AbstractScalarILMProblem{DT, ST, DTP} <: ImmersedLayers.AbstractILMProblem{DT, ST, DTP}\n\nWhen defining a problem type with scalar data, make it a subtype of this.\n\n\n\n\n\n","category":"type"},{"location":"manual/problems/#ImmersedLayers.AbstractVectorILMProblem","page":"Problems and the system","title":"ImmersedLayers.AbstractVectorILMProblem","text":"abstract type AbstractVectorILMProblem{DT, ST, DTP} <: ImmersedLayers.AbstractILMProblem{DT, ST, DTP}\n\nWhen defining a problem type with vector data, make it a subtype of this.\n\n\n\n\n\n","category":"type"},{"location":"manual/problems/#ImmersedLayers.@ilmproblem","page":"Problems and the system","title":"ImmersedLayers.@ilmproblem","text":"The @ilmproblem macro is used to automatically generate a type particular to an immersed-layer problem, which can then be used for dispatch on those types of problems. It takes two arguments: the name of the problem (to which Problem will be automatically appended), and whether the problem is of scalar or vector type. For example,\n\n@ilmproblem(StokesFlow,vector)\n\nwould generate a type StokesFlowProblem dealing with vector-valued data. The resulting type then automatically has a constructor that allows one to pass in the grid information and bodies, as well as optional choices for the DDF function and the scaling type. For the example, this constructor would be\n\nStokesFlowProblem(grid,bodies[,ddftype=CartesianGrids.Yang3][,scaling=GridScaling])\n\nNote that there is another constructor for problems with no surfaces that only requires that the grid information be passed, e.g.,\n\nStokesFlowProblem(grid)\n\nThere are several keyword arguments for the problem constructor\n\nddftype = to set the DDF type. The default is Yang3.\nscaling = to set the scaling type, GridScaling (default) or IndexScaling.\ndtype = to set the element type to Float64 (default) or ComplexF64.\nphys_params = to pass in physical parameters\nbc = to pass in boundary condition data or functions\nforcing = to pass in forcing functions or data\nmotions = to provide function(s) that specify the velocity of the immersed surface(s). Note: if this keyword is used, it is assumed that surfaces will move.\ntimestep_func = to pass in a function for time-dependent problems that provides the time-step size.                 It is expected that this function takes in two arguments,                 the grid::PhysicalGrid and phys_params, and returns the time step. It is up to the                 user to decide how to determine this. It could also simply return a                 constant value, regardless of the arguments.\n\n\n\n\n\n","category":"macro"},{"location":"manual/problems/#ImmersedLayers.BasicScalarILMProblem","page":"Problems and the system","title":"ImmersedLayers.BasicScalarILMProblem","text":"BasicScalarILMProblem\n\nILM problem type dealing with scalar-type data.\n\n\n\n\n\n","category":"type"},{"location":"manual/problems/#ImmersedLayers.BasicVectorILMProblem","page":"Problems and the system","title":"ImmersedLayers.BasicVectorILMProblem","text":"BasicVectorILMProblem\n\nILM problem type dealing with vector-type data.\n\n\n\n\n\n","category":"type"},{"location":"manual/problems/#ImmersedLayers.prob_cache","page":"Problems and the system","title":"ImmersedLayers.prob_cache","text":"prob_cache(prob,base_cache::BasicILMCache)\n\nThis function is called by __init to generate a problem-specific extra cache. Extend this function in order to generate an extra cache for a user-defined problem type. The user must define the cache type itself.\n\n\n\n\n\n","category":"function"},{"location":"manual/problems/#System-types-and-functions","page":"Problems and the system","title":"System types and functions","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"ILMSystem\nconstruct_system\nupdate_system\nupdate_system!","category":"page"},{"location":"manual/problems/#ImmersedLayers.ILMSystem","page":"Problems and the system","title":"ImmersedLayers.ILMSystem","text":"mutable struct ILMSystem{static, PT, N, PHT, BCF, FF, DTF, MTF, BCT, ECT}\n\nA system of operators and caches for immersed layer problems. This is constructed by construct_system\n\n\n\n\n\n","category":"type"},{"location":"manual/problems/#ImmersedLayers.construct_system","page":"Problems and the system","title":"ImmersedLayers.construct_system","text":"construct_system(prob::AbstractILMProblem) -> ILMSystem\n\nReturn a system of type of type ILMSystem from the given problem instance prob.\n\n\n\n\n\n","category":"function"},{"location":"manual/problems/#ImmersedLayers.update_system","page":"Problems and the system","title":"ImmersedLayers.update_system","text":"update_system(sysold::ILMSystem,body::Body/BodyList)\n\nFrom an existing system sysold, return a new system based on the Body or BodyList body.\n\n\n\n\n\n","category":"function"},{"location":"manual/problems/#ImmersedLayers.update_system!","page":"Problems and the system","title":"ImmersedLayers.update_system!","text":"update_system!(sys::ILMSystem,u,sysold,t)\n\nFrom an existing system sysold at time t, return a new system sys in place, based on the solution vector u, whose body state information will be used to replace the body information and subsequent operators in sysold.\n\n\n\n\n\n","category":"function"},{"location":"manual/problems/#Forcing-functions","page":"Problems and the system","title":"Forcing functions","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"AreaForcingModel\nLineForcingModel\nPointForcingModel\nAreaRegionCache\nLineRegionCache\nPointRegionCache\nForcingModelAndRegion\narcs(::LineRegionCache)\nmask(::AreaRegionCache)\npoints(::PointRegionCache)\napply_forcing!","category":"page"},{"location":"manual/problems/#ImmersedLayers.AreaForcingModel","page":"Problems and the system","title":"ImmersedLayers.AreaForcingModel","text":"  AreaForcingModel(shape::Union{Body,BodyList},model_function!)\n\nBundles a shape (i.e., a Body, BodyList,) and a model_function! (a function   that returns the strength of the forcing) for area-type forcing.   model_function! must be in-place with a signature of the form\n\n  model_function!(str,state,t,fcache,phys_params)\n\nwhere str is the strength to be returned, state the state vector,   t is time, fcache is a corresponding AreaRegionCache   and phys_params are user-supplied physical parameters. Any of these can   be utilized to compute the strength.\n\nThere are a number of keyword arguments that can be passed in:   ddftype =,specifying the type of DDF; spatialfield = to provide   an AbstractSpatialField to help in evaluating the strength.   (The resulting field is available to model_function! in the generated_field field     of fcache.)\n\n\n\n\n\nAreaForcingModel(model_function!)\n\nCreates area-type forcing over the entire domain, using a model_function! (a function   that returns the strength of the forcing).\n\nmodel_function! must be in-place with a signature of the form\n\n  model_function!(str,state,t,fcache,phys_params)\n\nwhere str is the strength to be returned, state the state vector,   t is time, fcache is a corresponding AreaRegionCache   and phys_params are user-supplied physical parameters. Any of these can   be utilized to compute the strength.\n\nThe keyword spatialfield = can provide   an AbstractSpatialField to help in evaluating the strength.   (The resulting field is available to model_function! in the generated_field field     of fcache.)\n\n\n\n\n\n","category":"type"},{"location":"manual/problems/#ImmersedLayers.LineForcingModel","page":"Problems and the system","title":"ImmersedLayers.LineForcingModel","text":"  LineForcingModel(shape::Union{Body,BodyList},model_function!)\n\nBundles a shape (i.e., a Body, BodyList,) and a model_function! (a function   that returns the strength of the forcing) for line-type forcing.   model_function! must be in-place with a signature of the form\n\n  model_function!(str,state,t,fcache,phys_params)\n\nwhere str is the strength to be returned, state the state vector,   t is time, fcache is a corresponding LineRegionCache   and phys_params are user-supplied physical parameters. Any of these can   be utilized to compute the strength.\n\nThe keyword ddftype = can be used to specify the type of DDF.\n\n\n\n\n\n","category":"type"},{"location":"manual/problems/#ImmersedLayers.PointForcingModel","page":"Problems and the system","title":"ImmersedLayers.PointForcingModel","text":"  PointForcingModel(pts::VectorData,model_function!)\n\nBundles point coordinates pts and a model_function! (a function   that returns the strength of the forcing) for point-type forcing.   model_function! must be in-place with a signature of the form\n\n  model_function!(str,state,t,fcache,phys_params)\n\nwhere str is the strength to be returned, state the state vector,   t is time, fcache is a corresponding PointRegionCache   and phys_params are user-supplied physical parameters. Any of these can   be utilized to compute the strength.\n\nThe keyword ddftype = can be used to specify the type of DDF.\n\n\n\n\n\nPointForcingModel(point_function::Function,model_function!::Function)\n\nBundles a point_function (a function that returns the positions of forcing points) and a model_function (a function that returns the strength of the forcing) for point-type forcing.\n\npoint_function must have an out-of-place signature of the form\n\n  point_function(state,t,fcache,phys_params)\n\nwhere state the state vector, t is time, fcache is a corresponding PointRegionCache   and phys_params are user-supplied physical parameters. Any of these can   be utilized to compute the positions. It must return either a vector for   each coordinate or VectorData.\n\nmodel_function! must have an in-place signature of the form\n\n  model_function!(str,state,t,fcache,phys_params)\n\nwhere str is the strength to be returned.\n\n\n\n\n\n","category":"type"},{"location":"manual/problems/#ImmersedLayers.AreaRegionCache","page":"Problems and the system","title":"ImmersedLayers.AreaRegionCache","text":"AreaRegionCache(shape::Body/BodyList,cache::BasicILMCache)\n\nCreate an area region (basically, a mask) of the shape(s) shape, using the data in cache to provide the details of the grid and regularization.\n\n\n\n\n\nAreaRegionCache(cache::BasicILMCache)\n\nCreate an area region that spans the entire domain, using the data in cache to provide the grid details.\n\n\n\n\n\n","category":"type"},{"location":"manual/problems/#ImmersedLayers.LineRegionCache","page":"Problems and the system","title":"ImmersedLayers.LineRegionCache","text":"LineRegionCache(shape::Body/BodyList,cache::BasicILMCache)\n\nCreate a line region of the shape(s) shape, using the data in cache to provide the details of the regularization.\n\n\n\n\n\n","category":"type"},{"location":"manual/problems/#ImmersedLayers.PointRegionCache","page":"Problems and the system","title":"ImmersedLayers.PointRegionCache","text":"PointRegionCache(pts::VectorData,cache::BasicILMCache[,kwargs])\n\nCreate a regularized point collection based on points pts, using the data in cache to provide the details of the regularization. The kwargs can be used to override the regularization choices, such as ddf.\n\n\n\n\n\n","category":"type"},{"location":"manual/problems/#ImmersedLayers.ForcingModelAndRegion","page":"Problems and the system","title":"ImmersedLayers.ForcingModelAndRegion","text":"ForcingModelAndRegion\n\nA type that holds the forcing model function, region, and cache\n\nConstructors\n\nForcingModelAndRegion(model::AbstractForcingModel,cache::BasicILMCache)\n\nForcingModelAndRegion(modellist::Vector{AbstractForcingModel},cache::BasicILMCache)\n\nThese forms gets called generally when building the extra cache. They also gracefully generate an empty list of models if one passes along nothing in the first argument.\n\n\n\n\n\n","category":"type"},{"location":"manual/problems/#ImmersedLayers.arcs-Tuple{LineRegionCache}","page":"Problems and the system","title":"ImmersedLayers.arcs","text":"arcs(lr::LineRegionCache)\n\nReturn the vector of arc length coordinates for the given line region lr.\n\n\n\n\n\n","category":"method"},{"location":"manual/problems/#ImmersedLayers.mask-Tuple{AreaRegionCache}","page":"Problems and the system","title":"ImmersedLayers.mask","text":"mask(ar::AreaRegionCache)\n\nReturn the mask for the given area region ar.\n\n\n\n\n\n","category":"method"},{"location":"manual/problems/#ImmersedLayers.points-Tuple{PointRegionCache}","page":"Problems and the system","title":"ImmersedLayers.points","text":"points(pr::PointRegionCache)\n\nReturn the vector of coordinates of points associated with pr.\n\n\n\n\n\n","category":"method"},{"location":"manual/problems/#ImmersedLayers.apply_forcing!","page":"Problems and the system","title":"ImmersedLayers.apply_forcing!","text":"apply_forcing!(out,x,t,fv::Vector{ForcingModelAndRegion},phys_params)\n\nReturn the total contribution of forcing in the vector fv to out, based on the current state x, time t, and physical parameters in phys_params. Note that out is zeroed before the contributions are added.\n\n\n\n\n\napply_forcing!(dx,x,t,f::ForcingModelAndRegion,phys_params)\n\nReturn the contribution of forcing in f to the right-hand side dx based on the current state x, time t, and physical parameters in phys_params.\n\n\n\n\n\n","category":"function"},{"location":"manual/problems/#Output-functions-and-macros","page":"Problems and the system","title":"Output functions and macros","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"@snapshotoutput\n@scalarsurfacemetric\n@vectorsurfacemetric\nsurfaces","category":"page"},{"location":"manual/problems/#ImmersedLayers.@snapshotoutput","page":"Problems and the system","title":"ImmersedLayers.@snapshotoutput","text":"@snapshotoutput(name)\n\nA function that returns some instantaneous output about a time-varying solution should have the signature name(state,constraint,sys::ILMSystem,t[,kwargs...]), where state is a solution vector (of the same type as returned by state(zeros_sol(sys))), constraint is of the same type as returned by constraint(zeros_sol(sys))), sys is the system struct, t is time, and kwargs are any additional keyword arguments. This macro extends that function so that it will also operate on the integrator e.g, name(integrator), and the solution history array sol, e.g., name(sol::ODESolution,sys,t), using interpolation for values of t that are not explicitly in the solution array. It can also take a range of values of t, e.g, name(sol::ODESolution,sys,0.1:0.01:0.2).\n\n\n\n\n\n","category":"macro"},{"location":"manual/problems/#ImmersedLayers.@scalarsurfacemetric","page":"Problems and the system","title":"ImmersedLayers.@scalarsurfacemetric","text":"@scalarsurfacemetric(name)\n\nA function that returns a time-varying scalar surface metric should have the signature name(state,constraint,sys::ILMSystem,t,bodyid,[,kwargs...]), where state is a solution vector (of the same type as returned by state(zeros_sol(sys))), constraint is of the same type as returned by constraint(zeros_sol(sys))), sys is the system struct, t is time, bodyid is the body ID, and kwargs are any additional keyword arguments. This macro extends that function so that it will also operate on the integrator e.g, name(integrator,bodyid), and the solution history array sol, e.g., name(sol::ODESolution,sys,t,bodyid), using interpolation for values of t that are not explicitly in the solution array. It can also take a range of values of t, e.g, name(sol::ODESolution,sys,0.1:0.01:0.2,bodyid). And finally, it can simply take name(sol::ODESolution,sys,bodyid) to return the entire history.\n\n\n\n\n\n","category":"macro"},{"location":"manual/problems/#ImmersedLayers.@vectorsurfacemetric","page":"Problems and the system","title":"ImmersedLayers.@vectorsurfacemetric","text":"@vectorsurfacemetric(name)\n\nA function that returns a time-varying scalar surface metric should have the signature name(state,constraint,sys::ILMSystem,t,bodyid,[,kwargs...]), where state is a solution vector (of the same type as returned by state(zeros_sol(sys))), constraint is of the same type as returned by constraint(zeros_sol(sys))), sys is the system struct, t is time, bodyid is the body ID, and kwargs are any additional keyword arguments. This macro extends that function so that it will also operate on the integrator e.g, name(integrator,bodyid), and the solution history array sol, e.g., name(sol::ODESolution,sys,t,bodyid), using interpolation for values of t that are not explicitly in the solution array. It can also take a range of values of t, e.g, name(sol::ODESolution,sys,0.1:0.01:0.2,bodyid). And finally, it can simply take name(sol::ODESolution,sys,bodyid) to return the entire history.\n\n\n\n\n\n","category":"macro"},{"location":"manual/problems/#ImmersedLayers.surfaces","page":"Problems and the system","title":"ImmersedLayers.surfaces","text":"surfaces(u::ConstrainedSystems.ArrayPartition,sys::ILMSystem,t) -> BodyList\n\nReturn the list of surfaces (as a BodyList) in the solution vector u. If the surfaces are stationary, then this simply returns them from sys and ignores the time argument.\n\n\n\n\n\nsurfaces(sys::ILMSystem) -> BodyList\n\nReturn the list of surfaces (as a BodyList) in the system sys.\n\n\n\n\n\nsurfaces(sol::ODESolution,sys::ILMSystem,t) -> BodyList\n\nReturn the list of surfaces (as a BodyList) at the time t, using the ODE solution array sol. If the surfaces are stationary, then this simply returns them and ignores the time argument.\n\n\n\n\n\nsurfaces(int::ConstrainedSystems.OrdinaryDiffEq.ODEIntegrator) -> BodyList\n\nReturn the list of surfaces (as a BodyList) in the integrator int.\n\n\n\n\n\n","category":"function"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"EditURL = \"<unknown>/literate/matrices.jl\"","category":"page"},{"location":"manual/matrices/#Matrix-operators","page":"Matrix operators","title":"Matrix operators","text":"","category":"section"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"Many solutions of partial differential equations with immersed layers, particularly Poisson problems, lead to saddle-point problems, in which the Schur complement operator is a matrix composed from some of the surface-grid operators discussed in Surface-grid operations. The package provides some convenience tools for constructing these matrices. By their nature, the construction of these matrices is slow, since each column involves the application of the same set of operations. However, the point of this construction is to do it once and store it for repeated application.","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"One common saddle point system is","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"A = beginbmatrix L  R  R^T  0 endbmatrix","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"where L is the discrete Laplacian and R and R^T are the regularization and interpolation operators (regularize! and interpolate!), respectively. This system arises in the solution of the Poisson equation with Dirichlet boundary conditions on the immersed surface. The Schur complement of this is S = - R^T L^-1 R. This matrix can be obtained using the function create_RTLinvR.","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"Another common saddle point system is","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"A = beginbmatrix L  D_s  G_s  R_n^T R_n endbmatrix","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"where D_s and G_s are the surface divergence and gradient operators (surface_divergence! and surface_grad!), respectively, and R_n and R_n^T are regularize_normal! and normal_interpolate!. This system arises in the solution of the Poisson equation with Neumann boundary conditions on the immersed surface. The Schur complement of this is S = R_n^T R_n - G_s L^-1 D_s. Each of the matrices in this are individually provided by the package, by the functions create_nRTRn and create_GLinvD, respectively. However, it is useful to know that the sum of these two matrices is exactly the matrix -C_s L^-1C_s^T, where C_s and C_s^T are surface curl operators surface_curl!. This complete matrix is provided by create_CLinvCT.","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"Another helpful matrix operator is the surface filter, given by","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"tildeR^T R","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"where tildeR^T is a modified form of the interpolation operator, designed to return the regularized field to the surface points while maintaining the integral value of the original field [1]. We can obtain this matrix with create_surface_filter.","category":"page"},{"location":"manual/matrices/#Matrix-construction-functions","page":"Matrix operators","title":"Matrix construction functions","text":"","category":"section"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"create_RTLinvR\ncreate_CLinvCT\ncreate_CLinvCT_scalar\ncreate_CL2invCT\ncreate_GLinvD\ncreate_GLinvD_cross\ncreate_nRTRn\ncreate_surface_filter","category":"page"},{"location":"manual/matrices/#ImmersedLayers.create_RTLinvR","page":"Matrix operators","title":"ImmersedLayers.create_RTLinvR","text":"create_RTLinvR(cache::BasicILMCache[;scale=1.0])\n\nUsing the provided cache cache, construct the square matrix -R^T L^-1R, which maps data of type ScalarData to data of the same type. The operators R^T and R correspond to interpolate! and regularize! and L^{-1} is the inverse of the grid Laplacian. The optional keyword scale multiplies the matrix by the designated value.\n\n\n\n\n\n","category":"function"},{"location":"manual/matrices/#ImmersedLayers.create_CLinvCT","page":"Matrix operators","title":"ImmersedLayers.create_CLinvCT","text":"create_CLinvCT(cache::BasicILMCache[;scale=1.0])\n\nUsing the provided cache cache, construct the square matrix -C_s L^-1C_s^T, which maps data of the primary point data type of the cache to data of the same type. The operators C_s and C_s^T correspond to surface_curl! and L is the grid Laplacian. The optional keyword scale multiplies the matrix by the designated value.\n\n\n\n\n\n","category":"function"},{"location":"manual/matrices/#ImmersedLayers.create_CLinvCT_scalar","page":"Matrix operators","title":"ImmersedLayers.create_CLinvCT_scalar","text":"create_CLinvCT_scalar(cache::BasicILMCache[;scale=1.0])\n\nUsing the provided cache cache, construct the square matrix -C_s L^-1C_s^T, which maps data of the scalar point data type of the cache to data of the same type. The operators C_s and C_s^T correspond to surface_curl! and L is the grid Laplacian. The optional keyword scale multiplies the matrix by the designated value.\n\n\n\n\n\n","category":"function"},{"location":"manual/matrices/#ImmersedLayers.create_CL2invCT","page":"Matrix operators","title":"ImmersedLayers.create_CL2invCT","text":"create_CL2invCT(cache::BasicILMCache[;scale=1.0])\n\nUsing the provided cache cache, construct the square matrix -C_s L^-2 C_s^T, which maps data of the primary point data type of the cache to data of the same type. The operators C_s and C_s^T correspond to surface_curl! and L is the grid Laplacian. The optional keyword scale multiplies the matrix by the designated value.\n\n\n\n\n\n","category":"function"},{"location":"manual/matrices/#ImmersedLayers.create_GLinvD","page":"Matrix operators","title":"ImmersedLayers.create_GLinvD","text":"create_GLinvD(cache::BasicILMCache[;scale=1.0])\n\nUsing the provided cache cache, construct the square matrix -G_s L^-1D_s, which maps data of type ScalarData to data of the same type. The operators G_s and D_s correspond to surface_grad! and surface_divergence!, and L is the grid Laplacian. The optional keyword scale multiplies the matrix by the designated value.\n\n\n\n\n\n","category":"function"},{"location":"manual/matrices/#ImmersedLayers.create_GLinvD_cross","page":"Matrix operators","title":"ImmersedLayers.create_GLinvD_cross","text":"create_GLinvD_cross(cache::BasicILMCache[;scale=1.0])\n\nUsing the provided cache cache, construct the square matrix -hatG_s L^-1hatD_s, which maps data of type ScalarData to data of the same type. The operators G_s and D_s correspond to surface_grad_cross! and surface_divergence_cross!, and L is the grid Laplacian. The optional keyword scale multiplies the matrix by the designated value.\n\n\n\n\n\n","category":"function"},{"location":"manual/matrices/#ImmersedLayers.create_nRTRn","page":"Matrix operators","title":"ImmersedLayers.create_nRTRn","text":"create_nRTRn(cache::BasicILMCache[;scale=1.0])\n\nUsing the provided cache cache, construct the square matrix ncdot R_f^T R_f n circ, which maps data of type ScalarData to data of the same type. The operators R_f^T and R_f correspond to the interpolation and regularization matrices. The optional keyword scale multiplies the matrix by the designated value.\n\n\n\n\n\n","category":"function"},{"location":"manual/matrices/#ImmersedLayers.create_surface_filter","page":"Matrix operators","title":"ImmersedLayers.create_surface_filter","text":"create_surface_filter(cache::BasicILMCache)\n\nCreate a surface filtering matrix operator tildeR^T R, where tildeR^T represents a modified version of the interpolation operator. The resulting matrix can be applied to surface data to filter out high-frequency components.\n\n\n\n\n\n","category":"function"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"[1]: Goza, A., et al., (2016) \"Accurate computation of surface stresses and forces with immersed boundary methods,\" J. Comput. Phys., 321, 860–873.","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"EditURL = \"<unknown>/literate/gridops.jl\"","category":"page"},{"location":"manual/gridops/#Grid-operations","page":"Grid operations","title":"Grid operations","text":"","category":"section"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/gridops/#Basic-differential-operations","page":"Grid operations","title":"Basic differential operations","text":"","category":"section"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"There are a variety of (purely) grid-based operators that are useful for carrying out calculations in immersed layer problems. We will demonstrate a few of them here. We will start by generating the cache, just as we did in Immersed layer caches","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"using ImmersedLayers\nusing CartesianGrids\nusing Plots","category":"page"},{"location":"manual/gridops/#Set-up-a-grid-and-cache","page":"Grid operations","title":"Set up a grid and cache","text":"","category":"section"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"Δx = 0.01\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx)","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"We still generate a cache for these operations, but now, we only supply the grid. There are no immersed surfaces for this demonstration.","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"cache = SurfaceScalarCache(g,scaling=GridScaling)","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"To demonstrate, let's generate a Gaussian","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"p = zeros_grid(cache)\nxg, yg = x_grid(cache), y_grid(cache)\np .= exp.(-(xg∘xg)-(yg∘yg))","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"Now, let's generate the gradient of these data","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"v = zeros_gridgrad(cache)\ngrad!(v,p,cache)\nplot(v,cache)","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"We can then compute the derivative of this data","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"divv = zeros_grid(cache)\ndivergence!(divv,v,cache)\nplot(divv,cache)","category":"page"},{"location":"manual/gridops/#Convective-derivatives","page":"Grid operations","title":"Convective derivatives","text":"","category":"section"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"And finally, let's compute convective derivatives. First, we will compute","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"mathbfvcdotnabla p","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"For this operation, we create a special additional cache using ConvectiveDerivativeCache. This extra cache holds additional memory for making the calculation of the convective derivative faster if we compute it often.","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"cdcache = ConvectiveDerivativeCache(cache)\nvdp = zeros_grid(cache)\nconvective_derivative!(vdp,v,p,cache,cdcache) #hide\n@time convective_derivative!(vdp,v,p,cache,cdcache)\nnothing #hide","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"Plot it","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"plot(vdp,cache)","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"Now, let's compute","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"mathbfvcdotnablamathbfv","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"For this, we create a cache for VectorGridData, and a new instance of ConvectiveDerivativeCache to go along with it.","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"vcache = SurfaceVectorCache(g,scaling=GridScaling)\nvdv = zeros_grid(vcache)\ncdvcache = ConvectiveDerivativeCache(vcache)\nconvective_derivative!(vdv,v,vcache,cdvcache) #hide\n@time convective_derivative!(vdv,v,vcache,cdvcache)\nnothing #hide","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"Plot it","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"plot(vdv,vcache)","category":"page"},{"location":"manual/gridops/#Grid-operator-functions","page":"Grid operations","title":"Grid operator functions","text":"","category":"section"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"divergence!\ngrad!\ncurl!\nconvective_derivative!\nconvective_derivative\nConvectiveDerivativeCache\nlaplacian!\ninverse_laplacian!","category":"page"},{"location":"manual/gridops/#CartesianGrids.divergence!","page":"Grid operations","title":"CartesianGrids.divergence!","text":"divergence!(p::Nodes{Primal/Dual},v::Edges{Primal/Dual},cache::BasicILMCache)\ndivergence!(p::Nodes{Primal/Dual},v::Edges{Primal/Dual},sys::ILMSystem)\n\nCompute the discrete divergence of v and return it in p, scaling it by the grid spacing if cache (or sys) is of GridScaling type, or leaving it as a simple differencing if cache (or sys) is of IndexScaling type.\n\n\n\n\n\n","category":"function"},{"location":"manual/gridops/#CartesianGrids.grad!","page":"Grid operations","title":"CartesianGrids.grad!","text":"grad!(v::Edges{Primal/Dual},p::Nodes{Primal/Dual},cache::BasicILMCache)\ngrad!(v::Edges{Primal/Dual},p::Nodes{Primal/Dual},sys::ILMSystem)\n\nCompute the discrete gradient of p and return it in v, scaling it by the grid spacing if cache (or sys) is of GridScaling type, or leaving it as a simple differencing if cache (or sys) is of IndexScaling type.\n\n\n\n\n\n","category":"function"},{"location":"manual/gridops/#CartesianGrids.curl!","page":"Grid operations","title":"CartesianGrids.curl!","text":"curl!(v::Edges{Primal},s::Nodes{Dual},cache::BasicILMCache)\ncurl!(v::Edges{Primal},s::Nodes{Dual},sys::ILMSystem)\n\nCompute the discrete curl of s and return it in v, scaling it by the grid spacing if cache (or sys) is of GridScaling type, or leaving it as a simple differencing if cache (or sys) is of IndexScaling type.\n\n\n\n\n\ncurl!(w::Nodes{Dual},v::Edges{Primal},cache::BasicILMCache)\ncurl!(w::Nodes{Dual},v::Edges{Primal},sys::ILMSystem)\n\nCompute the discrete curl of v and return it in w, scaling it by the grid spacing if cache (or sys) is of GridScaling type, or leaving it as a simple differencing if cache (or sys) is of IndexScaling type.\n\n\n\n\n\n","category":"function"},{"location":"manual/gridops/#CartesianGrids.convective_derivative!","page":"Grid operations","title":"CartesianGrids.convective_derivative!","text":"convective_derivative!(vdp::Nodes{Primal},v::Edges,p::Nodes{Primal},base_cache::BasicILMCache,extra_cache::ConvectiveDerivativeCache)\n\nCompute the convective derivative of p with velocity v, i.e., vcdot nabla p, and return the result in vdp. The result is either divided by unity or the grid cell size depending on whether base_cache is of type IndexScaling or GridScaling. This version of the method uses extra_cache of type ConvectiveDerivativeCache.\n\n\n\n\n\nconvective_derivative!(vdw::Nodes{Dual},v::Edges,w::Nodes{Dual},base_cache::BasicILMCache,extra_cache::ConvectiveDerivativeCache)\n\nCompute the convective derivative of w with velocity v, i.e., vcdot nabla w, and return the result in vdw. The result is either divided by unity or the grid cell size depending on whether base_cache is of type IndexScaling or GridScaling. This version of the method uses extra_cache of type ConvectiveDerivativeCache.\n\n\n\n\n\nconvective_derivative!(vdu::Edges,v::Edges,u::Edges,base_cache::BasicILMCache,extra_cache::ConvectiveDerivativeCache)\n\nCompute the convective derivative of u, i.e., vcdot nabla u, and return the result in vdu. The result is either divided by unity or the grid cell size depending on whether base_cache is of type IndexScaling or GridScaling. This version of the method uses extra_cache of type ConvectiveDerivativeCache.\n\n\n\n\n\nconvective_derivative!(vdv::Edges,v::Edges,base_cache::BasicILMCache,extra_cache::ConvectiveDerivativeCache)\n\nCompute the convective derivative of v, i.e., vcdot nabla v, and return the result in vdv. The result is either divided by unity or the grid cell size depending on whether base_cache is of type IndexScaling or GridScaling. This version of the method uses extra_cache of type ConvectiveDerivativeCache.\n\n\n\n\n\n","category":"function"},{"location":"manual/gridops/#ImmersedLayers.convective_derivative","page":"Grid operations","title":"ImmersedLayers.convective_derivative","text":"convective_derivative(v::Edges{Primal},p::Nodes{Primal},base_cache::BasicILMCache)\n\nCompute the convective derivative of p with velocity v, i.e., vcdot nabla p. The result is either divided by unity or the grid cell size depending on whether base_cache is of type IndexScaling or GridScaling.\n\n\n\n\n\nconvective_derivative(v::Edges{Dual},w::Nodes{Dual},base_cache::BasicILMCache)\n\nCompute the convective derivative of w with velocity v, i.e., vcdot nabla w. The result is either divided by unity or the grid cell size depending on whether base_cache is of type IndexScaling or GridScaling.\n\n\n\n\n\nconvective_derivative(v::Edges,base_cache::BasicILMCache)\n\nCompute the convective derivative of v, i.e., vcdot nabla v. The result is either divided by unity or the grid cell size depending on whether base_cache is of type IndexScaling or GridScaling.\n\n\n\n\n\n","category":"function"},{"location":"manual/gridops/#ImmersedLayers.ConvectiveDerivativeCache","page":"Grid operations","title":"ImmersedLayers.ConvectiveDerivativeCache","text":"ConvectiveDerivativeCache(dv::EdgeGradient)\n\nCreate a cache (a subtype of AbstractExtraILMCache) for computing the convective derivative, using dv to define the cache data.\n\n\n\n\n\n","category":"type"},{"location":"manual/gridops/#ImmersedLayers.laplacian!","page":"Grid operations","title":"ImmersedLayers.laplacian!","text":"laplacian!(w::GridData,s::GridData,sys::ILMSystem)\n\nCompute the Laplacian of grid data s, and divide the result by unity or by the grid cell size, depending on whether sys has IndexScaling or GridScaling, respectively, and return the result as w.\n\n\n\n\n\nlaplacian!(w::GridData,s::GridData,cache::BasicILMCache)\n\nCompute the Laplacian of grid data s, and divide the result by unity or by the grid cell size, depending on whether cache has IndexScaling or GridScaling, respectively, and return the result as w.\n\n\n\n\n\n","category":"function"},{"location":"manual/gridops/#ImmersedLayers.inverse_laplacian!","page":"Grid operations","title":"ImmersedLayers.inverse_laplacian!","text":"inverse_laplacian!(w::GridData,sys::ILMSystem)\n\nCompute the in-place inverse Laplacian of grid data w, and multiply the result by unity or by the grid cell size, depending on whether sys has IndexScaling or GridScaling, respectively.\n\n\n\n\n\ninverse_laplacian!(w::GridData,cache::BasicILMCache)\n\nCompute the in-place inverse Laplacian of grid data w, and multiply the result by unity or by the grid cell size, depending on whether cache has IndexScaling or GridScaling, respectively.\n\n\n\n\n\ninverse_laplacian!(sol::GridData,rhs::GridData,cache::BasicILMCache)\n\nCompute the iinverse Laplacian of grid data rhs, multiply the result by unity or by the grid cell size, depending on whether cache has IndexScaling or GridScaling, respectively, and return the result as sol.\n\n\n\n\n\n","category":"function"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"EditURL = \"<unknown>/literate/heatconduction-unbounded.jl\"","category":"page"},{"location":"manual/heatconduction-unbounded/#A-time-varying-PDE-with-forcing","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"","category":"section"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"In a previous example of the Poisson equation we demonstrated the use of point forcing. In this example we will explore other ways to apply forcing to a PDE. Our target problem will be similar to the most recent example – transient heat conduction – but now it will be in an unbounded domain. Our forcing will comprise local area heating and line heating. We will also include convection by an externally-imposed velocity field.","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"The governing equations are","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"dfracpartial Tpartial t + mathbfvcdotnabla T = kappa nabla^2 T + q","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"where mathbfv is a known convection velocity field and q is a known heating field (scaled by the density and specific heat)","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"In our discrete formulation, the problem takes the form","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"mathcalL_C^kappa T = -N(mathbfvT) + q","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"where N is a discrete approximation for the convection term mathbfvcdotnabla T, and mathcalL_C^kappa = mathrmdmathrmdt - kappa L_C is the same diffusion operator as in the previous example. Note that these equations are no longer constrained. We only need to supply the right-hand side function. Our job here is to provide everything needed to compute this right-hand side.","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"We will apply the heating and cooling inside of local regions. As we discussed before, for each forcing, we supply information about the shape of the forcing region and the model function, supplying the forcing strength whenever we need it. We package these together into a forcing model and provide it to the problem via the forcing keyword.","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"The convection velocity also must be provided. We also make use of the forcing keyword to supply this to the problem, as well, in the form of a function that returns the current convection velocity at a given time t. The convective derivative term N requires a special cache, which we also generate in the prob_cache.","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"We will highlight these aspects in the example that follows. In this example, we will create","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"a square-shaped line forcing region that delivers a certain amount of heat per unit length of line\na circular-shaped area forcing region that supplies heat based on the heat-transfer model hcdot(T_0cos(2pi f t)-T), where h is the heat transfer coefficient, T is the current local temperature,","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"and T_0 is the amplitude of an oscillatory heater temperature, oscillating at frequency f","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"a background rotational velocity field, with angular velocity Omega.","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"using ImmersedLayers\nusing Plots\nusing UnPack","category":"page"},{"location":"manual/heatconduction-unbounded/#Set-up-the-grid","page":"A time-varying PDE with forcing","title":"Set up the grid","text":"","category":"section"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"Let's set up the grid first before we go any further","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"Δx = 0.01\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx);\nnothing #hide","category":"page"},{"location":"manual/heatconduction-unbounded/#Specify-the-physical-parameters","page":"A time-varying PDE with forcing","title":"Specify the physical parameters","text":"","category":"section"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"We supply here the diffusivity (kappa) and the uniform convection velocity. We also supply the grid Fourier number and a CFL number, which we will make use of later to calculate the time step size.","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"phys_params = Dict(\"diffusivity\" => 0.005,\n                    \"angular velocity\" => 0.5,\n                    \"length scale\" => Lx/2,\n                     \"Fourier\" => 1.0,\n                     \"CFL\" => 0.5,\n                     \"lineheater_flux\" => -2.0,\n                     \"areaheater_freq\" => 1.0,\n                     \"areaheater_temp\" => 2.0,\n                     \"areaheater_coeff\" => 100.0\n                     )","category":"page"},{"location":"manual/heatconduction-unbounded/#Specifying-the-forcing-regions-and-models-and-convection-velocity-model","page":"A time-varying PDE with forcing","title":"Specifying the forcing regions and models and convection velocity model","text":"","category":"section"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"We first create the square line heater and place it at (01). Its associated model function is very simple, since it just sets the strength uniformly. But note the function signature, which must always take this form. It can make use of the current temperature, time, and physical parameters, to return the strength of the line forcing. We bundle these together using LineForcingModel.","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"fregion1 = Square(0.5,1.4*Δx)\nT = RigidTransform((0.0,1.0),0.0)\nT(fregion1)\n\nfunction model1!(σ,T,t,fr::LineRegionCache,phys_params)\n    σ .= phys_params[\"lineheater_flux\"]\nend\nlfm = LineForcingModel(fregion1,model1!);\nnothing #hide","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"Now the oscillatory heater, which we place at (0-05). This one has a few more parameters, since we provide the heat transfer coefficient and the amplitude and frequency of the target temperature. These are bundled with AreaForcingModel.","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"fregion2 = Circle(0.2,1.4*Δx)\nT = RigidTransform((0.0,-0.5),0.0)\nT(fregion2)\n\nfunction model2!(σ,T,t,fr::AreaRegionCache,phys_params)\n    f = phys_params[\"areaheater_freq\"]\n    T0 = phys_params[\"areaheater_temp\"]\n    h = phys_params[\"areaheater_coeff\"]\n    σ .= h*(T0*cos(2π*f*t) - T)\nend\nafm = AreaForcingModel(fregion2,model2!);\nnothing #hide","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"Finally, the convection velocity model. Here, we make use of the coordinate function x_gridgrad and y_gridgrad to supply the coordinates of the velocity grid points. Since this is a staggered grid, the velocity components live at different places. For example, yg.u denotes the y coordinates for the horizontal velocity components, and xg.v denotes the x coordinates for the vertical velocity components.","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"function my_velocity!(vel,t,cache,phys_params)\n    xg, yg = x_gridgrad(cache), y_gridgrad(cache)\n    Ω = phys_params[\"angular velocity\"]\n    vel.u .= -Ω*yg.u\n    vel.v .= Ω*xg.v\n    return vel\nend","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"We pack the forcing and convection together into the forcing Dict:","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"forcing_dict = Dict(\"heating models\" => [lfm,afm],\n                    \"convection velocity model\" => my_velocity!)","category":"page"},{"location":"manual/heatconduction-unbounded/#Construct-the-ODE-function-and-the-extra-cache","page":"A time-varying PDE with forcing","title":"Construct the ODE function and the extra cache","text":"","category":"section"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"For the RHS of the heat conduction equation, we calculate the convective derivative and the external heating.","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"function heatconduction_rhs!(dT,T,sys::ILMSystem,t)\n    @unpack forcing, phys_params, extra_cache, base_cache = sys\n    @unpack cdcache, fcache, v, dT_tmp = extra_cache\n\n    # This provides the convection velocity at time `t`\n    forcing[\"convection velocity model\"](v,t,base_cache,phys_params)\n\n    # Compute the convective derivative term `N(v,T)`\n    fill!(dT_tmp,0.0)\n    convective_derivative!(dT_tmp,v,T,base_cache,cdcache)\n    dT .= -dT_tmp\n\n    # Compute the contribution from the forcing models to the right-hand side\n    fill!(dT_tmp,0.0)\n    apply_forcing!(dT_tmp,T,t,fcache,phys_params)\n    dT .+= dT_tmp\n\n    return dT\nend","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"We create a problem type for this, define the extra cache, and extend prob_cache","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"@ilmproblem UnboundedHeatConduction scalar\n\nstruct UnboundedHeatConductionCache{VT,CDT,FRT,DTT,FT} <: AbstractExtraILMCache\n   v :: VT\n   cdcache :: CDT\n   fcache :: FRT\n   dT_tmp :: DTT\n   f :: FT\nend\n\nfunction ImmersedLayers.prob_cache(prob::UnboundedHeatConductionProblem,\n                                   base_cache::BasicILMCache{N,scaling}) where {N,scaling}\n    @unpack phys_params, forcing = prob\n    @unpack gdata_cache, g = base_cache\n\n    # Construct a Lapacian outfitted with the diffusivity\n    κ = phys_params[\"diffusivity\"]\n    heat_L = Laplacian(base_cache,gdata_cache,κ)\n\n    # Create cache for the convective derivative\n    v = zeros_gridgrad(base_cache)\n    cdcache = ConvectiveDerivativeCache(base_cache)\n\n    # Create cache for the forcing regions\n    fcache = ForcingModelAndRegion(forcing[\"heating models\"],base_cache);\n\n    dT_tmp = zeros_grid(base_cache)\n\n    # The state here is temperature, and we just supply the RHS function\n    f = ODEFunctionList(state = zeros_grid(base_cache),\n                        ode_rhs=heatconduction_rhs!,\n                        lin_op=heat_L)\n\n    UnboundedHeatConductionCache(v,cdcache,fcache,dT_tmp,f)\nend","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"The last definition we need is for a timestep function. This time, we take into account both the Fourier and the CFL conditions:","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"function timestep_fourier_cfl(sys)\n    @unpack phys_params = sys\n    g = get_grid(sys)\n    κ = phys_params[\"diffusivity\"]\n    Ω = phys_params[\"angular velocity\"]\n    L = phys_params[\"length scale\"]\n    Fo = phys_params[\"Fourier\"]\n    Co = phys_params[\"CFL\"]\n    Δt = min(Fo*cellsize(g)^2/κ,Co*cellsize(g)/Ω/L)\n    return Δt\nend","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"As in the last example, we also define the temperature output function for output","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"temperature(T,σ,sys::ILMSystem,t) = T\n@snapshotoutput temperature","category":"page"},{"location":"manual/heatconduction-unbounded/#Set-up-the-problem-and-system","page":"A time-varying PDE with forcing","title":"Set up the problem and system","text":"","category":"section"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"This is similar to previous problems.","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"prob = UnboundedHeatConductionProblem(g,scaling=GridScaling,\n                                        phys_params=phys_params,\n                                        forcing=forcing_dict,\n                                        timestep_func=timestep_fourier_cfl)\n\nsys = construct_system(prob);\nnothing #hide","category":"page"},{"location":"manual/heatconduction-unbounded/#Solve-the-problem","page":"A time-varying PDE with forcing","title":"Solve the problem","text":"","category":"section"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"As before, we first initialize the state, then we create an integrator, and finally, advance the solution in time","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"u0 = init_sol(sys)\ntspan = (0.0,2.0)\nintegrator = init(u0,tspan,sys)","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"Run the problem for one time unit","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"step!(integrator,1.0)","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"Let's see what this looks like. We will plot a set of snapshots in an array.","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"sol = integrator.sol\n\nplt = plot(layout = (2,3), size = (700, 500), legend=:false)\nfor (i,t) in enumerate(0:0.2:1.0)\n   plot!(plt[i],temperature(sol,sys,t),sys,levels=range(-10,2,length=30),clim=(-10,2))\nend\nplt","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"","category":"page"},{"location":"manual/heatconduction-unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"EditURL = \"<unknown>/literate/surfaceops.jl\"","category":"page"},{"location":"manual/surfaceops/#Surface-grid-operations","page":"Surface-grid operations","title":"Surface-grid operations","text":"","category":"section"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Here, we will discuss the various surface-grid operators available in the package. We will start by generating the cache, just as we did in Immersed layer caches","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"using ImmersedLayers\nusing Plots\nusing LinearAlgebra","category":"page"},{"location":"manual/surfaceops/#Set-up-the-grid,-shape,-and-cache","page":"Surface-grid operations","title":"Set up the grid, shape, and cache","text":"","category":"section"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"We do this just as we did in Immersed layer caches","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Δx = 0.01\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx)\nRadC = 1.0\nΔs = 1.4*cellsize(g)\nbody = Circle(RadC,Δs)\ncache = SurfaceScalarCache(body,g,scaling=GridScaling)","category":"page"},{"location":"manual/surfaceops/#Basic-regularization-and-interpolation","page":"Surface-grid operations","title":"Basic regularization and interpolation","text":"","category":"section"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Let's perform an example in which we regularize the x coordinate of the surface points onto the grid. We can get the surface coordinates by using the points function. This can be applied either to body directly or to the cache. As for any VectorData type, the components of pts are pts.u and pts.v.","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"pts = points(cache);\nnothing #hide","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Now, we set up some blank grid data on which to regularize onto","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"gx = zeros_grid(cache);\nnothing #hide","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Now regularize. We will time it to show that it is fast and memory-efficient:","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"regularize!(gx,pts.u,cache) #hide\n@time regularize!(gx,pts.u,cache);\nnothing #hide","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Let's plot this to look at it. This also gives us a chance to highlight the plot recipe for grid data associated with the cache, which is achieved by simply supplying the cache to the plot function in Plots.jl. By default, this plots the immersed points, as well, but this can be suppressed by adding the keyword layers=false.","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"plot(gx,cache)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"This shows how the regularization spreads the data over a couple of cells around the surface. In the parlance of potential theory, this is a single layer. If we wish to interpolate, then we do so with the [interpolate!] function. For example, suppose we have a uniform field that we wish to interpolate:","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"oc = 2.5*ones_grid(cache)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Now set up some surface data to receive the interpolated data, and interpolate:","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"f = zeros_surface(cache);\ninterpolate!(f,oc,cache)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"It is clear that the interpolation preserves the value of the field. This is also true for linearly varying fields, since the DDF is built to ensure this. Let's try this, using the x coordinate of the grid. Here, we use the coordinates function of CartesianGrids.jl, which gets the coordinates of the grid, and set the values of grid data to the x coordinate. We interpolate and plot, comparing to the actual x coordinate of the points on the body:","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"xg = x_grid(cache)\ninterpolate!(f,xg,cache)\nplot(f,cache,ylim=(-2,2),label=\"Interpolated from grid\",ylabel=\"x\",xlabel=\"arclength\")\nplot!(pts.u,cache,label=\"Actual body coordinate\",legend=:true)","category":"page"},{"location":"manual/surfaceops/#A-double-layer","page":"Surface-grid operations","title":"A double layer","text":"","category":"section"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Now we will generate a double layer. Mathematically, this takes the form","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"D_s f = nablacdot left( delta(chi) mathbfn f right)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"for some scalar data f on the surface. (See Background for an example.) Notice that it maps scalar data on the surface (f) to scalar data in space. So to calculate this using our discrete tools, we set up some grid data to receive the result. Then, we use the function surface_divergence! to compute the double layer. Here, we will demonstrate this on the y coordinate of the surface points:","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"dl = zeros_grid(cache)\nsurface_divergence!(dl,pts.v,cache)\nplot(dl,cache)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"If the surface data are vectors, mathbff, then this operation is a little different:","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"D_s mathbff = nablacdot leftdelta(chi) left(  mathbfn mathbff + mathbff mathbfn right) right","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"This maps mathbff to a vector field. We use this in conjunction with a cache generated with SurfaceVectorCache.","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"The transpose of the double layer, D_s, is the operation","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"G_s u = mathbfncdot delta^T(chi) nabla u","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"for some scalar field data u. This operation computes the gradient of the field data, interpolates this gradient onto the surface, and obtains the normal component of that surface data. As such, it represents an important tool for computing the normal derivative of field data on a surface. In the package, we use surface_grad! for this operation.","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"The vector field version of this is","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"G_s mathbfu = mathbfncdot delta^T(chi) (nabla mathbfu + nabla^T mathbfu)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"which maps vector field data mathbfu to vector-valued surface data.","category":"page"},{"location":"manual/surfaceops/#A-curl-layer","page":"Surface-grid operations","title":"A curl layer","text":"","category":"section"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"We also sometimes need to take the curl of the regularized surface data,","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"C_s f = nablatimes left( delta(chi) mathbfn f right)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"For this, we use the surface_curl! operator. Let's demonstrate this on a uniform field on the surface.","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"gc = zeros_gridcurl(cache)\nf = ones_surface(cache)\nsurface_curl!(gc,f,cache)\nplot(gc,cache)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"The continuous version of this operation is actually zero. It's not quite zero in discrete form. However, its norm is much smaller than that of the double layer.","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"norm(gc,cache)/norm(dl,cache)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Finally, a pair of operations that are used in support of the previous ones, or occasionally on their own, are","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"R_n f = delta(chi)mathbfncirc f","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"for scalar surface data f, which maps to a vector field, effectively a field of doublet strengths; and its transpose","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"R_n^T mathbfu = mathbfncdot delta^T(chi)mathbfu","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"which maps vector field data mathbfu to a scalar surface field, the normal component of the vector field on the surface. These are provided by regularize_normal! and normal_interpolate!, respectively.","category":"page"},{"location":"manual/surfaceops/#Masks","page":"Surface-grid operations","title":"Masks","text":"","category":"section"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Masks are grid data that take the value 1 in one region (e.g., the interior of a surface) and 0 in the other (e.g., the exterior). The functions mask and complementary_mask achieve this","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"m = mask(cache)\ncm = complementary_mask(cache)\nplot(\n   surface(m,cache,layers=false),\n   surface(cm,cache,layers=false)\n   )","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"One can apply a mask to some grid data by multiplying it, using, e.g., the product! function in CartesianGrids.jl. Let's demonstrate that with the grid data of x coordinates:","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"xmask = zeros_grid(cache)\nxcmask = zeros_grid(cache)\nproduct!(xmask,xg,m)\nproduct!(xcmask,xg,cm)\nplot(\n plot(xmask,cache),\n plot(xcmask,cache)\n )","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"The mask and complementary mask effectively partition the field into two parts. We can also apply masks in place, using mask! and complementary_mask!:","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"xmask .= xg\nmask!(xmask,cache)\nplot(xmask,cache)","category":"page"},{"location":"manual/surfaceops/#Surface-grid-operator-functions","page":"Surface-grid operations","title":"Surface-grid operator functions","text":"","category":"section"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"regularize!\ninterpolate!\nregularize_normal!\nregularize_normal_symm!\nnormal_interpolate!\nnormal_interpolate_symm!\nregularize_normal_cross!\nnormal_cross_interpolate!\nregularize_normal_dot!\nnormal_dot_interpolate!\nsurface_divergence!\nsurface_grad!\nsurface_curl!\nsurface_divergence_cross!\nsurface_grad_cross!\nsurface_curl_cross!\nmask!\nmask\ncomplementary_mask!\ncomplementary_mask","category":"page"},{"location":"manual/surfaceops/#ImmersedLayers.regularize!","page":"Surface-grid operations","title":"ImmersedLayers.regularize!","text":"regularize!(s::Nodes{Primal},f::ScalarData,cache::BasicILMCache)\nregularize!(s::Nodes{Primal},f::ScalarData,sys::ILMSystem)\n\nThe operation s = R_c f, which regularizes scalar surface data f onto the grid in the form of scalar grid data s. This is the adjoint to interpolate!\n\n\n\n\n\nregularize!(s::Nodes{Dual},f::ScalarData,cache::BasicILMCache)\nregularize!(s::Nodes{Dual},f::ScalarData,sys::ILMSystem)\n\nThe operation s = R_N f, which regularizes scalar surface data f onto the grid in the form of scalar grid (curl) data s. Only works if the cache is built for vector data. This is the adjoint to interpolate!\n\n\n\n\n\nregularize!(v::Edges{Primal},vb::VectorData,cache::BasicILMCache)\nregularize!(v::Edges{Primal},vb::VectorData,sys::ILMSystem)\n\nThe operation mathbfv = R_f mathbfv_b, which regularizes vector surface data vb onto the grid in the form of scalar grid data v. This is the adjoint to interpolate!\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.interpolate!","page":"Surface-grid operations","title":"ImmersedLayers.interpolate!","text":"interpolate!(f::ScalarData,s::Nodes{Primal},cache::BasicILMCache)\ninterpolate!(f::ScalarData,s::Nodes{Primal},sys::ILMSystem)\n\nThe operation f = R_c^T s, which interpolates scalar grid data s onto the surface points in the form of scalar point data f. This is the adjoint to regularize!\n\n\n\n\n\ninterpolate!(f::ScalarData,s::Nodes{Dual},cache::BasicILMCache)\ninterpolate!(f::ScalarData,s::Nodes{Dual},sys::ILMSystem)\n\nThe operation f = R_N^T s, which interpolates scalar grid (curl) data s onto the surface points in the form of scalar point data f. Only works if the cache is built for vector data. This is the adjoint to regularize!\n\n\n\n\n\ninterpolate!(vb::VectorData,v::Edges{Primal},cache::BasicILMCache)\ninterpolate!(vb::VectorData,v::Edges{Primal},sys::ILMSystem)\n\nThe operation mathbfv_b = R_c^T mathbfv, which interpolates vector grid data v onto the surface points in the form of scalar point data vb. This is the adjoint to regularize!\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.regularize_normal!","page":"Surface-grid operations","title":"ImmersedLayers.regularize_normal!","text":"regularize_normal!(v::Edges{Primal},f::ScalarData,cache::BasicILMCache)\nregularize_normal!(v::Edges{Primal},f::ScalarData,sys::ILMSystem)\n\nThe operation mathbfv = R_f mathbfncirc f, which maps scalar surface data f (like a jump in scalar potential) to grid data v (like velocity). This is the adjoint to normal_interpolate!.\n\n\n\n\n\nregularize_normal!(qt::EdgeGradient{Primal},v::VectorData,cache::BasicILMCache)\nregularize_normal!(qt::EdgeGradient{Primal},v::VectorData,sys::ILMSystem)\n\nThe operation mathbfq_t = R_t mathbfncirc mathbfv, which maps scalar vector data v (like a jump in velocity) to grid data qt (like velocity-normal tensor). This is the adjoint to normal_interpolate!.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.regularize_normal_symm!","page":"Surface-grid operations","title":"ImmersedLayers.regularize_normal_symm!","text":"regularize_normal_symm!(qt::EdgeGradient{Primal},v::VectorData,cache::BasicILMCache)\nregularize_normal_symm!(qt::EdgeGradient{Primal},v::VectorData,sys::ILMSystem)\n\nThe operation mathbfq_t = R_t (mathbfncirc mathbfv+mathbfvcirc mathbfn), which maps scalar vector data v (like a jump in velocity) to grid data qt (like velocity-normal tensor). This is the adjoint to normal_interpolate_symm!.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.normal_interpolate!","page":"Surface-grid operations","title":"ImmersedLayers.normal_interpolate!","text":"normal_interpolate!(vn::ScalarData,v::Edges{Primal},cache::BasicILMCache)\nnormal_interpolate!(vn::ScalarData,v::Edges{Primal},sys::ILMSystem)\n\nThe operation v_n = mathbfn cdot R_f^T mathbfv, which maps grid data v (like velocity) to scalar surface data vn (like normal component of surface velocity). This is the adjoint to regularize_normal!.\n\n\n\n\n\nnormal_interpolate!(τ::VectorData,A::EdgeGradient{Primal},cache::BasicILMCache)\nnormal_interpolate!(τ::VectorData,A::EdgeGradient{Primal},sys::ILMSystem)\n\nThe operation mathbftau = mathbfn cdot R_t^T mathbfA, which maps grid tensor data A (like velocity gradient tensor) to vector surface data τ (like traction). This is the adjoint to regularize_normal!.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.normal_interpolate_symm!","page":"Surface-grid operations","title":"ImmersedLayers.normal_interpolate_symm!","text":"normal_interpolate_symm!(τ::VectorData,A::EdgeGradient{Primal},cache::BasicILMCache)\nnormal_interpolate_symm!(τ::VectorData,A::EdgeGradient{Primal},sys::ILMSystem)\n\nThe operation mathbftau = mathbfn cdot R_t^T (mathbfA +mathbfA^T - (mathrmtrmathbfA)mathbfI), which maps grid tensor data A (like velocity gradient tensor) to vector surface data τ (like traction). This is the adjoint to regularize_normal_symm!.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.regularize_normal_cross!","page":"Surface-grid operations","title":"ImmersedLayers.regularize_normal_cross!","text":"regularize_normal_cross!(v::Edges{Primal},f::ScalarData,cache::BasicILMCache)\nregularize_normal_cross!(v::Edges{Primal},f::ScalarData,sys::ILMSystem)\n\nThe operation mathbfv = R_f mathbfntimes f mathbfe_z, which maps scalar surface data f (like a jump in streamfunction, endowed with the out-of-plane unit vector mathbfe_z) to grid data v (like velocity). This is the negative adjoint to normal_cross_interpolate!.\n\n\n\n\n\nregularize_normal_cross!(w::Nodes{Dual},vs::VectorData,cache::BasicILMCache)\nregularize_normal_cross!(w::Nodes{Dual},vs::VectorData,sys::ILMSystem)\n\nThe operation omega = R_N mathbfntimes mathbfv_s, which maps surface vector data vs (like a jump in velocity) to grid dual nodal data w (like vorticity). This is for use only with vector-data caches. This is the negative adjoint to normal_cross_interpolate!.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.normal_cross_interpolate!","page":"Surface-grid operations","title":"ImmersedLayers.normal_cross_interpolate!","text":"normal_cross_interpolate!(wn::ScalarData,v::Edges{Primal},cache::BasicILMCache)\nnormal_cross_interpolate!(wn::ScalarData,v::Edges{Primal},sys::ILMSystem)\n\nThe operation w_n = e_zcdot (mathbfn times R_f^T mathbfv), which maps grid data v (like velocity) to scalar surface data wn (like vorticity in the surface). This is the negative adjoint to regularize_normal_cross!.\n\n\n\n\n\nnormal_cross_interpolate!(vs::VectorData,s::Nodes{Dual},cache::BasicILMCache)\nnormal_cross_interpolate!(vs::VectorData,s::Nodes{Dual},sys::ILMSystem)\n\nThe operation mathbfv_s = mathbfntimes R_N^T psimathbfe_z), which maps grid data s (like streamfunction) to vector surface data vs (like velocity in the surface). It only works for a vector-type cache. This is the negative adjoint to regularize_normal_cross!.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.regularize_normal_dot!","page":"Surface-grid operations","title":"ImmersedLayers.regularize_normal_dot!","text":"regularize_normal_dot!(f::Nodes{Primal},vs::VectorData,cache::BasicILMCache)\nregularize_normal_dot!(f::Nodes{Primal},vs::VectorData,sys::ILMSystem)\n\nThe operation phi = R_c mathbfncdot mathbfv_s, which maps surface vector data vs (like a jump in velocity) to grid nodal data f (like scalar potential). This is the negative adjoint to normal_dot_interpolate!.\n\n\n\n\n\nregularize_normal_dot!(v::Edges{Primal},taus::TensorData,cache::BasicILMCache)\nregularize_normal_dot!(v::Edges{Primal},taus::TensorData,sys::ILMSystem)\n\nThe operation mathbfv = R_f mathbfncdot mathbftau_s, which maps surface tensor data taus (like a stress) to grid edge data v (like velocity). This is the negative adjoint to normal_dot_interpolate!.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.normal_dot_interpolate!","page":"Surface-grid operations","title":"ImmersedLayers.normal_dot_interpolate!","text":"normal_dot_interpolate!(vs::VectorData,f::Nodes{Primal},cache::BasicILMCache)\nnormal_dot_interpolate!(vs::VectorData,f::Nodes{Primal},sys::ILMSystem)\n\nThe operation mathbfv_s = mathbfn R_c^T phi, which maps grid nodal data f (like scalar potential) to surface vector data vs (like velocity). This is the negative adjoint to regularize_normal_dot!.\n\n\n\n\n\nnormal_dot_interpolate!(taus::TensorData,v::Edges{Primal},cache::BasicILMCache)\nnormal_dot_interpolate!(taus::TensorData,v::Edges{Primal},sys::ILMSystem)\n\nThe operation mathbftau_s = mathbfncirc R_f^Tmathbfv, which maps grid edge data v (like velocity) to surface tensor data taus (like stress). This is the negative adjoint to regularize_normal_dot!.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.surface_divergence!","page":"Surface-grid operations","title":"ImmersedLayers.surface_divergence!","text":"surface_divergence!(Θ::Nodes{Primal},f::ScalarData,cache::BasicILMCache)\nsurface_divergence!(Θ::Nodes{Primal},f::ScalarData,sys::ILMSystem)\n\nThe operation theta = D_s f = D R_f mathbfn circ f, which maps surface scalar data f (like jump in scalar potential) to grid data Θ (like dilatation, i.e. divergence of velocity). This is the negative adjoint of surface_grad!. Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\nsurface_divergence!(v::Edges{Primal},dv::VectorData,cache::BasicILMCache)\nsurface_divergence!(v::Edges{Primal},dv::VectorData,sys::ILMSystem)\n\nThe operation mathbfv = D_s dmathbfv = D R_t (mathbfn circ dmathbfv), which maps surface vector data dv (like jump in velocity) to grid data v (like velocity). This is the negative adjoint of surface_grad!. Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.surface_grad!","page":"Surface-grid operations","title":"ImmersedLayers.surface_grad!","text":"surface_grad!(vn::ScalarData,ϕ::Nodes{Primal},cache::BasicILMCache)\nsurface_grad!(vn::ScalarData,ϕ::Nodes{Primal},sys::ILMSystem)\n\nThe operation v_n = G_sphi = mathbfn cdot R_f^T Gphi, which maps grid data ϕ (like scalar potential) to scalar surface data vn (like normal component of velocity). This is the negative adjoint of surface_divergence!. Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\nsurface_grad!(τ::VectorData,v::Edges{Primal},cache::BasicILMCache)\nsurface_grad!(τ::VectorData,v::Edges{Primal},sys::ILMSystem)\n\nThe operation mathbftau = G_s v = mathbfn cdot R_t^T G mathbfv, which maps grid vector data v (like velocity) to vector surface data τ (like traction). This is the negative adjoint of surface_divergence!. Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.surface_curl!","page":"Surface-grid operations","title":"ImmersedLayers.surface_curl!","text":"surface_curl!(w::Nodes{Dual},f::ScalarData,cache::BasicILMCache)\nsurface_curl!(w::Nodes{Dual},f::ScalarData,sys::ILMSystem)\n\nThe operation w = C_s^T f = C^T R_f mathbfncirc f, which maps scalar surface data f (like a jump in scalar potential) to grid data w (like vorticity). This is the adjoint to C_s, also given by surface_curl! (but with arguments switched). Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\nsurface_curl!(w::Nodes{Dual},v::VectorData,cache::BasicILMCache)\nsurface_curl!(w::Nodes{Dual},v::VectorData,sys::ILMSystem)\n\nThe operation w = C_s^T mathbfv = C^T R_f mathbfv, which maps vector surface data v (like velocity) to grid data w (like vorticity). This is the adjoint to C_s, also given by surface_curl! (but with arguments switched). Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\nsurface_curl!(vn::ScalarData,s::Nodes{Dual},cache::BasicILMCache)\nsurface_curl!(vn::ScalarData,s::Nodes{Dual},sys::ILMSystem)\n\nThe operation v_n = C_s s = mathbfn cdot R_f^T C s, which maps grid data s (like streamfunction) to scalar surface data vn (like normal component of velocity). This is the adjoint to C_s^T, also given by surface_curl!, but with arguments switched.  Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\nsurface_curl!(v::VectorData,s::Nodes{Dual},cache::BasicILMCache)\nsurface_curl!(v::VectorData,s::Nodes{Dual},sys::ILMSystem)\n\nThe operation mathbfv = C_s s = R_f^T C s, which maps grid data s (like streamfunction) to vector surface data v (like velocity). This is the adjoint to C_s^T, also given by surface_curl!, but with arguments switched.  Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.surface_divergence_cross!","page":"Surface-grid operations","title":"ImmersedLayers.surface_divergence_cross!","text":"surface_divergence_cross!(Θ::Nodes{Primal},f::ScalarData,cache::BasicILMCache)\nsurface_divergence_cross!(Θ::Nodes{Primal},f::ScalarData,sys::ILMSystem)\n\nThe operation theta = hatD_s f = D R_f mathbfn times f mathbfe_z, which maps surface scalar data f (like jump in streamfunction) to grid data Θ (like dilatation, i.e. divergence of velocity). This is the adjoint of surface_grad_cross!. Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.surface_grad_cross!","page":"Surface-grid operations","title":"ImmersedLayers.surface_grad_cross!","text":"surface_grad_cross!(γ::ScalarData,ϕ::Nodes{Primal},cache::BasicILMCache)\nsurface_grad_cross!(γ::ScalarData,ϕ::Nodes{Primal},sys::ILMSystem)\n\nThe operation gamma = hatG_sphi = mathbfe_z cdot (mathbfn times R_f^T Gphi), which maps grid data ϕ (like scalar potential) to scalar surface data γ (like surface vorticity). This is the adjoint of surface_divergence_cross!. Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.surface_curl_cross!","page":"Surface-grid operations","title":"ImmersedLayers.surface_curl_cross!","text":"surface_curl_cross!(w::Nodes{Dual},f::ScalarData,cache::BasicILMCache)\nsurface_curl_cross!(w::Nodes{Dual},f::ScalarData,sys::ILMSystem)\n\nThe operation w = hatC_s^T f = C^T R_f mathbfntimes f mathbfe_z, which maps scalar surface data f (like a jump in streamfunction, multiplied by out-of-plane unit vector mathbfe_z) to grid data w (like vorticity). This is the adjoint to hatC_s, also given by surface_curl_cross! (but with arguments switched). Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\nsurface_curl_cross!(γ::ScalarData,s::Nodes{Dual},cache::BasicILMCache)\nsurface_curl_cross!(γ::ScalarData,s::Nodes{Dual},sys::ILMSystem)\n\nThe operation gamma = hatC_s s = mathbfe_zcdot (mathbfn times R_f^T C s), which maps grid data s (like streamfunction) to scalar surface data γ (like vorticity in the surface). This is the adjoint to hatC_s^T, also given by surface_curl_cross!, but with arguments switched.  Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.mask!","page":"Surface-grid operations","title":"ImmersedLayers.mask!","text":"mask!(w::GridData,cache::BasicILMCache)\nmask!(w::GridData,sys::ILMSystem)\n\nMask the data w in place by multiplying it by 1s inside of a surface (i.e., on a side opposite   the normal vectors) and 0s outside. The grid data w must be of the same type as the   output data type of cache. Only allows cache to have GridScaling.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.mask","page":"Surface-grid operations","title":"ImmersedLayers.mask","text":"mask(cache::BasicILMCache) -> GridData\nmask(sys::ILMSystem) -> GridData\n\nCreate grid data that consist of 1s inside of a surface (i.e., on a side opposite   the normal vectors) and 0s outside. The grid data are the same type as the   output data type of sys.  Only allows sys to have GridScaling.   If the cache has no immersed surface, then it reverts to 1s everywhere.\n\n\n\n\n\nmask(ar::AreaRegionCache)\n\nReturn the mask for the given area region ar.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.complementary_mask!","page":"Surface-grid operations","title":"ImmersedLayers.complementary_mask!","text":"complementary_mask!(w::GridData,cache::BasicILMCache)\ncomplementary_mask!(w::GridData,sys::ILMSystem)\n\nMask the data w in place by multiplying it by 0s inside of a surface (i.e., on a side opposite   the normal vectors) and 1s outside. The grid data w must be of the same type as the   output data type of cache. Only allows cache to have GridScaling.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.complementary_mask","page":"Surface-grid operations","title":"ImmersedLayers.complementary_mask","text":"complementary_mask(cache::BasicILMCache) -> GridData\ncomplementary_mask(sys::ILMSystem) -> GridData\n\nCreate grid data that consist of 0s inside of a surface (i.e., on a side opposite   the normal vectors) and 1s outside. The grid data are the same type as the   output data type of cache.  Only allows cache to have GridScaling.   If the cache has no immersed surface, then it reverts to 0s everywhere.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"EditURL = \"<unknown>/literate/caches.jl\"","category":"page"},{"location":"manual/caches/#Immersed-layer-caches","page":"Immersed layer caches","title":"Immersed layer caches","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"This package uses precomputed caches to efficiently implement the immersed layer operators. The starting point for a cache is the specification of the (discretized) body shape and the grid. Let's use an example.","category":"page"},{"location":"manual/caches/#Setting-up-a-cache","page":"Immersed layer caches","title":"Setting up a cache","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"using ImmersedLayers\nusing Plots\nusing LinearAlgebra","category":"page"},{"location":"manual/caches/#Set-up-a-grid","page":"Immersed layer caches","title":"Set up a grid","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"First, we will set up a grid for performing the operations. We use the PhysicalGrid constructor of the CartesianGrids.jl package to create this.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"Δx = 0.01\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx)","category":"page"},{"location":"manual/caches/#Set-the-shape","page":"Immersed layer caches","title":"Set the shape","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"Now let's set a shape to immerse into the grid. We will use a circle, but there are a variety of other shapes available. Many of these are in the RigidBodyTools.jl package. Note that we set the spacing between the points on this shape equal to 1.4 times the grid spacing. This is not critical, but it is generally best to set it to a value between 1 and 2.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"RadC = 1.0\nΔs = 1.4*cellsize(g)\nbody = Circle(RadC,Δs)","category":"page"},{"location":"manual/caches/#Create-the-cache","page":"Immersed layer caches","title":"Create the cache","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"After setting the grid and the surface to immerse, the next step for using the immersed layer tools is to set up a surface cache. This allocates a set of data structures, as well as the critical regularization and interpolation operators that will get used.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"There are a few choices to make when setting this up","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"What kind of data (scalar or vector) are we dealing with?","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"We will demonstrate with scalar data, which means we use the SurfaceScalarCache function. For vector data, use SurfaceVectorCache.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"What type of scaling (grid or index) do we wish to apply to the operators?","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"Grid scaling, set with scaling = GridScaling, means that the various operators are scaled with the physical grid spacing and/or surface point spacing so that they approximate the continuous operators. This means that regularization and interpolation are transposes with respect to inner products that incorporate these physical spacings, rather than the usual linear algebra inner products. Also, differential operations on the grid are true approximations of their continuous counterparts. This choice of scaling is usually the best, and the dot operator is extended in this package to implement the physically- scaled inner products.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"On the other hand, scaling = IndexScaling does not scale these, but rather, uses pure differencing for the grid differential operators, and regularization is the simple matrix transpose of interpolation.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"What discrete Dirac delta function (DDF) do we wish to use?","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"This is specified with the ddftype keyword argument. The default is ddftype=CartesianGrids.Yang3 [1]. However, there are other choices, such as CartesianGrids.Roma, CartesianGrids.Goza, CartesianGrids.Witchhat, CartesianGrids.M3, CartesianGrids.M4prime.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"cache = SurfaceScalarCache(body,g,scaling=GridScaling)","category":"page"},{"location":"manual/caches/#Plotting-the-immersed-points","page":"Immersed layer caches","title":"Plotting the immersed points","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"We can plot the immersed points with the plot function of the Plots.jl package, using a special plot recipe. This accepts all of the usual attribute keywords of the basic plot function.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"plot(cache,xlims=(-2,2),ylims=(-2,2))","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"In this plotting demonstration, we have used the points function to obtain the coordinates of the immersed points. Other useful utilities are normals, areas, and arcs, e.g.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"normals(cache)","category":"page"},{"location":"manual/caches/#Some-basic-utilities","page":"Immersed layer caches","title":"Some basic utilities","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"We will see deeper uses of this cache in Surface-grid operations. However, for now we can learn how to get basic copies of the grid and surface data. For example, a copy of the grid data, all initialized to zero:","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"zeros_grid(cache)","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"or similarly on the surface","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"zeros_surface(cache)","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"We also might need to initialize data on the grid to accept the curl of a vector field. This is used in conjunction with surface_curl!, for example.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"zeros_gridcurl(cache)","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"If we want them initialized to unity, then use","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"ones_grid(cache)","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"and","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"ones_surface(cache)","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"To evaluate functions on the grid, it is useful to be able to fill grid data with the x and y coordinates. For this, we use","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"x_grid(cache)","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"y_grid(cache)","category":"page"},{"location":"manual/caches/#Using-norms-and-inner-products","page":"Immersed layer caches","title":"Using norms and inner products","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"It is useful to compute norms and inner products on grid and surface data. These tools are easily accessible, e.g., dot(u,v,cache) and norm(u,cache), and they respect the scaling associated with the cache. For example, the following gives an approximation of the circumference of the circle:","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"os = ones_surface(cache)\ndot(os,os,cache)","category":"page"},{"location":"manual/caches/#Cache-types-and-constructors","page":"Immersed layer caches","title":"Cache types and constructors","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"BasicILMCache\nSurfaceScalarCache\nSurfaceVectorCache\nAbstractExtraILMCache","category":"page"},{"location":"manual/caches/#ImmersedLayers.BasicILMCache","page":"Immersed layer caches","title":"ImmersedLayers.BasicILMCache","text":"struct BasicILMCache{N, SCA<:AbstractScalingType, GCT, ND, BLT<:BodyList, NT<:VectorData, DST<:ScalarData, REGT<:Regularize, RSNT<:RegularizationMatrix, ESNT<:InterpolationMatrix, RT<:RegularizationMatrix, ET<:InterpolationMatrix, RCT, ECT, RDT, EDT, LT<:Laplacian, GVT, GNT, GDT, SVT, SDT, SST} <: ImmersedLayers.AbstractBasicCache{N, GCT}\n\nA cache of operators and storage data for use in surface operations. Constructed with SurfaceScalarCache or SurfaceVectorCache.\n\n\n\n\n\n","category":"type"},{"location":"manual/caches/#ImmersedLayers.SurfaceScalarCache","page":"Immersed layer caches","title":"ImmersedLayers.SurfaceScalarCache","text":"SurfaceScalarCache(g::PhysicalGrid[,scaling=IndexScaling])\n\nCreate a cache of type BasicILMCache with scalar grid data, using the grid specified in g, with no immersed points. The keyword scaling can be used to set the scaling in the operations. By default, it is set to IndexScaling which sets the differential operators to be only differencing operators. By using scaling = GridScaling, then the grid and  spacings are accounted for and differential operators are scaled by this spacing.  The keyword phys_params can be used to supply physical parameters.\n\n\n\n\n\nSurfaceScalarCache(body::Body/BodyList,g::PhysicalGrid[,ddftype=CartesianGrids.Yang3][,scaling=GridScaling])\n\nCreate a cache of type BasicILMCache, holding operators and storage data for use in immersed layer operations on scalar data. This is sometimes called from withinILMSystem rather than directly.\n\nThe body can be of type Body or BodyList. The keyword scaling can be used to set the scaling in the operations. By default, it is set to IndexScaling which sets the regularization and interpolation to be symmetric matrices (i.e., interpolation is the adjoint of regularization with   respect to a vector dot product), and the vector calculus operations on the grid   are simple differences. By using scaling = GridScaling, then the grid and   point spacings are accounted for. Interpolation and regularization are adjoints   with respect to inner products based on discretized surface and volume integrals,   and vector calculus operations are scaled by the grid spacing.\n\n\n\n\n\nSurfaceScalarCache(X::VectorData,g::PhysicalGrid[,ddftype=CartesianGrids.Yang3][,scaling=GridScaling])\n\nCreate a cache of type BasicILMCache, holding operators and storage data for use in immersed layer operations on scalar data. The X specifies the is assumed to hold the endpoints of the immersed surface segments, and g the physical grid.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.SurfaceVectorCache","page":"Immersed layer caches","title":"ImmersedLayers.SurfaceVectorCache","text":"SurfaceVectorCache(g::PhysicalGrid[,scaling=IndexScaling])\n\nCreate a cache of type BasicILMCache with vector grid data, with no immersed points. See SurfaceScalarCache for details.\n\n\n\n\n\nSurfaceVectorCache(body::Body/BodyList,g::PhysicalGrid[,ddftype=CartesianGrids.Yang3][,scaling=Gridcaling])\n\nCreate a cache of type BasicILMCache, holding operators and storage data for use in immersed layer operations on vector data. See SurfaceScalarCache for details.\n\n\n\n\n\nSurfaceVectorCache(X::VectorData,g::PhysicalGrid[,ddftype=CartesianGrids.Yang3][,scaling=GridScaling])\n\nCreate a cache of type BasicILMCache, holding operators and storage data for use in immersed layer operations on vector data. See SurfaceScalarCache for details.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.AbstractExtraILMCache","page":"Immersed layer caches","title":"ImmersedLayers.AbstractExtraILMCache","text":"abstract type AbstractExtraILMCache\n\nWhen defining problem-specific cache, make it a subtype of this.\n\n\n\n\n\n","category":"type"},{"location":"manual/caches/#Utilities-for-creating-instances-of-data","page":"Immersed layer caches","title":"Utilities for creating instances of data","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"similar_grid\nsimilar_gridgrad\nsimilar_gridcurl\nsimilar_griddiv\nsimilar_gridgradcurl\nsimilar_surface\nsimilar_surfacescalar\nzeros_grid\nzeros_gridgrad\nzeros_gridcurl\nzeros_griddiv\nzeros_gridgradcurl\nzeros_surface\nzeros_surfacescalar\nones_grid\nones_gridgrad\nones_gridcurl\nones_griddiv\nones_gridgradcurl\nones_surface\nones_surfacescalar\nx_grid\ny_grid\nx_gridcurl\ny_gridcurl\nx_griddiv\ny_griddiv\nx_gridgrad\ny_gridgrad","category":"page"},{"location":"manual/caches/#ImmersedLayers.similar_grid","page":"Immersed layer caches","title":"ImmersedLayers.similar_grid","text":"similar_grid(::BasicILMCache)\n\nGet a similar copy of the basic grid data in the cache.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.similar_gridgrad","page":"Immersed layer caches","title":"ImmersedLayers.similar_gridgrad","text":"similar_gridgrad(::BasicILMCache)\n\nGet a similar copy of the gradient of the grid data in the cache.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.similar_gridcurl","page":"Immersed layer caches","title":"ImmersedLayers.similar_gridcurl","text":"similar_gridcurl(::BasicILMCache)\n\nGet a similar copy of the grid curl field data in the cache.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.similar_griddiv","page":"Immersed layer caches","title":"ImmersedLayers.similar_griddiv","text":"similar_griddiv(::BasicILMCache)\n\nGet a similar copy of the grid div field data in the cache.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.similar_gridgradcurl","page":"Immersed layer caches","title":"ImmersedLayers.similar_gridgradcurl","text":"similar_gridgradcurl(::BasicILMCache)\n\nGet a similar copy of the grid gradient-of-curl field data in the cache.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.similar_surface","page":"Immersed layer caches","title":"ImmersedLayers.similar_surface","text":"similar_surface(::BasicILMCache)\n\nGet a similar copy of the basic surface point data in the cache.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.similar_surfacescalar","page":"Immersed layer caches","title":"ImmersedLayers.similar_surfacescalar","text":"similar_surfacescalar(::BasicILMCache)\n\nGet a similar copy of the surface scalar point data in the cache. This is only used for vector-type caches. Otherwise, similar_surface should be used.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.zeros_grid","page":"Immersed layer caches","title":"ImmersedLayers.zeros_grid","text":"zeros_grid(::BasicILMCache)\n\nGet an instance of the basic grid data in the cache, with values set to zero.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.zeros_gridgrad","page":"Immersed layer caches","title":"ImmersedLayers.zeros_gridgrad","text":"zeros_gridgrad(::BasicILMCache)\n\nGet an instance of the gradient of the grid data in the cache`, with values set to zero.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.zeros_gridcurl","page":"Immersed layer caches","title":"ImmersedLayers.zeros_gridcurl","text":"zeros_gridcurl(::BasicILMCache)\n\nGet an instance of the grid curl field data in the cache, with values set to zero.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.zeros_griddiv","page":"Immersed layer caches","title":"ImmersedLayers.zeros_griddiv","text":"zeros_griddiv(::BasicILMCache)\n\nGet an instance of the grid div field data in the cache, with values set to zero.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.zeros_gridgradcurl","page":"Immersed layer caches","title":"ImmersedLayers.zeros_gridgradcurl","text":"zeros_gridgradcurl(::BasicILMCache)\n\nGet an instance of the grid gradient-of-curl field data in the cache, with values set to zero.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.zeros_surface","page":"Immersed layer caches","title":"ImmersedLayers.zeros_surface","text":"zeros_surface(::BasicILMCache)\n\nGet an instance of the basic surface point data in the cache, with values set to zero.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.zeros_surfacescalar","page":"Immersed layer caches","title":"ImmersedLayers.zeros_surfacescalar","text":"zeros_surfacescalar(::BasicILMCache)\n\nGet an instance of the surface scalar point data in the cache, with values set to zero. This is only used for vector-type caches. Otherwise, zeros_surface should be used.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.ones_grid","page":"Immersed layer caches","title":"ImmersedLayers.ones_grid","text":"ones_grid(::BasicILMCache)\n\nGet an instance of the basic grid data in the cache, with values set to unity.\n\n\n\n\n\nones_grid(::BasicILMCache,dim)\n\nFor a vector-type cache, get an instance of the basic grid data in the cache, with values set to unity in dimension dim.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.ones_gridgrad","page":"Immersed layer caches","title":"ImmersedLayers.ones_gridgrad","text":"ones_gridgrad(::BasicILMCache,dim)\n\nGet an instance of the gradient of the grid data in the cache, in direction dim, with values set to unity. If the data are of type TensorGridData, then dim takes values from 1 to 2^2.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.ones_gridcurl","page":"Immersed layer caches","title":"ImmersedLayers.ones_gridcurl","text":"ones_gridcurl(::BasicILMCache)\n\nGet an instance of the grid curl field data in the cache, with values set to unity.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.ones_griddiv","page":"Immersed layer caches","title":"ImmersedLayers.ones_griddiv","text":"ones_griddiv(::BasicILMCache)\n\nGet an instance of the grid div field data in the cache, with values set to unity.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.ones_gridgradcurl","page":"Immersed layer caches","title":"ImmersedLayers.ones_gridgradcurl","text":"ones_gridgradcurl(::BasicILMCache)\n\nGet an instance of the grid gradient-of-curl field data in the cache, with values set to unity.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.ones_surface","page":"Immersed layer caches","title":"ImmersedLayers.ones_surface","text":"ones_surface(::BasicILMCache)\n\nGet an instance of the basic surface point data in the cache, with values set to unity.\n\n\n\n\n\nones_surface(::BasicILMCache,dim)\n\nGet an instance of the basic surface point data in the cache, with values set to unity in dimension dim. This only works for a vector-type cache.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.ones_surfacescalar","page":"Immersed layer caches","title":"ImmersedLayers.ones_surfacescalar","text":"ones_surfacescalar(::BasicILMCache)\n\nGet an instance of the surface scalar point data in the cache, with values set to unity. This is only used for vector-type caches. Otherwise, ones_surface should be used.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.x_grid","page":"Immersed layer caches","title":"ImmersedLayers.x_grid","text":"x_grid(::BasicILMCache)\n\nReturn basic grid data filled with the grid x coordinate. If the grid data is scalar, then the output of this function is of the same type. If the grid data is vector, then the output is of type Edges{Primal}, and the coordinates of each component are in u, v fields.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.y_grid","page":"Immersed layer caches","title":"ImmersedLayers.y_grid","text":"y_grid(::BasicILMCache)\n\nReturn basic grid data filled with the grid y coordinate. If the grid data is scalar, then the output of this function is of the same type. If the grid data is vector, then the output is of type Edges{Primal}, and the coordinates of each component are in u, v fields.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.x_gridcurl","page":"Immersed layer caches","title":"ImmersedLayers.x_gridcurl","text":"x_gridcurl(::BasicILMCache)\n\nReturn basic grid curl field data filled with the grid x coordinate\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.y_gridcurl","page":"Immersed layer caches","title":"ImmersedLayers.y_gridcurl","text":"y_gridcurl(::BasicILMCache)\n\nReturn basic grid curl field data filled with the grid y coordinate\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.x_griddiv","page":"Immersed layer caches","title":"ImmersedLayers.x_griddiv","text":"x_griddiv(::BasicILMCache)\n\nReturn basic grid div field data filled with the grid x coordinate\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.y_griddiv","page":"Immersed layer caches","title":"ImmersedLayers.y_griddiv","text":"y_griddiv(::BasicILMCache)\n\nReturn basic grid div field data filled with the grid y coordinate\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.x_gridgrad","page":"Immersed layer caches","title":"ImmersedLayers.x_gridgrad","text":"x_gridgrad(::BasicILMCache)\n\nReturn basic grid gradient field data filled with the grid x coordinate. If the grid data is scalar, then the output of this function is of Edges{Primal} type and the coordinate field for each component can be accessed with the u and v field, respectively. If the grid data is vector, then the output is of type EdgeGradient{Primal}, and the coordinates are in dudx, dudy, dvdx, and dvdy fields.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.y_gridgrad","page":"Immersed layer caches","title":"ImmersedLayers.y_gridgrad","text":"y_gridgrad(::BasicILMCache)\n\nReturn basic grid gradient field data filled with the grid y coordinate. If the grid data is scalar, then the output of this function is of Edges{Primal} type and the coordinate field for each component can be accessed with the u and v field, respectively. If the grid data is vector, then the output is of type EdgeGradient{Primal}, and the coordinates are in dudx, dudy, dvdx, and dvdy fields.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#Utilities-for-accessing-surface-information","page":"Immersed layer caches","title":"Utilities for accessing surface information","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"areas(::BasicILMCache)\nnormals(::BasicILMCache)\npoints(::BasicILMCache)\narcs(::BasicILMCache)","category":"page"},{"location":"manual/caches/#ImmersedLayers.areas-Tuple{BasicILMCache}","page":"Immersed layer caches","title":"ImmersedLayers.areas","text":"areas(cache::BasicILMCache)\n\nReturn the areas (as ScalarData) of the surface panels associated with cache\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#ImmersedLayers.normals-Tuple{BasicILMCache}","page":"Immersed layer caches","title":"ImmersedLayers.normals","text":"normals(cache::BasicILMCache)\n\nReturn the normals (as VectorData) of the surface points associated with cache\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#ImmersedLayers.points-Tuple{BasicILMCache}","page":"Immersed layer caches","title":"ImmersedLayers.points","text":"points(cache::BasicILMCache)\n\nReturn the coordinates (as VectorData) of the surface points associated with cache\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#ImmersedLayers.arcs-Tuple{BasicILMCache}","page":"Immersed layer caches","title":"ImmersedLayers.arcs","text":"arcs(cache::BasicILMCache)\n\nReturn ScalarData of arc length coordinates for the body surface(s) in the given cache cache.\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#Inner-products,-norms,-and-integrals","page":"Immersed layer caches","title":"Inner products, norms, and integrals","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"dot(::GridData,::GridData,::BasicILMCache)\ndot(::PointData,::PointData,::BasicILMCache)\nnorm(::GridData,::BasicILMCache)\nnorm(::PointData,::BasicILMCache)\nintegrate(::ScalarData{N},::BasicILMCache{N}) where {N}\ndot(::PointData,::PointData,::BasicILMCache,::Int)\nnorm(::PointData,::BasicILMCache,::Int)\nintegrate(::ScalarData{N},::BasicILMCache{N},::Int) where {N}","category":"page"},{"location":"manual/caches/#LinearAlgebra.dot-Tuple{GridData, GridData, BasicILMCache}","page":"Immersed layer caches","title":"LinearAlgebra.dot","text":"dot(u1::GridData,u2::GridData,cache::BasicILMCache)\n\nCalculate the inner product of grid data u1 and u2, using the scaling associated with cache.\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#LinearAlgebra.dot-Tuple{PointData, PointData, BasicILMCache}","page":"Immersed layer caches","title":"LinearAlgebra.dot","text":"dot(u1::PointData,u2::PointData,cache::BasicILMCache)\n\nCalculate the inner product of surface point data u1 and u2, using the scaling associated with cache.\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#LinearAlgebra.norm-Tuple{GridData, BasicILMCache}","page":"Immersed layer caches","title":"LinearAlgebra.norm","text":"norm(u::GridData,cache::BasicILMCache)\n\nCalculate the norm of grid data u, using the scaling associated with cache.\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#LinearAlgebra.norm-Tuple{PointData, BasicILMCache}","page":"Immersed layer caches","title":"LinearAlgebra.norm","text":"norm(u::PointData,cache::BasicILMCache)\n\nCalculate the norm of surface point data u, using the scaling associated with cache.\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#CartesianGrids.integrate-Union{Tuple{N}, Tuple{ScalarData{N, T, DT} where {T, DT<:(AbstractVector{T} where T)}, BasicILMCache{N, SCA, GCT, ND, BLT, NT, DST, REGT, RSNT, ESNT, RT, ET, RCT, ECT, RDT, EDT, LT, GVT, GNT, GDT, SVT, SDT, SST} where {SCA<:AbstractScalingType, GCT, ND, BLT<:BodyList, NT<:VectorData, DST<:ScalarData, REGT<:Regularize, RSNT<:RegularizationMatrix, ESNT<:InterpolationMatrix, RT<:RegularizationMatrix, ET<:InterpolationMatrix, RCT, ECT, RDT, EDT, LT<:Laplacian, GVT, GNT, GDT, SVT, SDT, SST}}} where N","page":"Immersed layer caches","title":"CartesianGrids.integrate","text":"integrate(u::PointData,cache::BasicILMCache)\n\nCalculate the discrete surface integral of data u on the immersed points in cache. This uses trapezoidal rule quadrature. If u is VectorData, then this returns a vector of the integrals in each coordinate direction. This operation produces the same effect, regardless if cache is set up for GridScaling or IndexScaling. In both cases, the surface element areas are used.\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#LinearAlgebra.dot-Tuple{PointData, PointData, BasicILMCache, Int64}","page":"Immersed layer caches","title":"LinearAlgebra.dot","text":"dot(u1::PointData,u2::PointData,cache::BasicILMCache,i)\n\nCalculate the inner product of surface point data u1 and u2 for body i in the cache cache, scaling as appropriate for this cache.\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#LinearAlgebra.norm-Tuple{PointData, BasicILMCache, Int64}","page":"Immersed layer caches","title":"LinearAlgebra.norm","text":"norm(u::PointData,cache::BasicILMCache,i::Int)\n\nCalculate the norm of surface point data u, using the scaling associated with cache, for body i in the body list of cache.\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#CartesianGrids.integrate-Union{Tuple{N}, Tuple{ScalarData{N, T, DT} where {T, DT<:(AbstractVector{T} where T)}, BasicILMCache{N, SCA, GCT, ND, BLT, NT, DST, REGT, RSNT, ESNT, RT, ET, RCT, ECT, RDT, EDT, LT, GVT, GNT, GDT, SVT, SDT, SST} where {SCA<:AbstractScalingType, GCT, ND, BLT<:BodyList, NT<:VectorData, DST<:ScalarData, REGT<:Regularize, RSNT<:RegularizationMatrix, ESNT<:InterpolationMatrix, RT<:RegularizationMatrix, ET<:InterpolationMatrix, RCT, ECT, RDT, EDT, LT<:Laplacian, GVT, GNT, GDT, SVT, SDT, SST}, Int64}} where N","page":"Immersed layer caches","title":"CartesianGrids.integrate","text":"integrate(u::PointData,cache::BasicILMCache,i::Int)\n\nCalculate the discrete surface integral of scalar data u on the immersed points in cache, on body i in the body list in cache. This uses trapezoidal rule quadrature. If u is VectorData, then this returns a vector of the integrals in each coordinate direction. This operation produces the same effect, regardless if cache is set up for GridScaling or IndexScaling. In both cases, the surface element areas are used.\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#Other-cache-utilities","page":"Immersed layer caches","title":"Other cache utilities","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"view(::PointData,::BasicILMCache,::Int)\nRegularizationMatrix(::BasicILMCache,::PointData,::GridData)\nInterpolationMatrix(::BasicILMCache,::GridData,::PointData)","category":"page"},{"location":"manual/caches/#Base.view-Tuple{PointData, BasicILMCache, Int64}","page":"Immersed layer caches","title":"Base.view","text":"view(u::PointData,cache::BasicILMCache,i::Int)\n\nProvide a view of point data u corresponding to body i in the list of bodies in cache.\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#CartesianGrids.RegularizationMatrix-Tuple{BasicILMCache, PointData, GridData}","page":"Immersed layer caches","title":"CartesianGrids.RegularizationMatrix","text":"RegularizationMatrix(cache::BasicILMCache,src::PointData,trg::GridData)\n\nCreate a regularization matrix for regularizing point data of type src to grid data of type trg. (Both src and trg must be appropriately sized for the grid and points in cache.)\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#CartesianGrids.InterpolationMatrix-Tuple{BasicILMCache, GridData, PointData}","page":"Immersed layer caches","title":"CartesianGrids.InterpolationMatrix","text":"InterpolationMatrix(cache::BasicILMCache,src::GridData,trg::PointData)\n\nCreate a interpolation matrix for regularizing grid data of type src to point data of type trg. (Both src and trg must be appropriately sized for the grid and points in cache.)\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"[1]: Yang, X., et al., (2009) \"A smoothing technique for discrete delta functions with application to immersed boundary method in moving boundary simulations,\" J. Comput. Phys., 228, 7821–7836.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#ImmersedLayers.jl","page":"Home","title":"ImmersedLayers.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tools for solving partial differential equations by immersing surfaces and their operations in Cartesian grids","category":"page"},{"location":"#Package-objective","page":"Home","title":"Package objective","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The objective of this package is to implement tools and operations for solving partial differential equations (PDEs) on Cartesian grids. Objects in the domain of interest are handled by immersing them into the grid (rather than creating a grid that conforms to their shape). The package implements    ","category":"page"},{"location":"","page":"Home","title":"Home","text":"the tools for regularizing and interpolating data between discretely-represented surfaces and Cartesian grids\ndiscrete Heaviside functions that mask the regions interior or exterior of surfaces\ndiscrete differential operators that immerse surface data into the grid (i.e., \"layers\")\nan easy framework for specifying a user-defined PDE problem and creating the caches and functions (e.g., boundary conditions, forcing, time marching) that fully implement this problem\nseveral examples of prototypical PDEs, both time-invariant and time-varying","category":"page"},{"location":"","page":"Home","title":"Home","text":"At this time, the package only implements these in two spatial dimensions. The operators and tools are described in detail in [1], but a summary is given below.","category":"page"},{"location":"#Background","page":"Home","title":"Background","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A lot of problems in physics involve surfaces and their interaction with fields in a higher-dimensional space. One way to facilitate this interaction is by \"immersing\" the surface data, as well as the associated operations on these data, into the higher-dimensional space, and similarly, allowing data in the higher-dimensional space to be restricted to the surface. Underlying these is the concept of a \"masked\" field, which takes a certain continuous form on one side of a surface and another form on the other side. A Heaviside function H can be used to write this mathematically [1]:","category":"page"},{"location":"","page":"Home","title":"Home","text":"f = H(chi) f^+ + H(-chi) f^-","category":"page"},{"location":"","page":"Home","title":"Home","text":"where chi is a level set function, taking a positive value on the + side of the surface and negative value on the - side. The chi=0 level set implicitly defines the surface. Also, the gradient of chi is proportional to the unit normal vector, mathbfn. In fact, we can always choose this function so that it is the local normal.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A really neat thing happens when we take a spatial derivative of f. For example, the gradient:","category":"page"},{"location":"","page":"Home","title":"Home","text":"nabla f = H(chi) nabla f^+ + H(-chi) nabla f^- + delta(chi)mathbfn(f^+ - f^-)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, we get a masked form of the gradient fields of f on either side, plus a term involving the jump in f across the surface, times the normal vector, times the Dirac delta function delta(chi). This last factor is the immersion operator: it immerses the surface jump in f into the higher-dimensional space. Other derivatives (e.g., curl, divergence of vector fields) lead to immersion similar terms. If we the divergence of the gradient above, we get a Poisson equation with two immersion terms:","category":"page"},{"location":"","page":"Home","title":"Home","text":"nabla^2 f = H(chi) nabla^2 f^+ + H(-chi) nabla^2 f^- + delta(chi)mathbfn cdot (nabla f^+ - nabla f^-) +  nabla cdot leftdelta(chi)mathbfn(f^+ - f^-) right","category":"page"},{"location":"","page":"Home","title":"Home","text":"The last two terms are single and double layers, in the language of the theory of potentials. Generically, in any partial differential equation, we refer to these terms as immersed layers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"So standard partial differential equations can be adapted for the masked fields, so that the equations are augmented with the surface quantities. Restriction, delta^T(chi), is the transpose of immersion. It arises when we wish to impose constraints on the surface behavior; we can instead apply this constraint to the restricted form of the masked field, e.g., setting it to a prescribed value, f_s, on the surface:","category":"page"},{"location":"","page":"Home","title":"Home","text":"delta^T(chi) f = f_s","category":"page"},{"location":"","page":"Home","title":"Home","text":"In a computational environment, we discretize the fields on both the surface as well as in the higher-dimensional space, so this immersion process involves regularization (the discrete form of immersion) and interpolation (the discrete form of restriction), defined with the help of a discrete version of the Dirac delta function, the \"DDF\". We discretize the higher-dimensional space with the a staggered Cartesian grid, using tools in the CartesianGrids.jl package, which is fully exported by this package. The package also exports RigidBodyTools.jl, which has a variety of tools for creating and transforming bodies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, to regularize surface scalar data to the cell centers of the grid, we use a matrix operator, R_c. Alternatively, for regularizing vector surface data to cell faces, we use R_f. Each of these has a transpose, used for interpolation of the grid data to the surface points, e.g, R_c^T.","category":"page"},{"location":"","page":"Home","title":"Home","text":"When we combine these operations with the standard differential operators on the grid, we get a powerful set of tools for numerically solving PDEs.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package works on Julia 1.4 and above and is registered in the general Julia registry. To install from the REPL, type e.g.,","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add ImmersedLayers","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, in any version, type","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using ImmersedLayers","category":"page"},{"location":"","page":"Home","title":"Home","text":"The plots in this documentation are generated using Plots.jl. You might want to install that, too, to follow the examples.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Eldredge, J. D. (2021) \"A method of immersed layers on Cartesian grids, with application to incompressible flows,\" arXiv:2103.04521.","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"EditURL = \"<unknown>/literate/stokes.jl\"","category":"page"},{"location":"manual/stokes/#Stokes-flow","page":"Stokes flow","title":"Stokes flow","text":"","category":"section"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"Here, we'll demonstrate a solution of the Stokes equations, with Dirichlet (i.e. no-slip) boundary conditions on a surface. The purpose of this case is to demonstrate the use of the tools with vector-valued data – in this case, the fluid velocity field.","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"After taking the curl of the velocity-pressure form of the Stokes equations, the governing equations for this problem can be written as","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"mu nabla^2 omega - nabla times (delta(chi) mathbfsigma) = nablatimes nabla cdot (delta(chi)mathbfSigma)","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"delta^T(chi) mathbfv = overlinemathbfv_b","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"mathbfv = nabla phi + nablatimes psi","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"where psi and phi are the solutions of","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"nabla^2 psi = -omega","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"nabla^2 phi = delta(chi) mathbfncdot mathbfv_b","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"and mathbfSigma = mu (mathbfv_bmathbfn + mathbfn mathbfv_b - mathbfncdotmathbfv_bmathbfI) is a surface viscous flux tensor; and mathbfv_b = mathbfv_b^+ - mathbfv_b^- and overlinemathbfv_b = (mathbfv_b^+ + mathbfv_b^-)2 are the jump and average of the surface velocities on either side of a surface.","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"We can discretize and combine these equations into a saddle-point form for psi and sigma:","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"beginbmatrixL^2  C_s^T  C_s  0 endbmatrixbeginpmatrix psi  mathbfsigma endpmatrix = beginpmatrix -C D_s mathbfv_b   overlinemathbfv_b - G_s L^-1 R mathbfncdot mathbfv_b  endpmatrix","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"Note that L^2 represents the discrete biharmonic operator. (We have absorbed the viscosity mu into the scaling of the problem.)","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"We can easily break this down into algorithmic form by the same block-LU decomposition of other problems. The difference here is that mathbfv and mathbfsigma are vector-valued, so we treat this fundamentally as a vector-valued problem.","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"using ImmersedLayers\nusing Plots\nusing LinearAlgebra\nusing UnPack","category":"page"},{"location":"manual/stokes/#Set-up-the-extra-cache-and-solve-function","page":"Stokes flow","title":"Set up the extra cache and solve function","text":"","category":"section"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"The problem type is generated with the usual macro call, but now with vector type","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"@ilmproblem StokesFlow vector","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"As with other cases, the extra cache holds additional intermediate data, as well as the Schur complement. We need a few more intermediate variable for this problem. We'll also construct the filtering matrix for showing the traction field.","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"struct StokesFlowCache{SMT,SSMT,CMT,RCT,DVT,VNT,ST,VFT,FT} <: AbstractExtraILMCache\n   S :: SMT\n   Ss :: SSMT\n   C :: CMT\n   Rc :: RCT\n   dv :: DVT\n   vb :: DVT\n   vprime :: DVT\n   dvn :: VNT\n   sstar :: ST\n   vϕ :: VFT\n   ϕ :: FT\nend","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"Extend the prob_cache function to construct the extra cache","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"function ImmersedLayers.prob_cache(prob::StokesFlowProblem,base_cache::BasicILMCache)\n    S = create_CL2invCT(base_cache)\n    Ss = create_CLinvCT_scalar(base_cache)\n    C = create_surface_filter(base_cache)\n\n    dv = zeros_surface(base_cache)\n    vb = zeros_surface(base_cache)\n    vprime = zeros_surface(base_cache)\n\n    dvn = ScalarData(dv)\n    sstar = zeros_gridcurl(base_cache)\n    vϕ = zeros_grid(base_cache)\n    ϕ = Nodes(Primal,sstar)\n\n    Rc = RegularizationMatrix(base_cache,dvn,ϕ)\n\n    StokesFlowCache(S,Ss,C,Rc,dv,vb,vprime,dvn,sstar,vϕ,ϕ)\nend","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"And finally, extend the solve function to do the actual solving. We pass in the external and internal surface velocities via the bc keyword The function returns the velocity field, streamfunction field, and surface traction","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"function ImmersedLayers.solve(prob::StokesFlowProblem,sys::ILMSystem)\n    @unpack extra_cache, base_cache, bc, phys_params = sys\n    @unpack nrm = base_cache\n    @unpack S, Ss, C, Rc, dv, vb, vprime, sstar, dvn, vϕ, ϕ  = extra_cache\n\n    σ = zeros_surface(sys)\n    s = zeros_gridcurl(sys)\n    v = zeros_grid(sys)\n\n    # Get the jumps in velocity across surface\n    prescribed_surface_jump!(dv,sys)\n\n    # Compute ψ*\n    surface_divergence_symm!(v,dv,sys)\n    curl!(sstar,v,sys)\n    sstar .*= -1.0\n\n    inverse_laplacian!(sstar,sys)\n    inverse_laplacian!(sstar,sys)\n\n    # Adjustment for jump in normal velocity\n    pointwise_dot!(dvn,nrm,dv)\n    regularize!(ϕ,dvn,Rc)\n    inverse_laplacian!(ϕ,sys)\n    grad!(vϕ,ϕ,sys)\n\n    # Get the average velocity on the surface\n    prescribed_surface_average!(vb,sys)\n    interpolate!(vprime,vϕ,sys)\n    vprime .= vb - vprime\n\n    # Compute surface velocity due to ψ*\n    curl!(v,sstar,sys)\n    interpolate!(vb,v,sys)\n\n    # Spurious slip\n    vprime .-= vb\n    σ .= S\\vprime\n\n    # Correction streamfunction\n    surface_curl!(s,σ,sys)\n    s .*= -1.0\n    inverse_laplacian!(s,sys)\n    inverse_laplacian!(s,sys)\n\n    # Correct\n    s .+= sstar\n\n    # Assemble the velocity\n    curl!(v,s,sys)\n    v .+= vϕ\n\n    # Add the streamfunction equivalent to scalar potential\n    ds = zeros_surfacescalar(base_cache)\n    surface_grad_cross!(ds,ϕ,base_cache)\n    ds .= Ss\\ds\n    surface_curl_cross!(sstar,ds,base_cache)\n    sstar .*= -1.0\n    inverse_laplacian!(sstar,base_cache)\n    s .+= sstar\n\n    # Filter the traction twice to clean it up a bit\n    σ .= C^2*σ\n\n    return v, s, σ\nend","category":"page"},{"location":"manual/stokes/#Set-up-a-grid,-body,-and-boundary-conditions","page":"Stokes flow","title":"Set up a grid, body, and boundary conditions","text":"","category":"section"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"We'll consider a rectangle here","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"Δx = 0.01\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx)\nΔs = 1.4*cellsize(g)\nbody = Rectangle(0.5,0.25,Δs)","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"Set up the boundary condition functions and assemble them into a Dict. We will consider the flow generated by simply translating the body to the right at unit velocity. We set the external x velocity to 1 and y velocity to zero. The internal velocity we set to zero.","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"function get_vsplus(base_cache,phys_params)\n    vsplus = zeros_surface(base_cache)\n    vsplus.u .= 1.0\n    return vsplus\nend\nget_vsminus(base_cache,phys_params) = zeros_surface(base_cache)\n\nbcdict = Dict(\"exterior\"=>get_vsplus,\"interior\"=>get_vsminus)","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"Set up the problem and the system, passing in the boundary condition information","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"prob = StokesFlowProblem(g,body,scaling=GridScaling,bc=bcdict)\nsys = construct_system(prob);\nnothing #hide","category":"page"},{"location":"manual/stokes/#Solve-the-problem","page":"Stokes flow","title":"Solve the problem","text":"","category":"section"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"solve(prob,sys) #hide\n@time v, s, σ = solve(prob,sys)\nnothing #hide","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"Let's look at the velocity components","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"plot(v,sys)","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"Note that the velocity is zero inside, as desired. Let's look at the streamlines here","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"plot(s,sys)","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"We'll plot the surface traction components, too.","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"plot(σ.u,sys,label=\"σx\")\nplot!(σ.v,sys,label=\"σy\")","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"Now, let's apply a different motion, where we rotate it counter-clockwise at unit angular velocity. We simply re-define the external velocity function.","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"function get_vsplus(base_cache,phys_params)\n    pts = points(base_cache)\n    vsplus = zeros_surface(base_cache)\n    vsplus.u .= -pts.v\n    vsplus.v .= pts.u\n    return vsplus\nend","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"Solve it again and plot the velocity and streamlines","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"v, s, σ = solve(prob,sys)\nplot(v,sys)","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"plot(s,sys)","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"This page was generated using Literate.jl.","category":"page"}]
}
