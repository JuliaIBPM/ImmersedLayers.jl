var documenterSearchIndex = {"docs":
[{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"EditURL = \"<unknown>/literate/gridops.jl\"","category":"page"},{"location":"manual/gridops/#Grid-operations","page":"Grid operations","title":"Grid operations","text":"","category":"section"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"There are a variety of (purely) grid-based operators that are useful for carrying out calculations in immersed layer problems. We will demonstrate a few of them here. We will start by generating the cache, just as we did in Immersed layer caches","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"using ImmersedLayers\nusing CartesianGrids\nusing Plots","category":"page"},{"location":"manual/gridops/#Set-up-a-grid-and-cache","page":"Grid operations","title":"Set up a grid and cache","text":"","category":"section"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"Δx = 0.01\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ngrid = PhysicalGrid(xlim,ylim,Δx)","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"We still generate a cache for these operations, but now, we only supply the grid. There are no immersed surfaces for this demonstration.","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"cache = SurfaceScalarCache(grid,scaling=GridScaling)","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"To demonstrate, let's generate a Gaussian","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"p = zeros_grid(cache)\nxg, yg = x_grid(cache), y_grid(cache)\np .= exp.(-(xg∘xg)-(yg∘yg))","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"Now, let's generate the gradient of these data","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"v = zeros_gridgrad(cache)\ngrad!(v,p,cache)\nplot(v,cache)","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"And finally, let's compute the convective derivative,","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"mathbfvcdotnablamathbfv","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"For this, we create a separate cache, using ConvectiveDerivativeCache, which can be constructed from the existing cache. This extra cache holds additional memory for making the calculation of the convective derivative faster. We will","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"cdcache = ConvectiveDerivativeCache(cache)\nvdv = zeros_gridgrad(cache)\nconvective_derivative!(vdv,v,cache,cdcache) #hide\n@time convective_derivative!(vdv,v,cache,cdcache)\nnothing #hide","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"Plot it","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"plot(vdv,cache)","category":"page"},{"location":"manual/gridops/#Surface-grid-operator-functions","page":"Grid operations","title":"Surface-grid operator functions","text":"","category":"section"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"divergence!\ngrad!\ncurl!\nconvective_derivative!\nconvective_derivative\nConvectiveDerivativeCache\ninverse_laplacian!","category":"page"},{"location":"manual/gridops/#CartesianGrids.divergence!","page":"Grid operations","title":"CartesianGrids.divergence!","text":"divergence!(p::Nodes{Primal},v::Edges{Primal},cache::BasicILMCache)\ndivergence!(p::Nodes{Primal},v::Edges{Primal},sys::ILMSystem)\n\nCompute the discrete divergence of v and return it in p, scaling it by the grid spacing if cache (or sys) is of GridScaling type, or leaving it as a simple differencing if cache (or sys) is of IndexScaling type.\n\n\n\n\n\n","category":"function"},{"location":"manual/gridops/#CartesianGrids.grad!","page":"Grid operations","title":"CartesianGrids.grad!","text":"grad!(v::Edges{Primal},p::Nodes{Primal},cache::BasicILMCache)\ngrad!(v::Edges{Primal},p::Nodes{Primal},sys::ILMSystem)\n\nCompute the discrete gradient of p and return it in v, scaling it by the grid spacing if cache (or sys) is of GridScaling type, or leaving it as a simple differencing if cache (or sys) is of IndexScaling type.\n\n\n\n\n\n","category":"function"},{"location":"manual/gridops/#CartesianGrids.curl!","page":"Grid operations","title":"CartesianGrids.curl!","text":"curl!(v::Edges{Primal},s::Nodes{Dual},cache::BasicILMCache)\ncurl!(v::Edges{Primal},s::Nodes{Dual},sys::ILMSystem)\n\nCompute the discrete curl of s and return it in v, scaling it by the grid spacing if cache (or sys) is of GridScaling type, or leaving it as a simple differencing if cache (or sys) is of IndexScaling type.\n\n\n\n\n\ncurl!(w::Nodes{Dual},v::Edges{Primal},cache::BasicILMCache)\ncurl!(w::Nodes{Dual},v::Edges{Primal},sys::ILMSystem)\n\nCompute the discrete curl of v and return it in w, scaling it by the grid spacing if cache (or sys) is of GridScaling type, or leaving it as a simple differencing if cache (or sys) is of IndexScaling type.\n\n\n\n\n\n","category":"function"},{"location":"manual/gridops/#CartesianGrids.convective_derivative!","page":"Grid operations","title":"CartesianGrids.convective_derivative!","text":"convective_derivative!(vdv::Edges,v::Edges,base_cache::BasicILMCache,extra_cache::ConvectiveDerivativeCache)\n\nCompute the convective derivative of v, i.e., vcdot nabla v, and return the result in vdv. The result is either divided by unity or the grid cell size depending on whether base_cache is of type IndexScaling or GridScaling. This version of the method uses extra_cache of type ConvectiveDerivativeCache.\n\n\n\n\n\n","category":"function"},{"location":"manual/gridops/#ImmersedLayers.convective_derivative","page":"Grid operations","title":"ImmersedLayers.convective_derivative","text":"convective_derivative(v::Edges,base_cache::BasicILMCache)\n\nCompute the convective derivative of v, i.e., vcdot nabla v. The result is either divided by unity or the grid cell size depending on whether base_cache is of type IndexScaling or GridScaling.\n\n\n\n\n\n","category":"function"},{"location":"manual/gridops/#ImmersedLayers.ConvectiveDerivativeCache","page":"Grid operations","title":"ImmersedLayers.ConvectiveDerivativeCache","text":"ConvectiveDerivativeCache(dv::EdgeGradient)\n\nCreate a cache (a subtype of AbstractExtraILMCache) for computing the convective derivative, using dv to define the cache data.\n\n\n\n\n\n","category":"type"},{"location":"manual/gridops/#ImmersedLayers.inverse_laplacian!","page":"Grid operations","title":"ImmersedLayers.inverse_laplacian!","text":"inverse_laplacian!(w::GridData,sys::ILMSystem)\n\nCompute the in-place inverse Laplacian of grid data w, and multiply the result by unity or by the grid cell size, depending on whether sys has IndexScaling or GridScaling, respectively.\n\n\n\n\n\ninverse_laplacian!(w::GridData,cache::BasicILMCache)\n\nCompute the in-place inverse Laplacian of grid data w, and multiply the result by unity or by the grid cell size, depending on whether cache has IndexScaling or GridScaling, respectively.\n\n\n\n\n\n","category":"function"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"EditURL = \"<unknown>/literate/problems.jl\"","category":"page"},{"location":"manual/problems/#Problems-and-the-system","page":"Problems and the system","title":"Problems and the system","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"In specific problems that we wish to solve with immersed layers, there may be other data and operators that we would like to cache. We do this with an extra cache, which the user can define, along with a problem type associated with this cache. The basic cache and the extra cache are generated and associated together in a system.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"There are a few basic ingredients to do this:","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Create a problem type, making it a subtype of AbstractScalarILMProblem or AbstractVectorILMProblem. This mostly just serves as a means of dispatching correctly, but also should hold the grid and bodies so they can be passed along when the caches are constructed.\nCreate an extra cache type, making it a subtype of AbstractExtraILMCache. This can hold pretty much anything you want it to.\nExtend the function prob_cache(prob,base_cache) to serve as a constructor for your extra cache, when your problem type is passed in.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Optionally, you can also extend the function solve in order to perform the steps of your algorithm. However, generically, you can just use pass in the system structure, which holds the basic ILM cache and your extra cache, into any function.","category":"page"},{"location":"manual/problems/#Example-of-problem-and-system-use","page":"Problems and the system","title":"Example of problem and system use","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"We will demonstrate the use of problems and systems with the example given in A Dirichlet Poisson problem. Here, we will assemble the various additional data structures and operators used to solve this problem into an extra cache. We will also create a problem type called DirichletPoissonProblem, which we make a subtype of AbstractScalarILMProblem.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"using ImmersedLayers\nusing CartesianGrids\nusing RigidBodyTools\nusing Plots\nusing UnPack","category":"page"},{"location":"manual/problems/#Create-your-problem-type","page":"Problems and the system","title":"Create your problem type","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"You can copy this as a template, because it Usually doesn't need to be any different from this.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"struct DirichletPoissonProblem{DT,ST} <: ImmersedLayers.AbstractScalarILMProblem{DT,ST}\n   g :: PhysicalGrid\n   bodies :: BodyList\n   DirichletPoissonProblem(g::PT,bodies::BodyList;ddftype=CartesianGrids.Yang3,scaling=IndexScaling) where {PT} = new{ddftype,scaling}(g,bodies)\n   DirichletPoissonProblem(g::PT,body::Body;ddftype=CartesianGrids.Yang3,scaling=IndexScaling) where {PT} = new{ddftype,scaling}(g,BodyList([body]))\nend","category":"page"},{"location":"manual/problems/#Create-your-extra-cache","page":"Problems and the system","title":"Create your extra cache","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Here, we'd like this extra cache to hold the Schur complement and the filtering matrices, as well as some cache variables.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"struct DirichletPoissonCache{SMT,CMT,ST,FT} <: ImmersedLayers.AbstractExtraILMCache\n   S :: SMT\n   C :: CMT\n   fb :: ST\n   fstar :: FT\nend","category":"page"},{"location":"manual/problems/#Extend-prob_cache","page":"Problems and the system","title":"Extend prob_cache","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"We need this to construct our extra cache","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"function ImmersedLayers.prob_cache(prob::DirichletPoissonProblem,base_cache::BasicILMCache)\n    S = create_RTLinvR(base_cache)\n    C = create_surface_filter(base_cache)\n    fb = zeros_surface(base_cache)\n    fstar = zeros_grid(base_cache)\n    DirichletPoissonCache(S,C,fb,fstar)\nend","category":"page"},{"location":"manual/problems/#Extend-the-solve-function","page":"Problems and the system","title":"Extend the solve function","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Here, we actually do the work of the algorithm, making use of all of the operators and data structures that we have cached for efficiency. The example below takes in some surface Dirichlet data fbplus, and returns the solutions f and s (filtered).","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"function ImmersedLayers.solve(fbplus,prob::DirichletPoissonProblem,sys::ILMSystem)\n    @unpack extra_cache, base_cache = sys\n    @unpack S, C, fb, fstar = extra_cache\n\n    f = zeros_grid(base_cache)\n    s = zeros_surface(base_cache)\n\n    surface_divergence!(fstar,fbplus,base_cache)\n    fb .= 0.5*fbplus\n\n    inverse_laplacian!(fstar,base_cache)\n\n    interpolate!(s,fstar,base_cache)\n    s .= fb - s\n    s .= -(S\\s);\n\n    regularize!(f,s,base_cache)\n    inverse_laplacian!(f,base_cache)\n    f .+= fstar;\n\n    return f, C^6*s\nend","category":"page"},{"location":"manual/problems/#Set-up-the-grid,-shape,-and-cache","page":"Problems and the system","title":"Set up the grid, shape, and cache","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"We do this just as we did in Immersed layer caches, but now we don't create a cache, since it will be done internally.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Δx = 0.01\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ngrid = PhysicalGrid(xlim,ylim,Δx)\nRadC = 1.0\nΔs = 1.4*cellsize(grid)\nbody = Circle(RadC,Δs)","category":"page"},{"location":"manual/problems/#Do-the-work","page":"Problems and the system","title":"Do the work","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"We do this in three steps:","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Create the problem instance\nCall __init to create the caches, assembled into a system\nCall solve to solve the problem.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Also, note that pretty much any function that accepts base_cache as an argument also accepts sys.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"prob = DirichletPoissonProblem(grid,body,scaling=GridScaling)\nsys = ImmersedLayers.__init(prob)\n\npts = points(sys)\nf, s = solve(pts.u,prob,sys)\n\nplot(f,sys)","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"plot(s)","category":"page"},{"location":"manual/problems/#Problem-types-and-functions","page":"Problems and the system","title":"Problem types and functions","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"AbstractScalarILMProblem\nAbstractVectorILMProblem\nBasicScalarILMProblem\nBasicVectorILMProblem\nprob_cache","category":"page"},{"location":"manual/problems/#ImmersedLayers.AbstractScalarILMProblem","page":"Problems and the system","title":"ImmersedLayers.AbstractScalarILMProblem","text":"abstract type AbstractScalarILMProblem{DT, ST} <: ImmersedLayers.AbstractILMProblem{DT, ST}\n\nWhen defining a problem type with scalar data, make it a subtype of this.\n\n\n\n\n\n","category":"type"},{"location":"manual/problems/#ImmersedLayers.AbstractVectorILMProblem","page":"Problems and the system","title":"ImmersedLayers.AbstractVectorILMProblem","text":"abstract type AbstractVectorILMProblem{DT, ST} <: ImmersedLayers.AbstractILMProblem{DT, ST}\n\nWhen defining a problem type with vector data, make it a subtype of this.\n\n\n\n\n\n","category":"type"},{"location":"manual/problems/#ImmersedLayers.BasicScalarILMProblem","page":"Problems and the system","title":"ImmersedLayers.BasicScalarILMProblem","text":"struct BasicScalarILMProblem{DT, ST} <: AbstractScalarILMProblem{DT, ST}\n\nGeneric problem type with scalar-type data. This type generates no extra cache.\n\n\n\n\n\n","category":"type"},{"location":"manual/problems/#ImmersedLayers.BasicVectorILMProblem","page":"Problems and the system","title":"ImmersedLayers.BasicVectorILMProblem","text":"struct BasicVectorILMProblem{DT, ST} <: AbstractVectorILMProblem{DT, ST}\n\nGeneric problem type with vector-type data. This type generates no extra cache.\n\n\n\n\n\n","category":"type"},{"location":"manual/problems/#ImmersedLayers.prob_cache","page":"Problems and the system","title":"ImmersedLayers.prob_cache","text":"prob_type(prob,base_cache::BasicILMCache)\n\nThis function is called by __init to generate a problem-specific extra cache. Extend this function in order to generate an extra cache for a user-defined problem type.\n\n\n\n\n\n","category":"function"},{"location":"manual/problems/#System-types-and-functions","page":"Problems and the system","title":"System types and functions","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"ILMSystem\n__init","category":"page"},{"location":"manual/problems/#ImmersedLayers.ILMSystem","page":"Problems and the system","title":"ImmersedLayers.ILMSystem","text":"struct ILMSystem{PT, BCT<:BasicILMCache, ECT<:Union{Nothing, AbstractExtraILMCache}}\n\nA system of operators and caches for immersed layer problems. This is constructed by __init\n\n\n\n\n\n","category":"type"},{"location":"manual/problems/#ImmersedLayers.__init","page":"Problems and the system","title":"ImmersedLayers.__init","text":"__init(prob::AbstractILMProblem)\n\nInitialize ILMSystem with the given problem prob specification. Depending on the type of problem, this sets up a base cache of scalar or vector type, as well as an optional extra cache\n\n\n\n\n\n","category":"function"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"EditURL = \"<unknown>/literate/surfaceops.jl\"","category":"page"},{"location":"manual/surfaceops/#Surface-grid-operations","page":"Surface-grid operations","title":"Surface-grid operations","text":"","category":"section"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Here, we will discuss the various surface-grid operators available in the package. We will start by generating the cache, just as we did in Immersed layer caches","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"using ImmersedLayers\nusing CartesianGrids\nusing RigidBodyTools\nusing Plots\nusing LinearAlgebra","category":"page"},{"location":"manual/surfaceops/#Set-up-the-grid,-shape,-and-cache","page":"Surface-grid operations","title":"Set up the grid, shape, and cache","text":"","category":"section"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"We do this just as we did in Immersed layer caches","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Δx = 0.01\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ngrid = PhysicalGrid(xlim,ylim,Δx)\nRadC = 1.0\nΔs = 1.4*cellsize(grid)\nbody = Circle(RadC,Δs)\ncache = SurfaceScalarCache(body,grid,scaling=GridScaling)","category":"page"},{"location":"manual/surfaceops/#Basic-regularization-and-interpolation","page":"Surface-grid operations","title":"Basic regularization and interpolation","text":"","category":"section"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Let's perform an example in which we regularize the x coordinate of the surface points onto the grid. We can get the surface coordinates by using the points function. This can be applied either to body directly or to the cache. As for any VectorData type, the components of pts are pts.u and pts.v.","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"pts = points(cache);\nnothing #hide","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Now, we set up some blank grid data on which to regularize onto","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"gx = zeros_grid(cache);\nnothing #hide","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Now regularize. We will time it to show that it is fast and memory-efficient:","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"regularize!(gx,pts.u,cache) #hide\n@time regularize!(gx,pts.u,cache);\nnothing #hide","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Let's plot this to look at it. This also gives us a chance to highlight the plot recipe for grid data associated with the cache, which is achieved by simply supplying the cache to the plot function in Plots.jl.","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"plot(gx,cache)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"This shows how the regularization spreads the data over a couple of cells around the surface. In the parlance of potential theory, this is a single layer. If we wish to interpolate, then we do so with the [interpolate!] function. For example, suppose we have a uniform field that we wish to interpolate:","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"oc = 2.5*ones_grid(cache)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Now set up some surface data to receive the interpolated data, and interpolate:","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"f = zeros_surface(cache);\ninterpolate!(f,oc,cache)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"It is clear that the interpolation preserves the value of the field. This is also true for linearly varying fields, since the DDF is built to ensure this. Let's try this, using the x coordinate of the grid. Here, we use the coordinates function of CartesianGrids.jl, which gets the coordinates of the grid, and set the values of grid data to the x coordinate. We interpolate and plot, comparing to the actual x coordinate of the points on the body:","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"x, y = coordinates(oc,grid)\nxg = similar(oc)\nxg .= x\ninterpolate!(f,xg,cache)\nplot(f,ylim=(-2,2),label=\"Interpolated from grid\",ylabel=\"x\",xlabel=\"Index\")\nplot!(pts.u,label=\"Actual body coordinate\")","category":"page"},{"location":"manual/surfaceops/#A-double-layer","page":"Surface-grid operations","title":"A double layer","text":"","category":"section"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Now we will generate a double layer. Mathematically, this takes the form","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"D_s f = nablacdot left( delta(chi) mathbfn f right)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"for some scalar data f on the surface. (See Background for an example.) Notice that it maps scalar data on the surface (f) to scalar data in space. So to calculate this using our discrete tools, we set up some grid data to receive the result. Then, we use the function surface_divergence! to compute the double layer. Here, we will demonstrate this on the y coordinate of the surface points:","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"dl = zeros_grid(cache)\nsurface_divergence!(dl,pts.v,cache)\nplot(dl,cache)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"If the surface data are vectors, mathbff, then this operation is a little different:","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"D_s mathbff = nablacdot delta(chi) left(  mathbfn mathbff + mathbff mathbfn right)\n\nThis maps mathbff to a vector field We use this in conjunction with a cache\ngenerated with SurfaceVectorCache(ref)\n\nThe transpose of the double layer D_s is the operation\n\nG_s u = mathbfncdot delta^T(chi) nabla u","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"for some scalar field data u. This operation computes the gradient of the field data, interpolates this gradient onto the surface, and obtains the normal component of that surface data. As such, it represents an important tool for computing the normal derivative of field data on a surface. In the package, we use surface_grad! for this operation.","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"The vector field version of this is","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"G_s mathbfu = mathbfncdot delta^T(chi) (nabla mathbfu + nabla^T mathbfu)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"which maps vector field data mathbu to vector-valued surface data.","category":"page"},{"location":"manual/surfaceops/#A-curl-layer","page":"Surface-grid operations","title":"A curl layer","text":"","category":"section"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"We also sometimes need to take the curl of the regularized surface data,","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"C_s f = nablatimes left( delta(chi) mathbfn f right)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"For this, we use the surface_curl! operator. Let's demonstrate this on a uniform field on the surface.","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"gc = zeros_gridcurl(cache)\nf = ones_surface(cache)\nsurface_curl!(gc,f,cache)\nplot(gc,cache)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"The continuous version of this operation is actually zero. It's not quite zero in discrete form. However, its norm is much smaller than that of the double layer.","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"norm(gc,cache)/norm(dl,cache)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Finally, a pair of operations that are used in support of the previous ones, or occasionally on their own, are","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"R_n f = delta(chi)mathbfncirc f","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"for scalar surface data f, which maps to a vector field, effectively a field of doublet strengths; and its transpose","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"R_n^T mathbfu = mathbfncdot delta^T(chi)mathbfu","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"which maps vector field data mathbfu to a scalar surface field, the normal component of the vector field on the surface. These are provided by regularize_normal! and normal_interpolate!, respectively.","category":"page"},{"location":"manual/surfaceops/#Masks","page":"Surface-grid operations","title":"Masks","text":"","category":"section"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Masks are grid data that take the value 1 in one region (e.g., the interior of a surface) and 0 in the other (e.g., the exterior). The functions mask and complementary_mask achieve this","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"m = mask(cache)\ncm = complementary_mask(cache)\nplot(\n    surface(m,cache),\n    surface(cm,cache)\n    )","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"One can apply a mask to some grid data by multiplying it, using, e.g., the product! function in CartesianGrids.jl. Let's demonstrate that with the grid data of x coordinates:","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"xmask = zeros_grid(cache)\nxcmask = zeros_grid(cache)\nproduct!(xmask,xg,m)\nproduct!(xcmask,xg,cm)\nplot(\n  plot(xmask,cache),\n  plot(xcmask,cache)\n  )","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"The mask and complementary mask effectively partition the field into two parts. We can also apply masks in place, using mask! and complementary_mask!:","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"xmask .= xg\nmask!(xmask,cache)\nplot(xmask,cache)","category":"page"},{"location":"manual/surfaceops/#Surface-grid-operator-functions","page":"Surface-grid operations","title":"Surface-grid operator functions","text":"","category":"section"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"regularize!\ninterpolate!\nregularize_normal!\nnormal_interpolate!\nsurface_divergence!\nsurface_grad!\nsurface_curl!\nmask!\nmask\ncomplementary_mask!\ncomplementary_mask","category":"page"},{"location":"manual/surfaceops/#ImmersedLayers.regularize!","page":"Surface-grid operations","title":"ImmersedLayers.regularize!","text":"regularize!(s::Nodes{Primal},f::ScalarData,cache::BasicILMCache)\nregularize!(s::Nodes{Primal},f::ScalarData,sys::ILMSystem)\n\nThe operation s = R_c f, which regularizes scalar surface data f onto the grid in the form of scalar grid data s. This is the adjoint to interpolate!\n\n\n\n\n\nregularize!(v::Edges{Primal},vb::VectorData,cache::BasicILMCache)\nregularize!(v::Edges{Primal},vb::VectorData,sys::ILMSystem)\n\nThe operation v = R_f v_b, which regularizes vector surface data vb onto the grid in the form of scalar grid data v. This is the adjoint to interpolate!\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.interpolate!","page":"Surface-grid operations","title":"ImmersedLayers.interpolate!","text":"interpolate!(f::ScalarData,s::Nodes{Primal},cache::BasicILMCache)\ninterpolate!(f::ScalarData,s::Nodes{Primal},sys::ILMSystem)\n\nThe operation f = R_c^T s, which interpolates scalar grid data s onto the surface points in the form of scalar point data f. This is the adjoint to regularize!\n\n\n\n\n\ninterpolate!(vb::VectorData,v::Edges{Primal},cache::BasicILMCache)\ninterpolate!(vb::VectorData,v::Edges{Primal},sys::ILMSystem)\n\nThe operation v_b = R_c^T v, which interpolates vector grid data v onto the surface points in the form of scalar point data vb. This is the adjoint to regularize!\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.regularize_normal!","page":"Surface-grid operations","title":"ImmersedLayers.regularize_normal!","text":"regularize_normal!(q::Edges{Primal},f::ScalarData,cache::BasicILMCache)\nregularize_normal!(q::Edges{Primal},f::ScalarData,sys::ILMSystem)\n\nThe operation q = R_f ncirc f, which maps scalar surface data f (like a jump in scalar potential) to grid data q (like velocity). This is the adjoint to normal_interpolate!.\n\n\n\n\n\nregularize_normal!(qt::EdgeGradient{Primal},v::VectorData,cache::BasicILMCache)\nregularize_normal!(qt::EdgeGradient{Primal},v::VectorData,sys::ILMSystem)\n\nThe operation q_t = R_t ncirc v, which maps scalar vector data v (like a jump in velocity) to grid data qt (like velocity-normal tensor). This is the adjoint to normal_interpolate!.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.normal_interpolate!","page":"Surface-grid operations","title":"ImmersedLayers.normal_interpolate!","text":"normal_interpolate!(vn::ScalarData,q::Edges{Primal},cache::BasicILMCache)\nnormal_interpolate!(vn::ScalarData,q::Edges{Primal},sys::ILMSystem)\n\nThe operation v_n = n cdot R_f^T q, which maps grid data q (like velocity) to scalar surface data vn (like normal component of surface velocity). This is the adjoint to regularize_normal!.\n\n\n\n\n\nnormal_interpolate!(τ::VectorData,A::EdgeGradient{Primal},cache::BasicILMCache)\nnormal_interpolate!(τ::VectorData,A::EdgeGradient{Primal},sys::ILMSystem)\n\nThe operation tau = n cdot R_t^T (A + A^T), which maps grid tensor data A (like velocity gradient tensor) to vector surface data τ (like traction). This is the adjoint to regularize_normal!.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.surface_divergence!","page":"Surface-grid operations","title":"ImmersedLayers.surface_divergence!","text":"surface_divergence!(Θ::Nodes{Primal},f::ScalarData,cache::BasicILMCache)\nsurface_divergence!(Θ::Nodes{Primal},f::ScalarData,sys::ILMSystem)\n\nThe operation theta = D_s f = D R_f n circ f, which maps surface scalar data f (like jump in scalar potential) to grid data Θ (like dilatation, i.e. divergence of velocity). This is the adjoint of surface_grad!. Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\nsurface_divergence!(v::Edges{Primal},dv::VectorData,cache::BasicILMCache)\nsurface_divergence!(v::Edges{Primal},dv::VectorData,sys::ILMSystem)\n\nThe operation v = D_s dv = D R_f (n circ dv + dv circ n), which maps surface vector data dv (like jump in velocity) to grid data v (like velocity). This is the adjoint of surface_grad!. Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.surface_grad!","page":"Surface-grid operations","title":"ImmersedLayers.surface_grad!","text":"surface_grad!(vn::ScalarData,ϕ::Nodes{Primal},cache::BasicILMCache)\nsurface_grad!(vn::ScalarData,ϕ::Nodes{Primal},sys::ILMSystem)\n\nThe operation v_n = G_sphi = n cdot R_f^T Gphi, which maps grid data ϕ (like scalar potential) to scalar surface data (like normal component of velocity). This is the adjoint of surface_divergence!. Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\nsurface_grad!(τ::VectorData,v::Edges{Primal},cache::BasicILMCache)\nsurface_grad!(τ::VectorData,v::Edges{Primal},sys::ILMSystem)\n\nThe operation tau = G_s v = n cdot R_t^T (G v + (G v)^T), which maps grid vector data v (like velocity) to vector surface data τ (like traction). This is the adjoint of surface_divergence!. Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.surface_curl!","page":"Surface-grid operations","title":"ImmersedLayers.surface_curl!","text":"surface_curl!(w::Nodes{Dual},f::ScalarData,cache::BasicILMCache)\nsurface_curl!(w::Nodes{Dual},f::ScalarData,sys::ILMSystem)\n\nThe operation w = C_s^T f = C^T R_f ncirc f, which maps scalar surface data f (like a jump in scalar potential) to grid data w (like vorticity). This is the adjoint to C_s, also given by surface_curl! (but with arguments switched). Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\nsurface_curl!(vn::ScalarData,s::Nodes{Dual},cache::BasicILMCache)\nsurface_curl!(vn::ScalarData,s::Nodes{Dual},sys::ILMSystem)\n\nThe operation v_n = C_s s = n cdot R_f^T C s, which maps grid data s (like streamfunction) to scalar surface data vn (like normal component of velocity). This is the adjoint to C_s^T, also given by surface_curl!, but with arguments switched.  Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.mask!","page":"Surface-grid operations","title":"ImmersedLayers.mask!","text":"mask!(w::GridData,cache::BasicILMCache)\nmask!(w::GridData,sys::ILMSystem)\n\nMask the data w in place by multiplying it by 1s inside of a surface (i.e., on a side opposite   the normal vectors) and 0s outside. The grid data w must be of the same type as the   output data type of cache. Only allows cache to have GridScaling.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.mask","page":"Surface-grid operations","title":"ImmersedLayers.mask","text":"mask(cache::BasicILMCache) -> GridData\nmask(sys::ILMSystem) -> GridData\n\nCreate grid data that consist of 1s inside of a surface (i.e., on a side opposite   the normal vectors) and 0s outside. The grid data are the same type as the   output data type of sys.  Only allows sys to have GridScaling.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.complementary_mask!","page":"Surface-grid operations","title":"ImmersedLayers.complementary_mask!","text":"complementary_mask!(w::GridData,cache::BasicILMCache)\ncomplementary_mask!(w::GridData,sys::ILMSystem)\n\nMask the data w in place by multiplying it by 0s inside of a surface (i.e., on a side opposite   the normal vectors) and 1s outside. The grid data w must be of the same type as the   output data type of cache. Only allows cache to have GridScaling.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.complementary_mask","page":"Surface-grid operations","title":"ImmersedLayers.complementary_mask","text":"complementary_mask(cache::BasicILMCache) -> GridData\ncomplementary_mask(sys::ILMSystem) -> GridData\n\nCreate grid data that consist of 0s inside of a surface (i.e., on a side opposite   the normal vectors) and 1s outside. The grid data are the same type as the   output data type of cache.  Only allows cache to have GridScaling.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"EditURL = \"<unknown>/literate/dirichlet.jl\"","category":"page"},{"location":"manual/dirichlet/#A-Dirichlet-Poisson-problem","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"","category":"section"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Now, let's put together a lot of the tools we've discussed earlier to solve a standard problem: the solution of Laplace's equation, with Dirichlet boundary conditions on a surface. Our objective is to solve this problem with one Dirichlet value for the region external to the surface, and another Dirichlet value internal to the surface.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"To be specific, our problem is","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"nabla^2varphi^+ = 0qquad nabla^2varphi^- = 0","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"where + denotes the exterior and - the interior of the surface. (We will consider a circle of radius 1.) The boundary conditions on this surface are","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"varphi^+ = x qquad varphi^- = 0","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"In other words, we seek to set the value on the exterior to the local x coordinate of the surface, while the interior should have zero field.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Discretizing this problem by the techniques developed in [1], we seek to solve","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"beginbmatrix L  R  R^T  0 endbmatrix beginpmatrix f  -s endpmatrix = beginpmatrix D_s d  overlinef_b endpmatrix","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"where overlinef_b = (f^+_b + f^-_b)2 = x2 and d = f^+_b - f^-_b = x.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"This saddle-point problem can be solved by block-LU decomposition. First solve","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"L f^* = D_s d","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"for f^*. Then solve","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"R^TL^-1R s = overlinef_b - R^T f^*","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"for s, and finally, compute","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"f = f^* + L^-1R s","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"We will demonstrate these steps here.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"using ImmersedLayers\nusing CartesianGrids\nusing RigidBodyTools\nusing Plots\nusing LinearAlgebra","category":"page"},{"location":"manual/dirichlet/#Set-up-the-grid,-shape,-and-cache","page":"A Dirichlet Poisson problem","title":"Set up the grid, shape, and cache","text":"","category":"section"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"We do this just as we did in Immersed layer caches","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Δx = 0.01\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ngrid = PhysicalGrid(xlim,ylim,Δx)\nRadC = 1.0\nΔs = 1.4*cellsize(grid)\nbody = Circle(RadC,Δs)\ncache = SurfaceScalarCache(body,grid,scaling=GridScaling);\nnothing #hide","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Let's set up the right-hand side values, D_s d and overlinef_b. We will use fstar as a placeholder for the right-hand side of the upper equations.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"pts = points(cache)\nx = zeros_surface(cache)\nfb = zeros_surface(cache)\nfstar = zeros_grid(cache)\nx .= pts.u\nsurface_divergence!(fstar,x,cache)\nfb .= 0.5*x;\nnothing #hide","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"First step in the algorithm, find f^*","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"inverse_laplacian!(fstar,cache);\nnothing #hide","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Now, generate the Schur complement matrix, S = -R^TL^-1R, using create_RTLinvR,","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"S = create_RTLinvR(cache);\nnothing #hide","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Now we set up the right-hand side of the Schur complement system, and solve for the Lagrange multipliers, s. We will use s as a placeholder for the right-hand side, first holding R^T f^*, then overlinef_b - R^T f^*, and finally, the solution of - S s = overlinef_b - R^T f^*.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"s = zeros_surface(cache)\ninterpolate!(s,fstar,cache)\ns .= fb - s\ns .= -(S\\s);\nnothing #hide","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Finally, correct f^* with L^-1Rs","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"f = zeros_grid(cache)\nregularize!(f,s,cache)\ninverse_laplacian!(f,cache)\nf .+= fstar;\nnothing #hide","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Now, let's look at the resulting field","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"plot(f,cache)","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"We can see that the field external to the circle has the expected behavior, and the solution inside the circle is blank, indicating it is zero.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Let's also plot the solution for s on the surface. We will plot the 'raw' result, which is rather noisy, and also apply the filtering matrix C = tildeR^T R several times to smooth it out.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"C = create_surface_filter(cache)\nplot(s,label=\"Original solution\")\nplot!(C^5*s,label=\"Filtered solution\")","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"[1]: Eldredge, J. D. (2021) \"A method of immersed layers on Cartesian grids, with application to incompressible flows,\" arXiv:2103.04521.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"EditURL = \"<unknown>/literate/matrices.jl\"","category":"page"},{"location":"manual/matrices/#Matrix-operators","page":"Matrix operators","title":"Matrix operators","text":"","category":"section"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"Many solutions of partial differential equations with immersed layers, particularly Poisson problems, lead to saddle-point problems, in which the Schur complement operator is a matrix composed from some of the surface-grid operators discussed in Surface-grid operations. The package provides some convenience tools for constructing these matrices. By their nature, the construction of these matrices is slow, since each column involves the application of the same set of operations. However, the point of this construction is to do it once and store it for repeated application.","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"One common saddle point system is","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"A = beginbmatrix L  R  R^T  0 endbmatrix","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"where L is the discrete Laplacian and R and R^T are the regularization and interpolation operators (regularize! and interpolate!), respectively. This system arises in the solution of the Poisson equation with Dirichlet boundary conditions on the immersed surface. The Schur complement of this is S = - R^T L^-1 R. This matrix can be obtained using the function create_RTLinvR.","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"Another common saddle point system is","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"A = beginbmatrix L  D_s  G_s  R_n^T R_n endbmatrix","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"where D_s and G_s are the surface divergence and gradient operators (surface_divergence! and surface_grad!), respectively, and R_n and R_n^T are regularize_normal! and normal_interpolate!. This system arises in the solution of the Poisson equation with Neumann boundary conditions on the immersed surface. The Schur complement of this is S = R_n^T R_n - G_s L^-1 D_s. Each of the matrices in this are individually provided by the package, by the functions create_nRTRn and create_GLinvD, respectively. However, it is useful to know that the sum of these two matrices is exactly the matrix C_s L^-1C_s^T, where C_s and C_s^T are surface curl operators surface_curl!. This complete matrix is provided by create_CLinvCT.","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"Another helpful matrix operator is the surface filter, given by","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"tildeR^T R","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"where tildeR^T is a modified form of the interpolation operator, designed to return the regularized field to the surface points while maintaining the integral value of the original field [1]. We can obtain this matrix with create_surface_filter.","category":"page"},{"location":"manual/matrices/#Matrix-construction-functions","page":"Matrix operators","title":"Matrix construction functions","text":"","category":"section"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"create_RTLinvR\ncreate_CLinvCT\ncreate_GLinvD\ncreate_nRTRn\ncreate_surface_filter","category":"page"},{"location":"manual/matrices/#ImmersedLayers.create_RTLinvR","page":"Matrix operators","title":"ImmersedLayers.create_RTLinvR","text":"create_RTLinvR(cache::BasicILMCache[;scale=1.0])\n\nUsing the provided cache cache, construct the square matrix -R^T L^-1R, which maps data of type ScalarData to data of the same type. The operators R^T and R correspond to interpolate! and regularize! and L^{-1} is the inverse of the grid Laplacian. The optional keyword scale multiplies the matrix by the designated value.\n\n\n\n\n\n","category":"function"},{"location":"manual/matrices/#ImmersedLayers.create_CLinvCT","page":"Matrix operators","title":"ImmersedLayers.create_CLinvCT","text":"create_CLinvCT(cache::BasicILMCache[;scale=1.0])\n\nUsing the provided cache cache, construct the square matrix C_s L^-1C_s^T, which maps data of type ScalarData to data of the same type. The operators C_s and C_s^T correspond to surface_curl! and L is the grid Laplacian. The optional keyword scale multiplies the matrix by the designated value.\n\n\n\n\n\n","category":"function"},{"location":"manual/matrices/#ImmersedLayers.create_GLinvD","page":"Matrix operators","title":"ImmersedLayers.create_GLinvD","text":"create_GLinvD(cache::BasicILMCache[;scale=1.0])\n\nUsing the provided cache cache, construct the square matrix -G_s L^-1D_s, which maps data of type ScalarData to data of the same type. The operators G_s and D_s correspond to surface_grad! and surface_divergence!, and L is the grid Laplacian. The optional keyword scale multiplies the matrix by the designated value.\n\n\n\n\n\n","category":"function"},{"location":"manual/matrices/#ImmersedLayers.create_nRTRn","page":"Matrix operators","title":"ImmersedLayers.create_nRTRn","text":"create_nRTRn(cache::BasicILMCache[;scale=1.0])\n\nUsing the provided cache cache, construct the square matrix ncdot R_f^T R_f n circ, which maps data of type ScalarData to data of the same type. The operators R_f^T and R_f correspond to the interpolation and regularization matrices. The optional keyword scale multiplies the matrix by the designated value.\n\n\n\n\n\n","category":"function"},{"location":"manual/matrices/#ImmersedLayers.create_surface_filter","page":"Matrix operators","title":"ImmersedLayers.create_surface_filter","text":"create_surface_filter(cache::BasicILMCache)\n\nCreate a surface filtering matrix operator tildeR^T R, where tildeR^T represents a modified version of the interpolation operator. The resulting matrix can be applied to surface data to filter out high-frequency components.\n\n\n\n\n\n","category":"function"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"[1]: Goza, A., et al., (2016) \"Accurate computation of surface stresses and forces with immersed boundary methods,\" J. Comput. Phys., 321, 860–873.","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"EditURL = \"<unknown>/literate/caches.jl\"","category":"page"},{"location":"manual/caches/#Immersed-layer-caches","page":"Immersed layer caches","title":"Immersed layer caches","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"This package uses precomputed caches to efficiently implement the immersed layer operators. The starting point for a cache is the specification of the (discretized) body shape and the grid. Let's use an example.","category":"page"},{"location":"manual/caches/#Setting-up-a-cache","page":"Immersed layer caches","title":"Setting up a cache","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"using ImmersedLayers\nusing CartesianGrids\nusing RigidBodyTools\nusing LinearAlgebra\nusing Plots","category":"page"},{"location":"manual/caches/#Set-up-a-grid","page":"Immersed layer caches","title":"Set up a grid","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"First, we will set up a grid for performing the operations. We use the PhysicalGrid constructor of the CartesianGrids.jl package to create this.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"Δx = 0.01\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ngrid = PhysicalGrid(xlim,ylim,Δx)","category":"page"},{"location":"manual/caches/#Set-the-shape","page":"Immersed layer caches","title":"Set the shape","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"Now let's set a shape to immerse into the grid. We will use a circle, but there are a variety of other shapes available. Many of these are in the RigidBodyTools.jl package. Note that we set the spacing between the points on this shape equal to 1.4 times the grid spacing. This is not critical, but it is generally best to set it to a value between 1 and 2.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"RadC = 1.0\nΔs = 1.4*cellsize(grid)\nbody = Circle(RadC,Δs)","category":"page"},{"location":"manual/caches/#Create-the-cache","page":"Immersed layer caches","title":"Create the cache","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"After setting the grid and the surface to immerse, the next step for using the immersed layer tools is to set up a surface cache. This allocates a set of data structures, as well as the critical regularization and interpolation operators that will get used.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"There are a few choices to make when setting this up","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"What kind of data (scalar or vector) are we dealing with?","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"We will demonstrate with scalar data, which means we use the SurfaceScalarCache function. For vector data, use SurfaceVectorCache.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"What type of scaling (grid or index) do we wish to apply to the operators?","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"Grid scaling, set with scaling = GridScaling, means that the various operators are scaled with the physical grid spacing and/or surface point spacing so that they approximate the continuous operators. This means that regularization and interpolation are transposes with respect to inner products that incorporate these physical spacings, rather than the usual linear algebra inner products. Also, differential operations on the grid are true approximations of their continuous counterparts. This choice of scaling is usually the best, and the dot operator is extended in this package to implement the physically- scaled inner products.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"On the other hand, scaling = IndexScaling does not scale these, but rather, uses pure differencing for the grid differential operators, and regularization is the simple matrix transpose of interpolation.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"What discrete Dirac delta function (DDF) do we wish to use?","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"This is specified with the ddftype = keyword argument. The default is CartesianGrids.Yang3 [1]. However, there are other choices, such as CartesianGrids.Roma, CartesianGrids.Goza, CartesianGrids.Witchhat, CartesianGrids.M3, CartesianGrids.M4prime.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"cache = SurfaceScalarCache(body,grid,scaling=GridScaling)","category":"page"},{"location":"manual/caches/#Some-basic-utilities","page":"Immersed layer caches","title":"Some basic utilities","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"We will see deeper uses of this cache in Surface-grid operations. However, for now we can learn how to get basic copies of the grid and surface data. For example, a copy of the grid data, all initialized to zero:","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"zeros_grid(cache)","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"or similarly on the surface","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"zeros_surface(cache)","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"We also might need to initialize data on the grid to accept the curl of a vector field. This is used in conjunction with surface_curl!, for example.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"zeros_gridcurl(cache)","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"If we want them initialized to unity, then use","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"ones_grid(cache)","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"and","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"ones_surface(cache)","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"To evaluate functions on the grid, it is useful to be able to fill grid data with the x and y coordinates. For this, we use","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"x_grid(cache)","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"y_grid(cache)","category":"page"},{"location":"manual/caches/#Norms-and-inner-products","page":"Immersed layer caches","title":"Norms and inner products","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"It is useful to compute norms and inner products on grid and surface data. These tools are easily accessible, e.g., dot(u,v,cache) and norm(u,cache), and they respect the scaling associated with the cache. For example, the following gives an approximation of the circumference of the circle:","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"os = ones_surface(cache)\ndot(os,os,cache)","category":"page"},{"location":"manual/caches/#Cache-types-and-constructors","page":"Immersed layer caches","title":"Cache types and constructors","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"BasicILMCache\nSurfaceScalarCache\nSurfaceVectorCache\nAbstractExtraILMCache","category":"page"},{"location":"manual/caches/#ImmersedLayers.BasicILMCache","page":"Immersed layer caches","title":"ImmersedLayers.BasicILMCache","text":"struct BasicILMCache{N, SCA<:AbstractScalingType, ND, PT<:CartesianGrids.VectorData, NT<:CartesianGrids.VectorData, DST<:CartesianGrids.ScalarData, REGT<:CartesianGrids.Regularize, RSNT<:CartesianGrids.RegularizationMatrix, ESNT<:CartesianGrids.InterpolationMatrix, RT<:CartesianGrids.RegularizationMatrix, ET<:CartesianGrids.InterpolationMatrix, LT<:CartesianGrids.Laplacian, GVT, GNT, GCT, SVT, SST}\n\nA cache of operators and storage data for use in surface operations. Constructed with SurfaceScalarCache or SurfaceVectorCache.\n\n\n\n\n\n","category":"type"},{"location":"manual/caches/#ImmersedLayers.SurfaceScalarCache","page":"Immersed layer caches","title":"ImmersedLayers.SurfaceScalarCache","text":"SurfaceScalarCache(g::PhysicalGrid[,scaling=IndexScaling])\n\nCreate a cache of type BasicILMCache with scalar grid data, using the grid specified in g, with no immersed points. The keyword scaling can be used to set the scaling in the operations. By default, it is set to IndexScaling which sets the differential operators to be only differencing operators. By using scaling = GridScaling, then the grid and  spacings are accounted for and differential operators are scaled by this spacing.\n\n\n\n\n\nSurfaceScalarCache(body::Body/BodyList,g::PhysicalGrid[,ddftype=CartesianGrids.Yang3][,scaling=IndexScaling])\n\nCreate a cache of type BasicILMCache, holding operators and storage data for use in immersed layer operations on scalar data. This is sometimes called from withinILMSystem rather than directly.\n\nThe body can be of type Body or BodyList. The keyword scaling can be used to set the scaling in the operations. By default, it is set to IndexScaling which sets the regularization and interpolation to be symmetric matrices (i.e., interpolation is the adjoint of regularization with   respect to a vector dot product), and the vector calculus operations on the grid   are simple differences. By using scaling = GridScaling, then the grid and   point spacings are accounted for. Interpolation and regularization are adjoints   with respect to inner products based on discretized surface and volume integrals,   and vector calculus operations are scaled by the grid spacing.\n\n\n\n\n\nSurfaceScalarCache(X::VectorData,A::ScalarData,nrm::VectorData,g::PhysicalGrid[,ddftype=CartesianGrids.Yang3][,scaling=IndexScaling])\n\nCreate a cache of type BasicILMCache, holding operators and storage data for use in immersed layer operations on scalar data. The X specifies the immersed point coordinates, A the element areas surrounding these points, and nrm the outward normals.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.SurfaceVectorCache","page":"Immersed layer caches","title":"ImmersedLayers.SurfaceVectorCache","text":"SurfaceVectorCache(g::PhysicalGrid[,scaling=IndexScaling])\n\nCreate a cache of type BasicILMCache with vector grid data, with no immersed points. See SurfaceScalarCache for details.\n\n\n\n\n\nSurfaceVectorCache(body::Body/BodyList,g::PhysicalGrid[,ddftype=CartesianGrids.Yang3][,scaling=IndexScaling])\n\nCreate a cache of type BasicILMCache, holding operators and storage data for use in immersed layer operations on vector data. See SurfaceScalarCache for details.\n\n\n\n\n\nSurfaceScalarCache(X::VectorData,A::ScalarData,nrm::VectorData,g::PhysicalGrid[,ddftype=CartesianGrids.Yang3][,scaling=IndexScaling])\n\nCreate a cache of type BasicILMCache, holding operators and storage data for use in immersed layer operations on vector data. See SurfaceScalarCache for details.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.AbstractExtraILMCache","page":"Immersed layer caches","title":"ImmersedLayers.AbstractExtraILMCache","text":"abstract type AbstractExtraILMCache\n\nWhen defining problem-specific cache, make it a subtype of this.\n\n\n\n\n\n","category":"type"},{"location":"manual/caches/#Utilities-for-creating-instances-of-data","page":"Immersed layer caches","title":"Utilities for creating instances of data","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"similar_grid\nsimilar_gridgrad\nsimilar_gridcurl\nsimilar_surface\nzeros_grid\nzeros_gridgrad\nzeros_gridcurl\nzeros_surface\nones_grid\nones_surface\nx_grid\ny_grid","category":"page"},{"location":"manual/caches/#ImmersedLayers.similar_grid","page":"Immersed layer caches","title":"ImmersedLayers.similar_grid","text":"similar_grid(::BasicILMCache)\n\nGet a similar copy of the basic grid data in the cache.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.similar_gridgrad","page":"Immersed layer caches","title":"ImmersedLayers.similar_gridgrad","text":"similar_gridgrad(::BasicILMCache)\n\nGet a similar copy of the gradient of the grid data in the cache.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.similar_gridcurl","page":"Immersed layer caches","title":"ImmersedLayers.similar_gridcurl","text":"similar_gridcurl(::BasicILMCache)\n\nGet a similar copy of the grid curl field data in the cache.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.similar_surface","page":"Immersed layer caches","title":"ImmersedLayers.similar_surface","text":"similar_surface(::BasicILMCache)\n\nGet a similar copy of the basic surface point data in the cache.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.zeros_grid","page":"Immersed layer caches","title":"ImmersedLayers.zeros_grid","text":"zeros_grid(::BasicILMCache)\n\nGet an instance of the basic grid data in the cache, with values set to zero.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.zeros_gridgrad","page":"Immersed layer caches","title":"ImmersedLayers.zeros_gridgrad","text":"zeros_gridgrad(::BasicILMCache)\n\nGet an instance of the gradient of the grid data in the cache, with values set to zero.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.zeros_gridcurl","page":"Immersed layer caches","title":"ImmersedLayers.zeros_gridcurl","text":"zeros_gridcurl(::BasicILMCache)\n\nGet an instance of the grid curl field data in the cache, with values set to zero.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.zeros_surface","page":"Immersed layer caches","title":"ImmersedLayers.zeros_surface","text":"zeros_surface(::BasicILMCache)\n\nGet an instance of the basic surface point data in the cache, with values set to zero.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.ones_grid","page":"Immersed layer caches","title":"ImmersedLayers.ones_grid","text":"ones_grid(::BasicILMCache)\n\nGet an instance of the basic grid data in the cache, with values set to one.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.ones_surface","page":"Immersed layer caches","title":"ImmersedLayers.ones_surface","text":"ones_surface(::BasicILMCache)\n\nGet an instance of the basic surface point data in the cache, with values set to one.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.x_grid","page":"Immersed layer caches","title":"ImmersedLayers.x_grid","text":"x_grid(::BasicILMCache)\n\nReturn basic grid data filled with the grid x coordinate\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.y_grid","page":"Immersed layer caches","title":"ImmersedLayers.y_grid","text":"y_grid(::BasicILMCache)\n\nReturn basic grid data filled with the grid y coordinate\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#Utilities-for-accessing-surface-information","page":"Immersed layer caches","title":"Utilities for accessing surface information","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"areas(::BasicILMCache)\nnormals(::BasicILMCache)\npoints(::BasicILMCache)","category":"page"},{"location":"manual/caches/#ImmersedLayers.areas-Tuple{BasicILMCache}","page":"Immersed layer caches","title":"ImmersedLayers.areas","text":"areas(cache::BasicILMCache)\n\nReturn the areas (as ScalarData) of the surface panels associated with cache\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#ImmersedLayers.normals-Tuple{BasicILMCache}","page":"Immersed layer caches","title":"ImmersedLayers.normals","text":"normals(cache::BasicILMCache)\n\nReturn the normals (as VectorData) of the surface points associated with cache\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#ImmersedLayers.points-Tuple{BasicILMCache}","page":"Immersed layer caches","title":"ImmersedLayers.points","text":"points(cache::BasicILMCache)\n\nReturn the coordinates (as VectorData) of the surface points associated with cache\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#Inner-products-and-norms","page":"Immersed layer caches","title":"Inner products and norms","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"dot(::GridData,::GridData,::BasicILMCache)\ndot(::PointData,::PointData,::BasicILMCache)\nnorm(::GridData,::BasicILMCache)\nnorm(::PointData,::BasicILMCache)","category":"page"},{"location":"manual/caches/#LinearAlgebra.dot-Tuple{CartesianGrids.GridData, CartesianGrids.GridData, BasicILMCache}","page":"Immersed layer caches","title":"LinearAlgebra.dot","text":"dot(u1::GridData,u2::GridData,cache::BasicILMCache)\n\nCalculate the inner product of grid data u1 and u2, using the scaling associated with cache.\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#LinearAlgebra.dot-Tuple{CartesianGrids.PointData, CartesianGrids.PointData, BasicILMCache}","page":"Immersed layer caches","title":"LinearAlgebra.dot","text":"dot(u1::PointData,u2::PointData,cache::BasicILMCache)\n\nCalculate the inner product of surface point data u1 and u2, using the scaling associated with cache.\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#LinearAlgebra.norm-Tuple{CartesianGrids.GridData, BasicILMCache}","page":"Immersed layer caches","title":"LinearAlgebra.norm","text":"norm(u::GridData,cache::BasicILMCache)\n\nCalculate the norm of grid data u, using the scaling associated with cache.\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#LinearAlgebra.norm-Tuple{CartesianGrids.PointData, BasicILMCache}","page":"Immersed layer caches","title":"LinearAlgebra.norm","text":"norm(u::PointData,cache::BasicILMCache)\n\nCalculate the norm of surface point data u, using the scaling associated with cache.\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"[1]: Yang, X., et al., (2009) \"A smoothing technique for discrete delta functions with application to immersed boundary method in moving boundary simulations,\" J. Comput. Phys., 228, 7821–7836.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#ImmersedLayers.jl","page":"Home","title":"ImmersedLayers.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"tools for immersing surfaces and their operations in Cartesian grids","category":"page"},{"location":"#Package-objective","page":"Home","title":"Package objective","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The objective of this package is to implement","category":"page"},{"location":"","page":"Home","title":"Home","text":"the tools for regularizing and interpolating data between discretely-represented surfaces and Cartesian grids\ndiscrete Heaviside functions that mask the regions interior or exterior of surfaces\ndiscrete differential operators that immerse surface data into the grid (i.e., \"layers\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"At this time, the package only implements these in two spatial dimensions. The operators and tools are described in detail in [1], but a summary is given below.","category":"page"},{"location":"#Background","page":"Home","title":"Background","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A lot of problems in physics involve surfaces and their interaction with fields in a higher-dimensional space. One way to facilitate this interaction is by \"immersing\" the surface data, as well as the associated operations on these data, into the higher-dimensional space, and similarly, allowing data in the higher-dimensional space to be restricted to the surface. Underlying these is the concept of a \"masked\" field, which takes a certain continuous form on one side of a surface and another form on the other side. A Heaviside function H can be used to write this mathematically [1]:","category":"page"},{"location":"","page":"Home","title":"Home","text":"f = H(chi) f^+ + H(-chi) f^-","category":"page"},{"location":"","page":"Home","title":"Home","text":"where chi is a level set function, taking a positive value on the + side of the surface and negative value on the - side. The chi=0 level set implicitly defines the surface. Also, the gradient of chi is proportional to the unit normal vector, mathbfn. In fact, we can always choose this function so that it is the local normal.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A really neat thing happens when we take a spatial derivative of f. For example, the gradient:","category":"page"},{"location":"","page":"Home","title":"Home","text":"nabla f = H(chi) nabla f^+ + H(-chi) nabla f^- + delta(chi)mathbfn(f^+ - f^-)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, we get a masked form of the gradient fields of f on either side, plus a term involving the jump in f across the surface, times the normal vector, times the Dirac delta function delta(chi). This last factor is the immersion operator: it immerses the surface jump in f into the higher-dimensional space. Other derivatives (e.g., curl, divergence of vector fields) lead to immersion similar terms. If we the divergence of the gradient above, we get a Poisson equation with two immersion terms:","category":"page"},{"location":"","page":"Home","title":"Home","text":"nabla^2 f = H(chi) nabla^2 f^+ + H(-chi) nabla^2 f^- + delta(chi)mathbfn cdot (nabla f^+ - nabla f^-) +  nabla cdot leftdelta(chi)mathbfn(f^+ - f^-) right","category":"page"},{"location":"","page":"Home","title":"Home","text":"The last two terms are single and double layers, in the language of the theory of potentials. Generically, in any partial differential equation, we refer to these terms as immersed layers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"So standard partial differential equations can be adapted for the masked fields, so that the equations are augmented with the surface quantities. Restriction, delta^T(chi), is the transpose of immersion. It arises when we wish to impose constraints on the surface behavior; we can instead apply this constraint to the restricted form of the masked field, e.g., setting it to a prescribed value, f_s, on the surface:","category":"page"},{"location":"","page":"Home","title":"Home","text":"delta^T(chi) f = f_s","category":"page"},{"location":"","page":"Home","title":"Home","text":"In a computational environment, we discretize the fields on both the surface as well as in the higher-dimensional space, so this immersion process involves regularization (the discrete form of immersion) and interpolation (the discrete form of restriction), defined with the help of a discrete version of the Dirac delta function, the \"DDF\". We discretize the higher-dimensional space with the a staggered Cartesian grid, using tools in the CartesianGrids.jl package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, to regularize surface scalar data to the cell centers of the grid, we use a matrix operator, R_c. Alternatively, for regularizing vector surface data to cell faces, we use R_f. Each of these has a transpose, used for interpolation of the grid data to the surface points, e.g, R_c^T.","category":"page"},{"location":"","page":"Home","title":"Home","text":"When we combine these operations with the standard differential operators on the grid, we get a powerful set of tools for numerically solving PDEs.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package works on Julia 1.4 and above and is registered in the general Julia registry. To install from the REPL, type e.g.,","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add ImmersedLayers","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, in any version, type","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using ImmersedLayers","category":"page"},{"location":"","page":"Home","title":"Home","text":"The plots in this documentation are generated using Plots.jl. You might want to install that, too, to follow the examples.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Eldredge, J. D. (2021) \"A method of immersed layers on Cartesian grids, with application to incompressible flows,\" arXiv:2103.04521.","category":"page"},{"location":"manual/utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"manual/utilities/","page":"Utilities","title":"Utilities","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/utilities/#Surface-point-utilities","page":"Utilities","title":"Surface point utilities","text":"","category":"section"},{"location":"manual/utilities/","page":"Utilities","title":"Utilities","text":"areas(::Body)\nnormals(::Body)\npoints(::Body)\ndot(::ScalarData{N},::ScalarData{N},::ScalarData{N}) where {N}\nnorm(::PointData{N},::ScalarData{N}) where {N}\nones(::ScalarData)","category":"page"},{"location":"manual/utilities/#ImmersedLayers.areas-Tuple{RigidBodyTools.Body}","page":"Utilities","title":"ImmersedLayers.areas","text":"areas(b::Body/BodyList)\n\nReturn ScalarData filled with the 1-d areas (via midpoint rule) associated with b.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#ImmersedLayers.normals-Tuple{RigidBodyTools.Body}","page":"Utilities","title":"ImmersedLayers.normals","text":"normals(b::Body/BodyList)\n\nReturn VectorData filled with the normal vectors (via midpoint rule) associated with b.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#ImmersedLayers.points-Tuple{RigidBodyTools.Body}","page":"Utilities","title":"ImmersedLayers.points","text":"points(b::Body/BodyList)\n\nReturn VectorData filled with the coordinates of the points associated with b.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#LinearAlgebra.dot-Union{Tuple{N}, Tuple{CartesianGrids.ScalarData{N, T, DT} where {T, DT<:(AbstractVector{T} where T)}, CartesianGrids.ScalarData{N, T, DT} where {T, DT<:(AbstractVector{T} where T)}, CartesianGrids.ScalarData{N, T, DT} where {T, DT<:(AbstractVector{T} where T)}}} where N","page":"Utilities","title":"LinearAlgebra.dot","text":"dot(u1::PointData,u2::PointData,ds::ScalarData)\n\nReturn the inner product between u1 and u2, weighted by ds.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#LinearAlgebra.norm-Union{Tuple{N}, Tuple{CartesianGrids.PointData{N, T} where T, CartesianGrids.ScalarData{N, T, DT} where {T, DT<:(AbstractVector{T} where T)}}} where N","page":"Utilities","title":"LinearAlgebra.norm","text":"norm(u::PointData,ds::ScalarData)\n\nReturn the norm of u, weighted by ds.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#Base.ones-Tuple{CartesianGrids.ScalarData}","page":"Utilities","title":"Base.ones","text":"ones(u::ScalarData)\n\nReturns ScalarData of the same type as u filled with ones.\n\n\n\n\n\nones(u::VectorData,dim::Int)\n\nReturns VectorData of the same type as u, filled with ones in component dim.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#Grid-utilities","page":"Utilities","title":"Grid utilities","text":"","category":"section"},{"location":"manual/utilities/","page":"Utilities","title":"Utilities","text":"dot(::GridData{NX,NY},::GridData{NX,NY},::PhysicalGrid) where {NX,NY}\nnorm(::GridData,::PhysicalGrid)","category":"page"},{"location":"manual/utilities/#LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{CartesianGrids.GridData{NX, NY, T} where T, CartesianGrids.GridData{NX, NY, T} where T, CartesianGrids.PhysicalGrid}} where {NX, NY}","page":"Utilities","title":"LinearAlgebra.dot","text":"dot(u1::GridData,u2::GridData,g::PhysicalGrid)\n\nReturn the inner product between u1 and u2 weighted by the volume (area) of the cell in grid g.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#LinearAlgebra.norm-Tuple{CartesianGrids.GridData, CartesianGrids.PhysicalGrid}","page":"Utilities","title":"LinearAlgebra.norm","text":"norm(u::GridData,g::PhysicalGrid)\n\nReturn the norm of u, weighted by the volume (area) of the cell in grid g.\n\n\n\n\n\n","category":"method"}]
}
