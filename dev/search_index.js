var documenterSearchIndex = {"docs":
[{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"EditURL = \"<unknown>/literate/multbodies.jl\"","category":"page"},{"location":"manual/multbodies/#Multiple-bodies","page":"Multiple bodies","title":"Multiple bodies","text":"","category":"section"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"Under the hood, the cache uses the concept of a Body (from the RigidBodyTools.jl package) to perform certain calculations, like normal vectors and surface panel areas, which may specialize depending on the type of body shape. Note that most immersed layer operations do not depend on whether there is one or more bodies; rather, they only depend on the discrete points, and their associated normals and areas. However, some post-processing operations, like surface integrals, do depend on distinguishing one body from another. For this reason, the cache stores points in a BodyList, and several operations can exploit this.","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"using ImmersedLayers\nusing Plots","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"For the demonstration, we use the same grid.","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"Δx = 0.01\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx)","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"We will create a 2 x 2 array of circles, each of radius 0.5, centered at (11), (1-1), (-11), (-1-1).","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"RadC = 0.5\nΔs = 1.4*cellsize(g)\nbody = Circle(RadC,Δs)","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"We set up the body list by pushing copies of the same body onto the list. (We use deepcopy to ensure that these are copies, rather than pointers to the same body.)","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"bl = BodyList()\npush!(bl,deepcopy(body))\npush!(bl,deepcopy(body))\npush!(bl,deepcopy(body))\npush!(bl,deepcopy(body))","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"Now we move them into position. We also use a RigidTransform for each, which we also assemble into a list. (The ! is for convenience, using Julia convention, to remind us that each transform operates in-place on the body.)","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"t1! = RigidTransform((1.0,1.0),0.0)\nt2! = RigidTransform((1.0,-1.0),0.0)\nt3! = RigidTransform((-1.0,1.0),0.0)\nt4! = RigidTransform((-1.0,-1.0),0.0)\ntl! = RigidTransformList([t1!,t2!,t3!,t4!])\nnothing #hide","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"Finally, we apply the transform. We can apply the transform list directly to the body list:","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"tl!(bl)","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"Now we can create the cache, and inspect it by plotting","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"cache = SurfaceScalarCache(bl,g,scaling=GridScaling)\nplot(cache,xlims=(-2,2),ylims=(-2,2))","category":"page"},{"location":"manual/multbodies/#Body-by-body-calculations","page":"Multiple bodies","title":"Body-by-body calculations","text":"","category":"section"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"We can now perform operations on data that exploit the division into distinct bodies. For example, let's compute the integral of mathbfxcdotmathbfn, for body 3. For any of the bodies, this integral should be approximately equal to the area enclosed by the body (or volume in 3-d), multiplied by 2 (or 3 in 3-d). For a circle of radius 12, this area is pi4, so we expect the result to be nearly pi2. We use the pointwise_dot operation in CartesianGrids.jl to perform the dot product at each point.","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"pts = points(cache)\nnrm = normals(cache)\nV3 = integrate(pointwise_dot(pts,nrm),cache,3)","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"We can also integrate VectorData over individual bodies, and the result is simply a vector with the integral in each coordinate direction. Let's demonstrate on another geometric integral, this time of (mathbfxcdotmathbfx)mathbfn, This integral, when divided by the enclosed area (volume) of the body, is equal to the centroid of the body. Let's demonstrate on body 3, which we expect to be centered at (-1,1)","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"Xc = integrate(pointwise_dot(pts,pts)∘nrm,cache,3)/V3","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"Other operations we can perform body-by-body are dot and norm","category":"page"},{"location":"manual/multbodies/#Copying-data-body-by-body","page":"Multiple bodies","title":"Copying data body by body","text":"","category":"section"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"It is common that we will want to assign values to surface data, one body at a time. For this, we can make use of an extension of the copyto! function. Let's see some examples. Suppose we wish to set the value of a surface scalar u to the x component of the normal vectors for points on body 3, but leave the values zero for all other bodies. Then we just do the following:","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"u = zeros_surface(cache)\ncopyto!(u,nrm.u,cache,3)\nnothing #hide","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"Let's plot the data to verify this worked","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"plot(u)","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"It is also possible to use copyto! to copy a vector of just the right size of the subarray associated with the body.","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"","category":"page"},{"location":"manual/multbodies/","page":"Multiple bodies","title":"Multiple bodies","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"EditURL = \"<unknown>/literate/dirichlet.jl\"","category":"page"},{"location":"manual/dirichlet/#A-Dirichlet-Poisson-problem","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"","category":"section"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Now, let's put together a lot of the tools we've discussed earlier to solve a standard problem: the solution of Laplace's equation, with Dirichlet boundary conditions on a surface. Our objective is to solve this problem with one Dirichlet value for the region external to the surface, and another Dirichlet value internal to the surface.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"To be specific, our problem is","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"nabla^2varphi^+ = 0qquad nabla^2varphi^- = 0","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"where + denotes the exterior and - the interior of the surface. (We will consider a circle of radius 1.) The boundary conditions on this surface are","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"varphi^+ = x qquad varphi^- = 0","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"In other words, we seek to set the value on the exterior to the local x coordinate of the surface, while the interior should have zero field.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Discretizing this problem by the techniques developed in [1], we seek to solve","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"beginbmatrix L  R  R^T  0 endbmatrix beginpmatrix f  -s endpmatrix = beginpmatrix D_s d  overlinef_b endpmatrix","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"where overlinef_b = (f^+_b + f^-_b)2 = x2 and d = f^+_b - f^-_b = x.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"This saddle-point problem can be solved by block-LU decomposition. First solve","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"L f^* = D_s d","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"for f^*. Then solve","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"R^TL^-1R s = overlinef_b - R^T f^*","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"for s, and finally, compute","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"f = f^* + L^-1R s","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"We will demonstrate these steps here.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"using ImmersedLayers\nusing Plots\nusing LinearAlgebra","category":"page"},{"location":"manual/dirichlet/#Set-up-the-grid,-shape,-and-cache","page":"A Dirichlet Poisson problem","title":"Set up the grid, shape, and cache","text":"","category":"section"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"We do this just as we did in Immersed layer caches","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Δx = 0.01\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx)\nRadC = 1.0\nΔs = 1.4*cellsize(g)\nbody = Circle(RadC,Δs)\ncache = SurfaceScalarCache(body,g,scaling=GridScaling);\nnothing #hide","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Let's set up the right-hand side values, D_s d and overlinef_b. We will use fstar as a placeholder for the right-hand side of the upper equations.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"pts = points(cache)\nx = zeros_surface(cache)\nfb = zeros_surface(cache)\nfstar = zeros_grid(cache)\nx .= pts.u\nsurface_divergence!(fstar,x,cache)\nfb .= 0.5*x;\nnothing #hide","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"First step in the algorithm, find f^*","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"inverse_laplacian!(fstar,cache);\nnothing #hide","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Now, generate the Schur complement matrix, S = -R^TL^-1R, using create_RTLinvR,","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"S = create_RTLinvR(cache);\nnothing #hide","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Now we set up the right-hand side of the Schur complement system, and solve for the Lagrange multipliers, s. We will use s as a placeholder for the right-hand side, first holding R^T f^*, then overlinef_b - R^T f^*, and finally, the solution of - S s = overlinef_b - R^T f^*.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"s = zeros_surface(cache)\ninterpolate!(s,fstar,cache)\ns .= fb - s\ns .= -(S\\s);\nnothing #hide","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Finally, correct f^* with L^-1Rs","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"f = zeros_grid(cache)\nregularize!(f,s,cache)\ninverse_laplacian!(f,cache)\nf .+= fstar;\nnothing #hide","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Now, let's look at the resulting field","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"plot(f,cache)","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"We can see that the field external to the circle has the expected behavior, and the solution inside the circle is blank, indicating it is zero.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"Let's also plot the solution for s on the surface. We will plot the 'raw' result, which is rather noisy, and also apply the filtering matrix C = tildeR^T R several times to smooth it out.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"C = create_surface_filter(cache)\nplot(s,label=\"Original solution\")\nplot!(C^5*s,label=\"Filtered solution\")","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"[1]: Eldredge, J. D. (2021) \"A method of immersed layers on Cartesian grids, with application to incompressible flows,\" arXiv:2103.04521.","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"","category":"page"},{"location":"manual/dirichlet/","page":"A Dirichlet Poisson problem","title":"A Dirichlet Poisson problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"EditURL = \"<unknown>/literate/neumann.jl\"","category":"page"},{"location":"manual/neumann/#A-Neumann-Poisson-problem","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"","category":"section"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"Here, we'll demonstrate a solution of Laplace's equation, with Neumann boundary conditions on a surface. Similar to the Dirichlet problem in A Dirichlet Poisson problem, we will solve the problem with one Neumann condition external to the surface, and another Neumann value internal to the surface.","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"Our underlying problem is still","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"nabla^2varphi^+ = 0qquad nabla^2varphi^- = 0","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"where + denotes the exterior and - the interior of the surface. (We will consider a circle of radius 1.) The boundary conditions on this surface are","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"mathbfncdotnablavarphi^+ = v^+_n qquad mathbfncdotnablavarphi^- = v^-_n","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"In other words, we seek to set the value on the exterior normal derivative to v_n of the local normal vector on the surface, while the interior should have zero normal derivative.","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"Discretizing this problem by the usual techniques, we seek to solve","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"beginbmatrix L  D_s  G_s  R_n^T R_n endbmatrix beginpmatrix f  -phi endpmatrix = beginpmatrix R v_n  overlinev_n endpmatrix","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"where overlinev_n = (v^+_n + v^-_n)2 and v_n = v^+_n - v^-_n. The resulting phi is f^+-f^-.","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"As with the Dirichlet problem, this saddle-point problem can be solved by block-LU decomposition. First solve","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"L f^* = R v_n","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"for f^*. Then solve","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"-S phi = overlinev_n - G_s f^*","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"for phi, where S = R_n^T R_n - G_s L^-1 D_s = -C_s L^-1C_s^T, and finally, compute","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"f = f^* + L^-1D_s phi","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"It should be remembered that, for any scalar potential field, there is a corresponding streamfunction psi that generates the same flow. We can get that field, as well, with only a little bit more effort:","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"S psi = C_s f^*","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"and then solve","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"L s = C_s^T phi - hatC_s^T psi","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":".","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"for the streamfunction s.","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"using ImmersedLayers\nusing Plots\nusing LinearAlgebra\nusing UnPack","category":"page"},{"location":"manual/neumann/#Set-up-the-extra-cache-and-solve-function","page":"A Neumann Poisson problem","title":"Set up the extra cache and solve function","text":"","category":"section"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"The problem type takes the usual basic form","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"struct NeumannPoissonProblem{DT,ST} <: AbstractScalarILMProblem{DT,ST}\n   g :: PhysicalGrid\n   bodies :: BodyList\n   NeumannPoissonProblem(g::PT,bodies::BodyList;ddftype=CartesianGrids.Yang3,scaling=IndexScaling) where {PT} = new{ddftype,scaling}(g,bodies)\n   NeumannPoissonProblem(g::PT,body::Body;ddftype=CartesianGrids.Yang3,scaling=IndexScaling) where {PT} = new{ddftype,scaling}(g,BodyList([body]))\nend","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"The extra cache holds additional intermediate data, as well as the Schur complement. We don't bother creating a filtering matrix here.","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"struct NeumannPoissonCache{SMT,DVT,VNT,FT,ST} <: AbstractExtraILMCache\n   S :: SMT\n   dvn :: DVT\n   vn :: VNT\n   fstar :: FT\n   sstar :: ST\nend","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"The function prob_cache, as before, constructs the operators and extra cache data structures","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"function ImmersedLayers.prob_cache(prob::NeumannPoissonProblem,base_cache::BasicILMCache)\n    S = create_CLinvCT(base_cache)\n    dvn = zeros_surface(base_cache)\n    vn = zeros_surface(base_cache)\n    fstar = zeros_grid(base_cache)\n    sstar = zeros_gridcurl(base_cache)\n    NeumannPoissonCache(S,dvn,vn,fstar,sstar)\nend\nnothing #hide","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"And finally, here's the steps we outlined above, used to extend the solve function","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"function ImmersedLayers.solve(vnplus,vnminus,prob::NeumannPoissonProblem,sys::ILMSystem)\n    @unpack extra_cache, base_cache = sys\n    @unpack S, dvn, vn, fstar, sstar = extra_cache\n\n    fill!(fstar,0.0)\n    fill!(sstar,0.0)\n\n    f = zeros_grid(base_cache)\n    s = zeros_gridcurl(base_cache)\n    df = zeros_surface(base_cache)\n    ds = zeros_surface(base_cache)\n\n    vn .= 0.5*(vnplus+vnminus)\n    dvn .= vnplus - vnminus\n\n    # Find the potential\n    regularize!(fstar,dvn,base_cache)\n    inverse_laplacian!(fstar,base_cache)\n\n    surface_grad!(df,fstar,base_cache)\n    df .= vn - df\n    df .= -(S\\df);\n\n    surface_divergence!(f,df,base_cache)\n    inverse_laplacian!(f,base_cache)\n    f .+= fstar\n\n    # Find the streamfunction\n    surface_curl!(sstar,df,base_cache)\n\n    surface_grad_cross!(ds,fstar,base_cache)\n    ds .= S\\ds\n\n    surface_curl_cross!(s,ds,base_cache)\n    s .-= sstar\n    s .*= -1.0\n\n    inverse_laplacian!(s,base_cache)\n\n    return f, df, s, ds\nend\nnothing #hide","category":"page"},{"location":"manual/neumann/#Solve-the-problem","page":"A Neumann Poisson problem","title":"Solve the problem","text":"","category":"section"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"Here, we will demonstrate the solution on a circular shape of radius 1, with v_n^+ = n_x and v_n^- = 0. This is actually the set of conditions used to compute the unit scalar potential field (and, as we will see, the added mass) in potential flow.","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"Set up the grid","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"Δx = 0.01\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx)\nΔs = 1.4*cellsize(g)\nbody = Circle(1.0,Δs);\nnothing #hide","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"Create the system","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"prob = NeumannPoissonProblem(g,body,scaling=GridScaling)\nsys = ImmersedLayers.__init(prob)\nnothing #hide","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"Set the boundary values","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"nrm = normals(sys)\nvnplus = zeros_surface(sys)\nvnminus = zeros_surface(sys)\nvnplus .= nrm.u\nnothing #hide","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"Solve it","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"solve(vnplus,vnminus,prob,sys) #hide\n@time f, df, s, ds = solve(vnplus,vnminus,prob,sys);\nnothing #hide","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"and plot the field","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"plot(plot(f,sys,layers=true,levels=30,title=\"ϕ\"),\nplot(s,sys,layers=true,levels=30,title=\"ψ\"))","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"and the Lagrange multiplier field, phi, on the surface","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"plot(df)","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"If, instead, we set the inner boundary condition to n_x and the outer to zero, then we get the flow inside of a translating circle","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"vnplus = zeros_surface(sys)\nvnminus = zeros_surface(sys)\nvnminus .= nrm.u\nf, df, s, ds = solve(vnplus,vnminus,prob,sys);\nplot(plot(f,sys,layers=true,levels=30,title=\"ϕ\"),\nplot(s,sys,layers=true,levels=30,title=\"ψ\"))","category":"page"},{"location":"manual/neumann/#Multiple-bodies","page":"A Neumann Poisson problem","title":"Multiple bodies","text":"","category":"section"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"The cache and solve function we created above can be applied for any body or set of bodies. Let's apply it here to a circle of radius 0.25 inside of a square of half-side length 2, where our goal is to find the effect of the enclosing square on the motion of the circle. As such, we will set the Neumann conditions both internal to and external to the square to be 0, but for the exterior of the circle, we set it to n_x.","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"bl = BodyList();\npush!(bl,Square(1.0,Δs))\npush!(bl,Circle(0.25,Δs))\nnothing #hide","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"We don't actually have to transform these shapes, but it is illustrative to show how we would move them.","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"t1 = RigidTransform((0.0,0.0),0.0)\nt2 = RigidTransform((0.0,0.0),0.0)\ntl = RigidTransformList([t1,t2])\ntl(bl)\nnothing #hide","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"Create the problem and system","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"prob = NeumannPoissonProblem(g,bl,scaling=GridScaling)\nsys = ImmersedLayers.__init(prob)\nnothing #hide","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"Set the boundary conditions. We set only the exterior Neumann value of body 2 (the circle), using copyto!","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"nrm = normals(sys)\nvnplus = zeros_surface(sys)\nvnminus = zeros_surface(sys)\ncopyto!(vnplus,nrm.u,sys,2)","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"Solve it and plot","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"f, df, s, ds  = solve(vnplus,vnminus,prob,sys)\nplot(plot(f,sys,layers=true,levels=30,title=\"ϕ\"),\nplot(s,sys,layers=true,levels=30,title=\"ψ\"))","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"Now, let's compute the added mass components of the circle associated with this motion. We are approximating","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"M = -int_C_2 f^+ mathbfnmathrmds","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"where C_2 is shape 2 (the circle), and f^+ is simply phi on body 2.","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"M = -integrate(df∘nrm,sys,2)","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"As one would expect, the circle has added mass in the x direction associated with moving in that direction.","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"","category":"page"},{"location":"manual/neumann/","page":"A Neumann Poisson problem","title":"A Neumann Poisson problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"manual/utilities/","page":"Utilities","title":"Utilities","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/utilities/#Surface-point-utilities","page":"Utilities","title":"Surface point utilities","text":"","category":"section"},{"location":"manual/utilities/","page":"Utilities","title":"Utilities","text":"areas(::Body)\nnormals(::Body)\npoints(::Body)\ndot(::ScalarData{N},::ScalarData{N},::ScalarData{N}) where {N}\nnorm(::PointData{N},::ScalarData{N}) where {N}\nintegrate(::ScalarData{N},::ScalarData{N}) where {N}\nones(::ScalarData)","category":"page"},{"location":"manual/utilities/#ImmersedLayers.areas-Tuple{Body}","page":"Utilities","title":"ImmersedLayers.areas","text":"areas(b::Body/BodyList)\n\nReturn ScalarData filled with the 1-d areas (via midpoint rule) associated with b.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#ImmersedLayers.normals-Tuple{Body}","page":"Utilities","title":"ImmersedLayers.normals","text":"normals(b::Body/BodyList)\n\nReturn VectorData filled with the normal vectors (via midpoint rule) associated with b.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#ImmersedLayers.points-Tuple{Body}","page":"Utilities","title":"ImmersedLayers.points","text":"points(b::Body/BodyList)\n\nReturn VectorData filled with the coordinates of the points associated with b.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#LinearAlgebra.dot-Union{Tuple{N}, Tuple{ScalarData{N, T, DT} where {T, DT<:(AbstractVector{T} where T)}, ScalarData{N, T, DT} where {T, DT<:(AbstractVector{T} where T)}, ScalarData{N, T, DT} where {T, DT<:(AbstractVector{T} where T)}}} where N","page":"Utilities","title":"LinearAlgebra.dot","text":"dot(u1::PointData,u2::PointData,ds::ScalarData)\n\nReturn the inner product between u1 and u2, weighted by ds.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#LinearAlgebra.norm-Union{Tuple{N}, Tuple{PointData{N, T} where T, ScalarData{N, T, DT} where {T, DT<:(AbstractVector{T} where T)}}} where N","page":"Utilities","title":"LinearAlgebra.norm","text":"norm(u::PointData,ds::ScalarData)\n\nReturn the norm of u, weighted by ds.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#CartesianGrids.integrate-Union{Tuple{N}, Tuple{ScalarData{N, T, DT} where {T, DT<:(AbstractVector{T} where T)}, ScalarData{N, T, DT} where {T, DT<:(AbstractVector{T} where T)}}} where N","page":"Utilities","title":"CartesianGrids.integrate","text":"integrate(u::PointData,ds::ScalarData)\n\nCalculate the discrete surface integral of data u, using the surface element areas in ds. This uses trapezoidal rule quadrature. If u is VectorData, then this returns a vector of the integrals in each coordinate direction.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#Base.ones-Tuple{ScalarData}","page":"Utilities","title":"Base.ones","text":"ones(u::ScalarData)\n\nReturns ScalarData of the same type as u filled with ones.\n\n\n\n\n\nones(u::VectorData,dim::Int)\n\nReturns VectorData of the same type as u, filled with ones in component dim.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#Surface-point-utilities-on-body-lists","page":"Utilities","title":"Surface point utilities on body lists","text":"","category":"section"},{"location":"manual/utilities/","page":"Utilities","title":"Utilities","text":"copyto!(::PointData,::PointData,::BodyList,::Int)\ncopyto!(::ScalarData,::AbstractVector,::BodyList,::Int)","category":"page"},{"location":"manual/utilities/#Base.copyto!-Tuple{PointData, PointData, BodyList, Int64}","page":"Utilities","title":"Base.copyto!","text":"copyto!(u::PointData,v::PointData,bl::BodyList,i::Int)\n\nCopy the data in the elements of v associated with body i in body list bl to the corresponding elements in u. These data must be of the same type (e.g., ScalarData or VectorData) and have the same length.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#Base.copyto!-Tuple{ScalarData, AbstractVector{T} where T, BodyList, Int64}","page":"Utilities","title":"Base.copyto!","text":"copyto!(u::ScalarData,v::AbstractVector,bl::BodyList,i::Int)\n\nCopy the data in v to the elements in u associated with body i in body list bl. v must have the same length as this subarray of u associated with i.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#Grid-utilities","page":"Utilities","title":"Grid utilities","text":"","category":"section"},{"location":"manual/utilities/","page":"Utilities","title":"Utilities","text":"dot(::GridData{NX,NY},::GridData{NX,NY},::PhysicalGrid) where {NX,NY}\nnorm(::GridData,::PhysicalGrid)","category":"page"},{"location":"manual/utilities/#LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{GridData{NX, NY, T} where T, GridData{NX, NY, T} where T, PhysicalGrid}} where {NX, NY}","page":"Utilities","title":"LinearAlgebra.dot","text":"dot(u1::GridData,u2::GridData,g::PhysicalGrid)\n\nReturn the inner product between u1 and u2 weighted by the volume (area) of the cell in grid g.\n\n\n\n\n\n","category":"method"},{"location":"manual/utilities/#LinearAlgebra.norm-Tuple{GridData, PhysicalGrid}","page":"Utilities","title":"LinearAlgebra.norm","text":"norm(u::GridData,g::PhysicalGrid)\n\nReturn the norm of u, weighted by the volume (area) of the cell in grid g.\n\n\n\n\n\n","category":"method"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"EditURL = \"<unknown>/literate/problems.jl\"","category":"page"},{"location":"manual/problems/#Problems-and-the-system","page":"Problems and the system","title":"Problems and the system","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"In specific problems that we wish to solve with immersed layers, there may be other data and operators that we would like to cache. We do this with an extra cache, which the user can define, along with a problem type associated with this cache. The basic cache and the extra cache are generated and associated together in a system.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"There are a few basic ingredients to do this:","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Create a problem type, making it a subtype of AbstractScalarILMProblem or AbstractVectorILMProblem. This mostly just serves as a means of dispatching correctly, but also should hold the grid and bodies so they can be passed along when the caches are constructed.\nCreate an extra cache type, making it a subtype of AbstractExtraILMCache. This can hold pretty much anything you want it to.\nExtend the function prob_cache(prob,base_cache) to serve as a constructor for your extra cache, when your problem type is passed in.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Optionally, you can also extend the function solve in order to perform the steps of your algorithm. However, generically, you can just use pass in the system structure, which holds the basic ILM cache and your extra cache, into any function.","category":"page"},{"location":"manual/problems/#Example-of-problem-and-system-use","page":"Problems and the system","title":"Example of problem and system use","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"We will demonstrate the use of problems and systems with the example given in A Dirichlet Poisson problem. Here, we will assemble the various additional data structures and operators used to solve this problem into an extra cache. We will also create a problem type called DirichletPoissonProblem, which we make a subtype of AbstractScalarILMProblem.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"using ImmersedLayers\nusing Plots\nusing UnPack","category":"page"},{"location":"manual/problems/#Create-your-problem-type","page":"Problems and the system","title":"Create your problem type","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"You can copy this as a template, because it Usually doesn't need to be any different from this.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"struct DirichletPoissonProblem{DT,ST} <: ImmersedLayers.AbstractScalarILMProblem{DT,ST}\n   g :: PhysicalGrid\n   bodies :: BodyList\n   DirichletPoissonProblem(g::PT,bodies::BodyList;ddftype=CartesianGrids.Yang3,scaling=IndexScaling) where {PT} = new{ddftype,scaling}(g,bodies)\n   DirichletPoissonProblem(g::PT,body::Body;ddftype=CartesianGrids.Yang3,scaling=IndexScaling) where {PT} = new{ddftype,scaling}(g,BodyList([body]))\nend","category":"page"},{"location":"manual/problems/#Create-your-extra-cache","page":"Problems and the system","title":"Create your extra cache","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Here, we'd like this extra cache to hold the Schur complement and the filtering matrices, as well as some cache variables.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"struct DirichletPoissonCache{SMT,CMT,ST,FT} <: ImmersedLayers.AbstractExtraILMCache\n   S :: SMT\n   C :: CMT\n   fb :: ST\n   fstar :: FT\nend","category":"page"},{"location":"manual/problems/#Extend-prob_cache","page":"Problems and the system","title":"Extend prob_cache","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"We need this to construct our extra cache","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"function ImmersedLayers.prob_cache(prob::DirichletPoissonProblem,base_cache::BasicILMCache)\n    S = create_RTLinvR(base_cache)\n    C = create_surface_filter(base_cache)\n    fb = zeros_surface(base_cache)\n    fstar = zeros_grid(base_cache)\n    DirichletPoissonCache(S,C,fb,fstar)\nend","category":"page"},{"location":"manual/problems/#Extend-the-solve-function","page":"Problems and the system","title":"Extend the solve function","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Here, we actually do the work of the algorithm, making use of all of the operators and data structures that we have cached for efficiency. The example below takes in some surface Dirichlet data fbplus, and returns the solutions f and s (filtered).","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"function ImmersedLayers.solve(fbplus,prob::DirichletPoissonProblem,sys::ILMSystem)\n    @unpack extra_cache, base_cache = sys\n    @unpack S, C, fb, fstar = extra_cache\n\n    f = zeros_grid(base_cache)\n    s = zeros_surface(base_cache)\n\n    surface_divergence!(fstar,fbplus,base_cache)\n    fb .= 0.5*fbplus\n\n    inverse_laplacian!(fstar,base_cache)\n\n    interpolate!(s,fstar,base_cache)\n    s .= fb - s\n    s .= -(S\\s);\n\n    regularize!(f,s,base_cache)\n    inverse_laplacian!(f,base_cache)\n    f .+= fstar;\n\n    return f, C^6*s\nend","category":"page"},{"location":"manual/problems/#Set-up-the-grid,-shape,-and-cache","page":"Problems and the system","title":"Set up the grid, shape, and cache","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"We do this just as we did in Immersed layer caches, but now we don't create a cache, since it will be done internally.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Δx = 0.01\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx)\nRadC = 1.0\nΔs = 1.4*cellsize(g)\nbody = Circle(RadC,Δs)","category":"page"},{"location":"manual/problems/#Do-the-work","page":"Problems and the system","title":"Do the work","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"We do this in three steps:","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Create the problem instance\nCall __init to create the caches, assembled into a system\nCall solve to solve the problem.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"Also, note that pretty much any function that accepts base_cache as an argument also accepts sys.","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"prob = DirichletPoissonProblem(g,body,scaling=GridScaling)\nsys = ImmersedLayers.__init(prob)\n\npts = points(sys)\nf, s = solve(pts.u,prob,sys)\n\nplot(f,sys)","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"plot(s)","category":"page"},{"location":"manual/problems/#Problem-types-and-functions","page":"Problems and the system","title":"Problem types and functions","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"AbstractScalarILMProblem\nAbstractVectorILMProblem\nBasicScalarILMProblem\nBasicVectorILMProblem\nprob_cache","category":"page"},{"location":"manual/problems/#ImmersedLayers.AbstractScalarILMProblem","page":"Problems and the system","title":"ImmersedLayers.AbstractScalarILMProblem","text":"abstract type AbstractScalarILMProblem{DT, ST} <: ImmersedLayers.AbstractILMProblem{DT, ST}\n\nWhen defining a problem type with scalar data, make it a subtype of this.\n\n\n\n\n\n","category":"type"},{"location":"manual/problems/#ImmersedLayers.AbstractVectorILMProblem","page":"Problems and the system","title":"ImmersedLayers.AbstractVectorILMProblem","text":"abstract type AbstractVectorILMProblem{DT, ST} <: ImmersedLayers.AbstractILMProblem{DT, ST}\n\nWhen defining a problem type with vector data, make it a subtype of this.\n\n\n\n\n\n","category":"type"},{"location":"manual/problems/#ImmersedLayers.BasicScalarILMProblem","page":"Problems and the system","title":"ImmersedLayers.BasicScalarILMProblem","text":"struct BasicScalarILMProblem{DT, ST} <: AbstractScalarILMProblem{DT, ST}\n\nGeneric problem type with scalar-type data. This type generates no extra cache.\n\n\n\n\n\n","category":"type"},{"location":"manual/problems/#ImmersedLayers.BasicVectorILMProblem","page":"Problems and the system","title":"ImmersedLayers.BasicVectorILMProblem","text":"struct BasicVectorILMProblem{DT, ST} <: AbstractVectorILMProblem{DT, ST}\n\nGeneric problem type with vector-type data. This type generates no extra cache.\n\n\n\n\n\n","category":"type"},{"location":"manual/problems/#ImmersedLayers.prob_cache","page":"Problems and the system","title":"ImmersedLayers.prob_cache","text":"prob_type(prob,base_cache::BasicILMCache)\n\nThis function is called by __init to generate a problem-specific extra cache. Extend this function in order to generate an extra cache for a user-defined problem type.\n\n\n\n\n\n","category":"function"},{"location":"manual/problems/#System-types-and-functions","page":"Problems and the system","title":"System types and functions","text":"","category":"section"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"ILMSystem\n__init","category":"page"},{"location":"manual/problems/#ImmersedLayers.ILMSystem","page":"Problems and the system","title":"ImmersedLayers.ILMSystem","text":"struct ILMSystem{PT, BCT<:BasicILMCache, ECT<:Union{Nothing, AbstractExtraILMCache}}\n\nA system of operators and caches for immersed layer problems. This is constructed by __init\n\n\n\n\n\n","category":"type"},{"location":"manual/problems/#ImmersedLayers.__init","page":"Problems and the system","title":"ImmersedLayers.__init","text":"__init(prob::AbstractILMProblem)\n\nInitialize ILMSystem with the given problem prob specification. Depending on the type of problem, this sets up a base cache of scalar or vector type, as well as an optional extra cache\n\n\n\n\n\n","category":"function"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"","category":"page"},{"location":"manual/problems/","page":"Problems and the system","title":"Problems and the system","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"EditURL = \"<unknown>/literate/matrices.jl\"","category":"page"},{"location":"manual/matrices/#Matrix-operators","page":"Matrix operators","title":"Matrix operators","text":"","category":"section"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"Many solutions of partial differential equations with immersed layers, particularly Poisson problems, lead to saddle-point problems, in which the Schur complement operator is a matrix composed from some of the surface-grid operators discussed in Surface-grid operations. The package provides some convenience tools for constructing these matrices. By their nature, the construction of these matrices is slow, since each column involves the application of the same set of operations. However, the point of this construction is to do it once and store it for repeated application.","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"One common saddle point system is","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"A = beginbmatrix L  R  R^T  0 endbmatrix","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"where L is the discrete Laplacian and R and R^T are the regularization and interpolation operators (regularize! and interpolate!), respectively. This system arises in the solution of the Poisson equation with Dirichlet boundary conditions on the immersed surface. The Schur complement of this is S = - R^T L^-1 R. This matrix can be obtained using the function create_RTLinvR.","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"Another common saddle point system is","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"A = beginbmatrix L  D_s  G_s  R_n^T R_n endbmatrix","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"where D_s and G_s are the surface divergence and gradient operators (surface_divergence! and surface_grad!), respectively, and R_n and R_n^T are regularize_normal! and normal_interpolate!. This system arises in the solution of the Poisson equation with Neumann boundary conditions on the immersed surface. The Schur complement of this is S = R_n^T R_n - G_s L^-1 D_s. Each of the matrices in this are individually provided by the package, by the functions create_nRTRn and create_GLinvD, respectively. However, it is useful to know that the sum of these two matrices is exactly the matrix -C_s L^-1C_s^T, where C_s and C_s^T are surface curl operators surface_curl!. This complete matrix is provided by create_CLinvCT.","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"Another helpful matrix operator is the surface filter, given by","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"tildeR^T R","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"where tildeR^T is a modified form of the interpolation operator, designed to return the regularized field to the surface points while maintaining the integral value of the original field [1]. We can obtain this matrix with create_surface_filter.","category":"page"},{"location":"manual/matrices/#Matrix-construction-functions","page":"Matrix operators","title":"Matrix construction functions","text":"","category":"section"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"create_RTLinvR\ncreate_CLinvCT\ncreate_CL2invCT\ncreate_GLinvD\ncreate_GLinvD_cross\ncreate_nRTRn\ncreate_surface_filter","category":"page"},{"location":"manual/matrices/#ImmersedLayers.create_RTLinvR","page":"Matrix operators","title":"ImmersedLayers.create_RTLinvR","text":"create_RTLinvR(cache::BasicILMCache[;scale=1.0])\n\nUsing the provided cache cache, construct the square matrix -R^T L^-1R, which maps data of type ScalarData to data of the same type. The operators R^T and R correspond to interpolate! and regularize! and L^{-1} is the inverse of the grid Laplacian. The optional keyword scale multiplies the matrix by the designated value.\n\n\n\n\n\n","category":"function"},{"location":"manual/matrices/#ImmersedLayers.create_CLinvCT","page":"Matrix operators","title":"ImmersedLayers.create_CLinvCT","text":"create_CLinvCT(cache::BasicILMCache[;scale=1.0])\n\nUsing the provided cache cache, construct the square matrix -C_s L^-1C_s^T, which maps data of the primary point data type of the cache to data of the same type. The operators C_s and C_s^T correspond to surface_curl! and L is the grid Laplacian. The optional keyword scale multiplies the matrix by the designated value.\n\n\n\n\n\n","category":"function"},{"location":"manual/matrices/#ImmersedLayers.create_CL2invCT","page":"Matrix operators","title":"ImmersedLayers.create_CL2invCT","text":"create_CL2invCT(cache::BasicILMCache[;scale=1.0])\n\nUsing the provided cache cache, construct the square matrix -C_s L^-2 C_s^T, which maps data of the primary point data type of the cache to data of the same type. The operators C_s and C_s^T correspond to surface_curl! and L is the grid Laplacian. The optional keyword scale multiplies the matrix by the designated value.\n\n\n\n\n\n","category":"function"},{"location":"manual/matrices/#ImmersedLayers.create_GLinvD","page":"Matrix operators","title":"ImmersedLayers.create_GLinvD","text":"create_GLinvD(cache::BasicILMCache[;scale=1.0])\n\nUsing the provided cache cache, construct the square matrix -G_s L^-1D_s, which maps data of type ScalarData to data of the same type. The operators G_s and D_s correspond to surface_grad! and surface_divergence!, and L is the grid Laplacian. The optional keyword scale multiplies the matrix by the designated value.\n\n\n\n\n\n","category":"function"},{"location":"manual/matrices/#ImmersedLayers.create_GLinvD_cross","page":"Matrix operators","title":"ImmersedLayers.create_GLinvD_cross","text":"create_GLinvD_cross(cache::BasicILMCache[;scale=1.0])\n\nUsing the provided cache cache, construct the square matrix -hatG_s L^-1hatD_s, which maps data of type ScalarData to data of the same type. The operators G_s and D_s correspond to surface_grad_cross! and surface_divergence_cross!, and L is the grid Laplacian. The optional keyword scale multiplies the matrix by the designated value.\n\n\n\n\n\n","category":"function"},{"location":"manual/matrices/#ImmersedLayers.create_nRTRn","page":"Matrix operators","title":"ImmersedLayers.create_nRTRn","text":"create_nRTRn(cache::BasicILMCache[;scale=1.0])\n\nUsing the provided cache cache, construct the square matrix ncdot R_f^T R_f n circ, which maps data of type ScalarData to data of the same type. The operators R_f^T and R_f correspond to the interpolation and regularization matrices. The optional keyword scale multiplies the matrix by the designated value.\n\n\n\n\n\n","category":"function"},{"location":"manual/matrices/#ImmersedLayers.create_surface_filter","page":"Matrix operators","title":"ImmersedLayers.create_surface_filter","text":"create_surface_filter(cache::BasicILMCache)\n\nCreate a surface filtering matrix operator tildeR^T R, where tildeR^T represents a modified version of the interpolation operator. The resulting matrix can be applied to surface data to filter out high-frequency components.\n\n\n\n\n\n","category":"function"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"[1]: Goza, A., et al., (2016) \"Accurate computation of surface stresses and forces with immersed boundary methods,\" J. Comput. Phys., 321, 860–873.","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"","category":"page"},{"location":"manual/matrices/","page":"Matrix operators","title":"Matrix operators","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"EditURL = \"<unknown>/literate/gridops.jl\"","category":"page"},{"location":"manual/gridops/#Grid-operations","page":"Grid operations","title":"Grid operations","text":"","category":"section"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"There are a variety of (purely) grid-based operators that are useful for carrying out calculations in immersed layer problems. We will demonstrate a few of them here. We will start by generating the cache, just as we did in Immersed layer caches","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"using ImmersedLayers\nusing CartesianGrids\nusing Plots","category":"page"},{"location":"manual/gridops/#Set-up-a-grid-and-cache","page":"Grid operations","title":"Set up a grid and cache","text":"","category":"section"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"Δx = 0.01\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx)","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"We still generate a cache for these operations, but now, we only supply the grid. There are no immersed surfaces for this demonstration.","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"cache = SurfaceScalarCache(g,scaling=GridScaling)","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"To demonstrate, let's generate a Gaussian","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"p = zeros_grid(cache)\nxg, yg = x_grid(cache), y_grid(cache)\np .= exp.(-(xg∘xg)-(yg∘yg))","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"Now, let's generate the gradient of these data","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"v = zeros_gridgrad(cache)\ngrad!(v,p,cache)\nplot(v,cache)","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"And finally, let's compute the convective derivative,","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"mathbfvcdotnablamathbfv","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"For this, we create a separate cache, using ConvectiveDerivativeCache, which can be constructed from the existing cache. This extra cache holds additional memory for making the calculation of the convective derivative faster. We will","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"cdcache = ConvectiveDerivativeCache(cache)\nvdv = zeros_gridgrad(cache)\nconvective_derivative!(vdv,v,cache,cdcache) #hide\n@time convective_derivative!(vdv,v,cache,cdcache)\nnothing #hide","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"Plot it","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"plot(vdv,cache)","category":"page"},{"location":"manual/gridops/#Surface-grid-operator-functions","page":"Grid operations","title":"Surface-grid operator functions","text":"","category":"section"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"divergence!\ngrad!\ncurl!\nconvective_derivative!\nconvective_derivative\nConvectiveDerivativeCache\ninverse_laplacian!","category":"page"},{"location":"manual/gridops/#CartesianGrids.divergence!","page":"Grid operations","title":"CartesianGrids.divergence!","text":"divergence!(p::Nodes{Primal},v::Edges{Primal},cache::BasicILMCache)\ndivergence!(p::Nodes{Primal},v::Edges{Primal},sys::ILMSystem)\n\nCompute the discrete divergence of v and return it in p, scaling it by the grid spacing if cache (or sys) is of GridScaling type, or leaving it as a simple differencing if cache (or sys) is of IndexScaling type.\n\n\n\n\n\n","category":"function"},{"location":"manual/gridops/#CartesianGrids.grad!","page":"Grid operations","title":"CartesianGrids.grad!","text":"grad!(v::Edges{Primal},p::Nodes{Primal},cache::BasicILMCache)\ngrad!(v::Edges{Primal},p::Nodes{Primal},sys::ILMSystem)\n\nCompute the discrete gradient of p and return it in v, scaling it by the grid spacing if cache (or sys) is of GridScaling type, or leaving it as a simple differencing if cache (or sys) is of IndexScaling type.\n\n\n\n\n\n","category":"function"},{"location":"manual/gridops/#CartesianGrids.curl!","page":"Grid operations","title":"CartesianGrids.curl!","text":"curl!(v::Edges{Primal},s::Nodes{Dual},cache::BasicILMCache)\ncurl!(v::Edges{Primal},s::Nodes{Dual},sys::ILMSystem)\n\nCompute the discrete curl of s and return it in v, scaling it by the grid spacing if cache (or sys) is of GridScaling type, or leaving it as a simple differencing if cache (or sys) is of IndexScaling type.\n\n\n\n\n\ncurl!(w::Nodes{Dual},v::Edges{Primal},cache::BasicILMCache)\ncurl!(w::Nodes{Dual},v::Edges{Primal},sys::ILMSystem)\n\nCompute the discrete curl of v and return it in w, scaling it by the grid spacing if cache (or sys) is of GridScaling type, or leaving it as a simple differencing if cache (or sys) is of IndexScaling type.\n\n\n\n\n\n","category":"function"},{"location":"manual/gridops/#CartesianGrids.convective_derivative!","page":"Grid operations","title":"CartesianGrids.convective_derivative!","text":"convective_derivative!(vdv::Edges,v::Edges,base_cache::BasicILMCache,extra_cache::ConvectiveDerivativeCache)\n\nCompute the convective derivative of v, i.e., vcdot nabla v, and return the result in vdv. The result is either divided by unity or the grid cell size depending on whether base_cache is of type IndexScaling or GridScaling. This version of the method uses extra_cache of type ConvectiveDerivativeCache.\n\n\n\n\n\n","category":"function"},{"location":"manual/gridops/#ImmersedLayers.convective_derivative","page":"Grid operations","title":"ImmersedLayers.convective_derivative","text":"convective_derivative(v::Edges,base_cache::BasicILMCache)\n\nCompute the convective derivative of v, i.e., vcdot nabla v. The result is either divided by unity or the grid cell size depending on whether base_cache is of type IndexScaling or GridScaling.\n\n\n\n\n\n","category":"function"},{"location":"manual/gridops/#ImmersedLayers.ConvectiveDerivativeCache","page":"Grid operations","title":"ImmersedLayers.ConvectiveDerivativeCache","text":"ConvectiveDerivativeCache(dv::EdgeGradient)\n\nCreate a cache (a subtype of AbstractExtraILMCache) for computing the convective derivative, using dv to define the cache data.\n\n\n\n\n\n","category":"type"},{"location":"manual/gridops/#ImmersedLayers.inverse_laplacian!","page":"Grid operations","title":"ImmersedLayers.inverse_laplacian!","text":"inverse_laplacian!(w::GridData,sys::ILMSystem)\n\nCompute the in-place inverse Laplacian of grid data w, and multiply the result by unity or by the grid cell size, depending on whether sys has IndexScaling or GridScaling, respectively.\n\n\n\n\n\ninverse_laplacian!(w::GridData,cache::BasicILMCache)\n\nCompute the in-place inverse Laplacian of grid data w, and multiply the result by unity or by the grid cell size, depending on whether cache has IndexScaling or GridScaling, respectively.\n\n\n\n\n\n","category":"function"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"","category":"page"},{"location":"manual/gridops/","page":"Grid operations","title":"Grid operations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"EditURL = \"<unknown>/literate/surfaceops.jl\"","category":"page"},{"location":"manual/surfaceops/#Surface-grid-operations","page":"Surface-grid operations","title":"Surface-grid operations","text":"","category":"section"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Here, we will discuss the various surface-grid operators available in the package. We will start by generating the cache, just as we did in Immersed layer caches","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"using ImmersedLayers\nusing Plots\nusing LinearAlgebra","category":"page"},{"location":"manual/surfaceops/#Set-up-the-grid,-shape,-and-cache","page":"Surface-grid operations","title":"Set up the grid, shape, and cache","text":"","category":"section"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"We do this just as we did in Immersed layer caches","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Δx = 0.01\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx)\nRadC = 1.0\nΔs = 1.4*cellsize(g)\nbody = Circle(RadC,Δs)\ncache = SurfaceScalarCache(body,g,scaling=GridScaling)","category":"page"},{"location":"manual/surfaceops/#Basic-regularization-and-interpolation","page":"Surface-grid operations","title":"Basic regularization and interpolation","text":"","category":"section"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Let's perform an example in which we regularize the x coordinate of the surface points onto the grid. We can get the surface coordinates by using the points function. This can be applied either to body directly or to the cache. As for any VectorData type, the components of pts are pts.u and pts.v.","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"pts = points(cache);\nnothing #hide","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Now, we set up some blank grid data on which to regularize onto","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"gx = zeros_grid(cache);\nnothing #hide","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Now regularize. We will time it to show that it is fast and memory-efficient:","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"regularize!(gx,pts.u,cache) #hide\n@time regularize!(gx,pts.u,cache);\nnothing #hide","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Let's plot this to look at it. This also gives us a chance to highlight the plot recipe for grid data associated with the cache, which is achieved by simply supplying the cache to the plot function in Plots.jl. By default, this plots the immersed points, as well, but this can be suppressed by adding the keyword layers=false.","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"plot(gx,cache)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"This shows how the regularization spreads the data over a couple of cells around the surface. In the parlance of potential theory, this is a single layer. If we wish to interpolate, then we do so with the [interpolate!] function. For example, suppose we have a uniform field that we wish to interpolate:","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"oc = 2.5*ones_grid(cache)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Now set up some surface data to receive the interpolated data, and interpolate:","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"f = zeros_surface(cache);\ninterpolate!(f,oc,cache)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"It is clear that the interpolation preserves the value of the field. This is also true for linearly varying fields, since the DDF is built to ensure this. Let's try this, using the x coordinate of the grid. Here, we use the coordinates function of CartesianGrids.jl, which gets the coordinates of the grid, and set the values of grid data to the x coordinate. We interpolate and plot, comparing to the actual x coordinate of the points on the body:","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"#x, y = coordinates(oc,g)\n#xg = similar(oc)\n#xg .= x\nxg = x_grid(cache)\ninterpolate!(f,xg,cache)\nplot(f,ylim=(-2,2),label=\"Interpolated from grid\",ylabel=\"x\",xlabel=\"Index\")\nplot!(pts.u,label=\"Actual body coordinate\")","category":"page"},{"location":"manual/surfaceops/#A-double-layer","page":"Surface-grid operations","title":"A double layer","text":"","category":"section"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Now we will generate a double layer. Mathematically, this takes the form","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"D_s f = nablacdot left( delta(chi) mathbfn f right)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"for some scalar data f on the surface. (See Background for an example.) Notice that it maps scalar data on the surface (f) to scalar data in space. So to calculate this using our discrete tools, we set up some grid data to receive the result. Then, we use the function surface_divergence! to compute the double layer. Here, we will demonstrate this on the y coordinate of the surface points:","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"dl = zeros_grid(cache)\nsurface_divergence!(dl,pts.v,cache)\nplot(dl,cache)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"If the surface data are vectors, mathbff, then this operation is a little different:","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"D_s mathbff = nablacdot delta(chi) left(  mathbfn mathbff + mathbff mathbfn right)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"This maps mathbff to a vector field. We use this in conjunction with a cache generated with SurfaceVectorCache.","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"The transpose of the double layer, D_s, is the operation","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"G_s u = mathbfncdot delta^T(chi) nabla u","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"for some scalar field data u. This operation computes the gradient of the field data, interpolates this gradient onto the surface, and obtains the normal component of that surface data. As such, it represents an important tool for computing the normal derivative of field data on a surface. In the package, we use surface_grad! for this operation.","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"The vector field version of this is","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"G_s mathbfu = mathbfncdot delta^T(chi) (nabla mathbfu + nabla^T mathbfu)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"which maps vector field data mathbfu to vector-valued surface data.","category":"page"},{"location":"manual/surfaceops/#A-curl-layer","page":"Surface-grid operations","title":"A curl layer","text":"","category":"section"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"We also sometimes need to take the curl of the regularized surface data,","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"C_s f = nablatimes left( delta(chi) mathbfn f right)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"For this, we use the surface_curl! operator. Let's demonstrate this on a uniform field on the surface.","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"gc = zeros_gridcurl(cache)\nf = ones_surface(cache)\nsurface_curl!(gc,f,cache)\nplot(gc,cache)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"The continuous version of this operation is actually zero. It's not quite zero in discrete form. However, its norm is much smaller than that of the double layer.","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"norm(gc,cache)/norm(dl,cache)","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Finally, a pair of operations that are used in support of the previous ones, or occasionally on their own, are","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"R_n f = delta(chi)mathbfncirc f","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"for scalar surface data f, which maps to a vector field, effectively a field of doublet strengths; and its transpose","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"R_n^T mathbfu = mathbfncdot delta^T(chi)mathbfu","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"which maps vector field data mathbfu to a scalar surface field, the normal component of the vector field on the surface. These are provided by regularize_normal! and normal_interpolate!, respectively.","category":"page"},{"location":"manual/surfaceops/#Masks","page":"Surface-grid operations","title":"Masks","text":"","category":"section"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"Masks are grid data that take the value 1 in one region (e.g., the interior of a surface) and 0 in the other (e.g., the exterior). The functions mask and complementary_mask achieve this","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"m = mask(cache)\ncm = complementary_mask(cache)\nplot(\n    surface(m,cache,layers=false),\n    surface(cm,cache,layers=false)\n    )","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"One can apply a mask to some grid data by multiplying it, using, e.g., the product! function in CartesianGrids.jl. Let's demonstrate that with the grid data of x coordinates:","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"xmask = zeros_grid(cache)\nxcmask = zeros_grid(cache)\nproduct!(xmask,xg,m)\nproduct!(xcmask,xg,cm)\nplot(\n  plot(xmask,cache),\n  plot(xcmask,cache)\n  )","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"The mask and complementary mask effectively partition the field into two parts. We can also apply masks in place, using mask! and complementary_mask!:","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"xmask .= xg\nmask!(xmask,cache)\nplot(xmask,cache)","category":"page"},{"location":"manual/surfaceops/#Surface-grid-operator-functions","page":"Surface-grid operations","title":"Surface-grid operator functions","text":"","category":"section"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"regularize!\ninterpolate!\nregularize_normal!\nnormal_interpolate!\nregularize_normal_cross!\nnormal_cross_interpolate!\nsurface_divergence!\nsurface_grad!\nsurface_curl!\nsurface_divergence_cross!\nsurface_grad_cross!\nsurface_curl_cross!\nmask!\nmask\ncomplementary_mask!\ncomplementary_mask","category":"page"},{"location":"manual/surfaceops/#ImmersedLayers.regularize!","page":"Surface-grid operations","title":"ImmersedLayers.regularize!","text":"regularize!(s::Nodes{Primal},f::ScalarData,cache::BasicILMCache)\nregularize!(s::Nodes{Primal},f::ScalarData,sys::ILMSystem)\n\nThe operation s = R_c f, which regularizes scalar surface data f onto the grid in the form of scalar grid data s. This is the adjoint to interpolate!\n\n\n\n\n\nregularize!(v::Edges{Primal},vb::VectorData,cache::BasicILMCache)\nregularize!(v::Edges{Primal},vb::VectorData,sys::ILMSystem)\n\nThe operation mathbfv = R_f mathbfv_b, which regularizes vector surface data vb onto the grid in the form of scalar grid data v. This is the adjoint to interpolate!\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.interpolate!","page":"Surface-grid operations","title":"ImmersedLayers.interpolate!","text":"interpolate!(f::ScalarData,s::Nodes{Primal},cache::BasicILMCache)\ninterpolate!(f::ScalarData,s::Nodes{Primal},sys::ILMSystem)\n\nThe operation f = R_c^T s, which interpolates scalar grid data s onto the surface points in the form of scalar point data f. This is the adjoint to regularize!\n\n\n\n\n\ninterpolate!(vb::VectorData,v::Edges{Primal},cache::BasicILMCache)\ninterpolate!(vb::VectorData,v::Edges{Primal},sys::ILMSystem)\n\nThe operation mathbfv_b = R_c^T mathbfv, which interpolates vector grid data v onto the surface points in the form of scalar point data vb. This is the adjoint to regularize!\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.regularize_normal!","page":"Surface-grid operations","title":"ImmersedLayers.regularize_normal!","text":"regularize_normal!(v::Edges{Primal},f::ScalarData,cache::BasicILMCache)\nregularize_normal!(v::Edges{Primal},f::ScalarData,sys::ILMSystem)\n\nThe operation mathbfv = R_f mathbfncirc f, which maps scalar surface data f (like a jump in scalar potential) to grid data v (like velocity). This is the adjoint to normal_interpolate!.\n\n\n\n\n\nregularize_normal!(qt::EdgeGradient{Primal},v::VectorData,cache::BasicILMCache)\nregularize_normal!(qt::EdgeGradient{Primal},v::VectorData,sys::ILMSystem)\n\nThe operation mathbfq_t = R_t mathbfncirc mathbfv, which maps scalar vector data v (like a jump in velocity) to grid data qt (like velocity-normal tensor). This is the adjoint to normal_interpolate!.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.normal_interpolate!","page":"Surface-grid operations","title":"ImmersedLayers.normal_interpolate!","text":"normal_interpolate!(vn::ScalarData,v::Edges{Primal},cache::BasicILMCache)\nnormal_interpolate!(vn::ScalarData,v::Edges{Primal},sys::ILMSystem)\n\nThe operation v_n = mathbfn cdot R_f^T mathbfv, which maps grid data v (like velocity) to scalar surface data vn (like normal component of surface velocity). This is the adjoint to regularize_normal!.\n\n\n\n\n\nnormal_interpolate!(τ::VectorData,A::EdgeGradient{Primal},cache::BasicILMCache)\nnormal_interpolate!(τ::VectorData,A::EdgeGradient{Primal},sys::ILMSystem)\n\nThe operation mathbftau = mathbfn cdot R_t^T (mathbfA +mathbfA^T), which maps grid tensor data A (like velocity gradient tensor) to vector surface data τ (like traction). This is the adjoint to regularize_normal!.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.regularize_normal_cross!","page":"Surface-grid operations","title":"ImmersedLayers.regularize_normal_cross!","text":"regularize_normal_cross!(v::Edges{Primal},f::ScalarData,cache::BasicILMCache)\nregularize_normal_cross!(v::Edges{Primal},f::ScalarData,sys::ILMSystem)\n\nThe operation mathbfv = R_f mathbfntimes f mathbfe_z, which maps scalar surface data f (like a jump in streamfunction, endowed with the out-of-plane unit vector mathbfe_z) to grid data v (like velocity). This is the adjoint to normal_cross_interpolate!.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.normal_cross_interpolate!","page":"Surface-grid operations","title":"ImmersedLayers.normal_cross_interpolate!","text":"normal_cross_interpolate!(wn::ScalarData,v::Edges{Primal},cache::BasicILMCache)\nnormal_cross_interpolate!(wn::ScalarData,v::Edges{Primal},sys::ILMSystem)\n\nThe operation w_n = e_zcdot (mathbfn times R_f^T mathbfv), which maps grid data v (like velocity) to scalar surface data wn (like vorticity in the surface). This is the adjoint to regularize_normal!.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.surface_divergence!","page":"Surface-grid operations","title":"ImmersedLayers.surface_divergence!","text":"surface_divergence!(Θ::Nodes{Primal},f::ScalarData,cache::BasicILMCache)\nsurface_divergence!(Θ::Nodes{Primal},f::ScalarData,sys::ILMSystem)\n\nThe operation theta = D_s f = D R_f mathbfn circ f, which maps surface scalar data f (like jump in scalar potential) to grid data Θ (like dilatation, i.e. divergence of velocity). This is the adjoint of surface_grad!. Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\nsurface_divergence!(v::Edges{Primal},dv::VectorData,cache::BasicILMCache)\nsurface_divergence!(v::Edges{Primal},dv::VectorData,sys::ILMSystem)\n\nThe operation mathbfv = D_s dmathbfv = D R_f (mathbfn circ dmathbfv + dmathbfv circ mathbfn), which maps surface vector data dv (like jump in velocity) to grid data v (like velocity). This is the adjoint of surface_grad!. Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.surface_grad!","page":"Surface-grid operations","title":"ImmersedLayers.surface_grad!","text":"surface_grad!(vn::ScalarData,ϕ::Nodes{Primal},cache::BasicILMCache)\nsurface_grad!(vn::ScalarData,ϕ::Nodes{Primal},sys::ILMSystem)\n\nThe operation v_n = G_sphi = mathbfn cdot R_f^T Gphi, which maps grid data ϕ (like scalar potential) to scalar surface data vn (like normal component of velocity). This is the adjoint of surface_divergence!. Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\nsurface_grad!(τ::VectorData,v::Edges{Primal},cache::BasicILMCache)\nsurface_grad!(τ::VectorData,v::Edges{Primal},sys::ILMSystem)\n\nThe operation mathbftau = G_s v = mathbfn cdot R_t^T (G mathbfv + (G mathbfv)^T), which maps grid vector data v (like velocity) to vector surface data τ (like traction). This is the adjoint of surface_divergence!. Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.surface_curl!","page":"Surface-grid operations","title":"ImmersedLayers.surface_curl!","text":"surface_curl!(w::Nodes{Dual},f::ScalarData,cache::BasicILMCache)\nsurface_curl!(w::Nodes{Dual},f::ScalarData,sys::ILMSystem)\n\nThe operation w = C_s^T f = C^T R_f mathbfncirc f, which maps scalar surface data f (like a jump in scalar potential) to grid data w (like vorticity). This is the adjoint to C_s, also given by surface_curl! (but with arguments switched). Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\nsurface_curl!(w::Nodes{Dual},v::VectorData,cache::BasicILMCache)\nsurface_curl!(w::Nodes{Dual},v::VectorData,sys::ILMSystem)\n\nThe operation w = C_s^T mathbfv = C^T R_f mathbfv, which maps vector surface data v (like velocity) to grid data w (like vorticity). This is the adjoint to C_s, also given by surface_curl! (but with arguments switched). Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\nsurface_curl!(vn::ScalarData,s::Nodes{Dual},cache::BasicILMCache)\nsurface_curl!(vn::ScalarData,s::Nodes{Dual},sys::ILMSystem)\n\nThe operation v_n = C_s s = mathbfn cdot R_f^T C s, which maps grid data s (like streamfunction) to scalar surface data vn (like normal component of velocity). This is the adjoint to C_s^T, also given by surface_curl!, but with arguments switched.  Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\nsurface_curl!(v::VectorData,s::Nodes{Dual},cache::BasicILMCache)\nsurface_curl!(v::VectorData,s::Nodes{Dual},sys::ILMSystem)\n\nThe operation mathbfv = C_s s = R_f^T C s, which maps grid data s (like streamfunction) to vector surface data v (like velocity). This is the adjoint to C_s^T, also given by surface_curl!, but with arguments switched.  Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.surface_divergence_cross!","page":"Surface-grid operations","title":"ImmersedLayers.surface_divergence_cross!","text":"surface_divergence_cross!(Θ::Nodes{Primal},f::ScalarData,cache::BasicILMCache)\nsurface_divergence_cross!(Θ::Nodes{Primal},f::ScalarData,sys::ILMSystem)\n\nThe operation theta = hatD_s f = D R_f mathbfn times f mathbfe_z, which maps surface scalar data f (like jump in streamfunction) to grid data Θ (like dilatation, i.e. divergence of velocity). This is the adjoint of surface_grad_cross!. Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.surface_grad_cross!","page":"Surface-grid operations","title":"ImmersedLayers.surface_grad_cross!","text":"surface_grad_cross!(γ::ScalarData,ϕ::Nodes{Primal},cache::BasicILMCache)\nsurface_grad_cross!(γ::ScalarData,ϕ::Nodes{Primal},sys::ILMSystem)\n\nThe operation gamma = hatG_sphi = mathbfe_z cdot (mathbfn times R_f^T Gphi), which maps grid data ϕ (like scalar potential) to scalar surface data γ (like surface vorticity). This is the adjoint of surface_divergence_cross!. Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.surface_curl_cross!","page":"Surface-grid operations","title":"ImmersedLayers.surface_curl_cross!","text":"surface_curl_cross!(w::Nodes{Dual},f::ScalarData,cache::BasicILMCache)\nsurface_curl_cross!(w::Nodes{Dual},f::ScalarData,sys::ILMSystem)\n\nThe operation w = hatC_s^T f = C^T R_f mathbfntimes f mathbfe_z, which maps scalar surface data f (like a jump in streamfunction, multiplied by out-of-plane unit vector mathbfe_z) to grid data w (like vorticity). This is the adjoint to hatC_s, also given by surface_curl_cross! (but with arguments switched). Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\nsurface_curl_cross!(γ::ScalarData,s::Nodes{Dual},cache::BasicILMCache)\nsurface_curl_cross!(γ::ScalarData,s::Nodes{Dual},sys::ILMSystem)\n\nThe operation gamma = hatC_s s = mathbfe_zcdot (mathbfn times R_f^T C s), which maps grid data s (like streamfunction) to scalar surface data γ (like vorticity in the surface). This is the adjoint to hatC_s^T, also given by surface_curl_cross!, but with arguments switched.  Note that the differential operations are divided either by 1 or by the grid cell size, depending on whether sys has been designated with IndexScaling or GridScaling, respectively.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.mask!","page":"Surface-grid operations","title":"ImmersedLayers.mask!","text":"mask!(w::GridData,cache::BasicILMCache)\nmask!(w::GridData,sys::ILMSystem)\n\nMask the data w in place by multiplying it by 1s inside of a surface (i.e., on a side opposite   the normal vectors) and 0s outside. The grid data w must be of the same type as the   output data type of cache. Only allows cache to have GridScaling.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.mask","page":"Surface-grid operations","title":"ImmersedLayers.mask","text":"mask(cache::BasicILMCache) -> GridData\nmask(sys::ILMSystem) -> GridData\n\nCreate grid data that consist of 1s inside of a surface (i.e., on a side opposite   the normal vectors) and 0s outside. The grid data are the same type as the   output data type of sys.  Only allows sys to have GridScaling.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.complementary_mask!","page":"Surface-grid operations","title":"ImmersedLayers.complementary_mask!","text":"complementary_mask!(w::GridData,cache::BasicILMCache)\ncomplementary_mask!(w::GridData,sys::ILMSystem)\n\nMask the data w in place by multiplying it by 0s inside of a surface (i.e., on a side opposite   the normal vectors) and 1s outside. The grid data w must be of the same type as the   output data type of cache. Only allows cache to have GridScaling.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/#ImmersedLayers.complementary_mask","page":"Surface-grid operations","title":"ImmersedLayers.complementary_mask","text":"complementary_mask(cache::BasicILMCache) -> GridData\ncomplementary_mask(sys::ILMSystem) -> GridData\n\nCreate grid data that consist of 0s inside of a surface (i.e., on a side opposite   the normal vectors) and 1s outside. The grid data are the same type as the   output data type of cache.  Only allows cache to have GridScaling.\n\n\n\n\n\n","category":"function"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"","category":"page"},{"location":"manual/surfaceops/","page":"Surface-grid operations","title":"Surface-grid operations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"EditURL = \"<unknown>/literate/caches.jl\"","category":"page"},{"location":"manual/caches/#Immersed-layer-caches","page":"Immersed layer caches","title":"Immersed layer caches","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"This package uses precomputed caches to efficiently implement the immersed layer operators. The starting point for a cache is the specification of the (discretized) body shape and the grid. Let's use an example.","category":"page"},{"location":"manual/caches/#Setting-up-a-cache","page":"Immersed layer caches","title":"Setting up a cache","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"using ImmersedLayers\nusing Plots\nusing LinearAlgebra","category":"page"},{"location":"manual/caches/#Set-up-a-grid","page":"Immersed layer caches","title":"Set up a grid","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"First, we will set up a grid for performing the operations. We use the PhysicalGrid constructor of the CartesianGrids.jl package to create this.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"Δx = 0.01\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx)","category":"page"},{"location":"manual/caches/#Set-the-shape","page":"Immersed layer caches","title":"Set the shape","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"Now let's set a shape to immerse into the grid. We will use a circle, but there are a variety of other shapes available. Many of these are in the RigidBodyTools.jl package. Note that we set the spacing between the points on this shape equal to 1.4 times the grid spacing. This is not critical, but it is generally best to set it to a value between 1 and 2.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"RadC = 1.0\nΔs = 1.4*cellsize(g)\nbody = Circle(RadC,Δs)","category":"page"},{"location":"manual/caches/#Create-the-cache","page":"Immersed layer caches","title":"Create the cache","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"After setting the grid and the surface to immerse, the next step for using the immersed layer tools is to set up a surface cache. This allocates a set of data structures, as well as the critical regularization and interpolation operators that will get used.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"There are a few choices to make when setting this up","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"What kind of data (scalar or vector) are we dealing with?","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"We will demonstrate with scalar data, which means we use the SurfaceScalarCache function. For vector data, use SurfaceVectorCache.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"What type of scaling (grid or index) do we wish to apply to the operators?","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"Grid scaling, set with scaling = GridScaling, means that the various operators are scaled with the physical grid spacing and/or surface point spacing so that they approximate the continuous operators. This means that regularization and interpolation are transposes with respect to inner products that incorporate these physical spacings, rather than the usual linear algebra inner products. Also, differential operations on the grid are true approximations of their continuous counterparts. This choice of scaling is usually the best, and the dot operator is extended in this package to implement the physically- scaled inner products.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"On the other hand, scaling = IndexScaling does not scale these, but rather, uses pure differencing for the grid differential operators, and regularization is the simple matrix transpose of interpolation.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"What discrete Dirac delta function (DDF) do we wish to use?","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"This is specified with the ddftype = keyword argument. The default is CartesianGrids.Yang3 [1]. However, there are other choices, such as CartesianGrids.Roma, CartesianGrids.Goza, CartesianGrids.Witchhat, CartesianGrids.M3, CartesianGrids.M4prime.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"cache = SurfaceScalarCache(body,g,scaling=GridScaling)","category":"page"},{"location":"manual/caches/#Plotting-the-immersed-points","page":"Immersed layer caches","title":"Plotting the immersed points","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"We can plot the immersed points with the plot function of the Plots.jl package, using a special plot recipe. This accepts all of the usual attribute keywords of the basic plot function.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"plot(cache,xlims=(-2,2),ylims=(-2,2))","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"In this plotting demonstration, we have used the points function to obtain the coordinates of the immersed points. Other useful utilities are normals and areas, e.g.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"normals(cache)","category":"page"},{"location":"manual/caches/#Some-basic-utilities","page":"Immersed layer caches","title":"Some basic utilities","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"We will see deeper uses of this cache in Surface-grid operations. However, for now we can learn how to get basic copies of the grid and surface data. For example, a copy of the grid data, all initialized to zero:","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"zeros_grid(cache)","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"or similarly on the surface","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"zeros_surface(cache)","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"We also might need to initialize data on the grid to accept the curl of a vector field. This is used in conjunction with surface_curl!, for example.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"zeros_gridcurl(cache)","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"If we want them initialized to unity, then use","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"ones_grid(cache)","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"and","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"ones_surface(cache)","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"To evaluate functions on the grid, it is useful to be able to fill grid data with the x and y coordinates. For this, we use","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"x_grid(cache)","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"y_grid(cache)","category":"page"},{"location":"manual/caches/#Using-norms-and-inner-products","page":"Immersed layer caches","title":"Using norms and inner products","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"It is useful to compute norms and inner products on grid and surface data. These tools are easily accessible, e.g., dot(u,v,cache) and norm(u,cache), and they respect the scaling associated with the cache. For example, the following gives an approximation of the circumference of the circle:","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"os = ones_surface(cache)\ndot(os,os,cache)","category":"page"},{"location":"manual/caches/#Cache-types-and-constructors","page":"Immersed layer caches","title":"Cache types and constructors","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"BasicILMCache\nSurfaceScalarCache\nSurfaceVectorCache\nAbstractExtraILMCache","category":"page"},{"location":"manual/caches/#ImmersedLayers.BasicILMCache","page":"Immersed layer caches","title":"ImmersedLayers.BasicILMCache","text":"struct BasicILMCache{N, SCA<:AbstractScalingType, ND, BLT<:BodyList, NT<:VectorData, DST<:ScalarData, REGT<:Regularize, RSNT<:RegularizationMatrix, ESNT<:InterpolationMatrix, RT<:RegularizationMatrix, ET<:InterpolationMatrix, LT<:CartesianGrids.Laplacian, GVT, GNT, GCT, SVT, SST}\n\nA cache of operators and storage data for use in surface operations. Constructed with SurfaceScalarCache or SurfaceVectorCache.\n\n\n\n\n\n","category":"type"},{"location":"manual/caches/#ImmersedLayers.SurfaceScalarCache","page":"Immersed layer caches","title":"ImmersedLayers.SurfaceScalarCache","text":"SurfaceScalarCache(g::PhysicalGrid[,scaling=IndexScaling])\n\nCreate a cache of type BasicILMCache with scalar grid data, using the grid specified in g, with no immersed points. The keyword scaling can be used to set the scaling in the operations. By default, it is set to IndexScaling which sets the differential operators to be only differencing operators. By using scaling = GridScaling, then the grid and  spacings are accounted for and differential operators are scaled by this spacing.\n\n\n\n\n\nSurfaceScalarCache(body::Body/BodyList,g::PhysicalGrid[,ddftype=CartesianGrids.Yang3][,scaling=IndexScaling])\n\nCreate a cache of type BasicILMCache, holding operators and storage data for use in immersed layer operations on scalar data. This is sometimes called from withinILMSystem rather than directly.\n\nThe body can be of type Body or BodyList. The keyword scaling can be used to set the scaling in the operations. By default, it is set to IndexScaling which sets the regularization and interpolation to be symmetric matrices (i.e., interpolation is the adjoint of regularization with   respect to a vector dot product), and the vector calculus operations on the grid   are simple differences. By using scaling = GridScaling, then the grid and   point spacings are accounted for. Interpolation and regularization are adjoints   with respect to inner products based on discretized surface and volume integrals,   and vector calculus operations are scaled by the grid spacing.\n\n\n\n\n\nSurfaceScalarCache(X::VectorData,g::PhysicalGrid[,ddftype=CartesianGrids.Yang3][,scaling=IndexScaling])\n\nCreate a cache of type BasicILMCache, holding operators and storage data for use in immersed layer operations on scalar data. The X specifies the immersed point coordinates, and g the physical grid.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.SurfaceVectorCache","page":"Immersed layer caches","title":"ImmersedLayers.SurfaceVectorCache","text":"SurfaceVectorCache(g::PhysicalGrid[,scaling=IndexScaling])\n\nCreate a cache of type BasicILMCache with vector grid data, with no immersed points. See SurfaceScalarCache for details.\n\n\n\n\n\nSurfaceVectorCache(body::Body/BodyList,g::PhysicalGrid[,ddftype=CartesianGrids.Yang3][,scaling=IndexScaling])\n\nCreate a cache of type BasicILMCache, holding operators and storage data for use in immersed layer operations on vector data. See SurfaceScalarCache for details.\n\n\n\n\n\nSurfaceVectorCache(X::VectorData,g::PhysicalGrid[,ddftype=CartesianGrids.Yang3][,scaling=IndexScaling])\n\nCreate a cache of type BasicILMCache, holding operators and storage data for use in immersed layer operations on vector data. See SurfaceScalarCache for details.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.AbstractExtraILMCache","page":"Immersed layer caches","title":"ImmersedLayers.AbstractExtraILMCache","text":"abstract type AbstractExtraILMCache\n\nWhen defining problem-specific cache, make it a subtype of this.\n\n\n\n\n\n","category":"type"},{"location":"manual/caches/#Utilities-for-creating-instances-of-data","page":"Immersed layer caches","title":"Utilities for creating instances of data","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"similar_grid\nsimilar_gridgrad\nsimilar_gridcurl\nsimilar_surface\nzeros_grid\nzeros_gridgrad\nzeros_gridcurl\nzeros_surface\nones_grid\nones_gridgrad\nones_gridcurl\nones_surface\nx_grid\ny_grid\nx_gridcurl\ny_gridcurl","category":"page"},{"location":"manual/caches/#ImmersedLayers.similar_grid","page":"Immersed layer caches","title":"ImmersedLayers.similar_grid","text":"similar_grid(::BasicILMCache)\n\nGet a similar copy of the basic grid data in the cache.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.similar_gridgrad","page":"Immersed layer caches","title":"ImmersedLayers.similar_gridgrad","text":"similar_gridgrad(::BasicILMCache)\n\nGet a similar copy of the gradient of the grid data in the cache.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.similar_gridcurl","page":"Immersed layer caches","title":"ImmersedLayers.similar_gridcurl","text":"similar_gridcurl(::BasicILMCache)\n\nGet a similar copy of the grid curl field data in the cache.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.similar_surface","page":"Immersed layer caches","title":"ImmersedLayers.similar_surface","text":"similar_surface(::BasicILMCache)\n\nGet a similar copy of the basic surface point data in the cache.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.zeros_grid","page":"Immersed layer caches","title":"ImmersedLayers.zeros_grid","text":"zeros_grid(::BasicILMCache)\n\nGet an instance of the basic grid data in the cache, with values set to zero.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.zeros_gridgrad","page":"Immersed layer caches","title":"ImmersedLayers.zeros_gridgrad","text":"zeros_gridgrad(::BasicILMCache,dim)\n\nGet an instance of the gradient of the grid data in the cache, , in direction dim, with values set to zero. If the data are of type TensorGridData, then dim takes values from 1 to 2^2.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.zeros_gridcurl","page":"Immersed layer caches","title":"ImmersedLayers.zeros_gridcurl","text":"zeros_gridcurl(::BasicILMCache)\n\nGet an instance of the grid curl field data in the cache, with values set to zero.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.zeros_surface","page":"Immersed layer caches","title":"ImmersedLayers.zeros_surface","text":"zeros_surface(::BasicILMCache)\n\nGet an instance of the basic surface point data in the cache, with values set to zero.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.ones_grid","page":"Immersed layer caches","title":"ImmersedLayers.ones_grid","text":"ones_grid(::BasicILMCache)\n\nGet an instance of the basic grid data in the cache, with values set to unity.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.ones_gridgrad","page":"Immersed layer caches","title":"ImmersedLayers.ones_gridgrad","text":"ones_gridgrad(::BasicILMCache,dim)\n\nGet an instance of the gradient of the grid data in the cache, in direction dim, with values set to unity. If the data are of type TensorGridData, then dim takes values from 1 to 2^2.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.ones_gridcurl","page":"Immersed layer caches","title":"ImmersedLayers.ones_gridcurl","text":"ones_gridcurl(::BasicILMCache)\n\nGet an instance of the grid curl field data in the cache, with values set to unity.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.ones_surface","page":"Immersed layer caches","title":"ImmersedLayers.ones_surface","text":"ones_surface(::BasicILMCache)\n\nGet an instance of the basic surface point data in the cache, with values set to unity.\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.x_grid","page":"Immersed layer caches","title":"ImmersedLayers.x_grid","text":"x_grid(::BasicILMCache)\n\nReturn basic grid data filled with the grid x coordinate\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.y_grid","page":"Immersed layer caches","title":"ImmersedLayers.y_grid","text":"y_grid(::BasicILMCache)\n\nReturn basic grid data filled with the grid y coordinate\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.x_gridcurl","page":"Immersed layer caches","title":"ImmersedLayers.x_gridcurl","text":"x_gridcurl(::BasicILMCache)\n\nReturn basic grid curl field data filled with the grid x coordinate\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#ImmersedLayers.y_gridcurl","page":"Immersed layer caches","title":"ImmersedLayers.y_gridcurl","text":"y_gridcurl(::BasicILMCache)\n\nReturn basic grid curl field data filled with the grid y coordinate\n\n\n\n\n\n","category":"function"},{"location":"manual/caches/#Utilities-for-accessing-surface-information","page":"Immersed layer caches","title":"Utilities for accessing surface information","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"areas(::BasicILMCache)\nnormals(::BasicILMCache)\npoints(::BasicILMCache)","category":"page"},{"location":"manual/caches/#ImmersedLayers.areas-Tuple{BasicILMCache}","page":"Immersed layer caches","title":"ImmersedLayers.areas","text":"areas(cache::BasicILMCache)\n\nReturn the areas (as ScalarData) of the surface panels associated with cache\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#ImmersedLayers.normals-Tuple{BasicILMCache}","page":"Immersed layer caches","title":"ImmersedLayers.normals","text":"normals(cache::BasicILMCache)\n\nReturn the normals (as VectorData) of the surface points associated with cache\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#ImmersedLayers.points-Tuple{BasicILMCache}","page":"Immersed layer caches","title":"ImmersedLayers.points","text":"points(cache::BasicILMCache)\n\nReturn the coordinates (as VectorData) of the surface points associated with cache\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#Inner-products,-norms,-and-integrals","page":"Immersed layer caches","title":"Inner products, norms, and integrals","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"dot(::GridData,::GridData,::BasicILMCache)\ndot(::PointData,::PointData,::BasicILMCache)\nnorm(::GridData,::BasicILMCache)\nnorm(::PointData,::BasicILMCache)\nintegrate(::ScalarData{N},::BasicILMCache{N}) where {N}\ndot(::PointData,::PointData,::BasicILMCache,::Int)\nnorm(::PointData,::BasicILMCache,::Int)\nintegrate(::ScalarData{N},::BasicILMCache{N},::Int) where {N}","category":"page"},{"location":"manual/caches/#LinearAlgebra.dot-Tuple{GridData, GridData, BasicILMCache}","page":"Immersed layer caches","title":"LinearAlgebra.dot","text":"dot(u1::GridData,u2::GridData,cache::BasicILMCache)\n\nCalculate the inner product of grid data u1 and u2, using the scaling associated with cache.\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#LinearAlgebra.dot-Tuple{PointData, PointData, BasicILMCache}","page":"Immersed layer caches","title":"LinearAlgebra.dot","text":"dot(u1::PointData,u2::PointData,cache::BasicILMCache)\n\nCalculate the inner product of surface point data u1 and u2, using the scaling associated with cache.\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#LinearAlgebra.norm-Tuple{GridData, BasicILMCache}","page":"Immersed layer caches","title":"LinearAlgebra.norm","text":"norm(u::GridData,cache::BasicILMCache)\n\nCalculate the norm of grid data u, using the scaling associated with cache.\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#LinearAlgebra.norm-Tuple{PointData, BasicILMCache}","page":"Immersed layer caches","title":"LinearAlgebra.norm","text":"norm(u::PointData,cache::BasicILMCache)\n\nCalculate the norm of surface point data u, using the scaling associated with cache.\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#CartesianGrids.integrate-Union{Tuple{N}, Tuple{ScalarData{N, T, DT} where {T, DT<:(AbstractVector{T} where T)}, BasicILMCache{N, SCA, ND, BLT, NT, DST, REGT, RSNT, ESNT, RT, ET, LT, GVT, GNT, GCT, SVT, SST} where {SCA<:AbstractScalingType, ND, BLT<:BodyList, NT<:VectorData, DST<:ScalarData, REGT<:Regularize, RSNT<:RegularizationMatrix, ESNT<:InterpolationMatrix, RT<:RegularizationMatrix, ET<:InterpolationMatrix, LT<:CartesianGrids.Laplacian, GVT, GNT, GCT, SVT, SST}}} where N","page":"Immersed layer caches","title":"CartesianGrids.integrate","text":"integrate(u::PointData,cache::BasicILMCache)\n\nCalculate the discrete surface integral of data u on the immersed points in cache. This uses trapezoidal rule quadrature. If u is VectorData, then this returns a vector of the integrals in each coordinate direction. This operation produces the same effect, regardless if cache is set up for GridScaling or IndexScaling. In both cases, the surface element areas are used.\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#LinearAlgebra.dot-Tuple{PointData, PointData, BasicILMCache, Int64}","page":"Immersed layer caches","title":"LinearAlgebra.dot","text":"dot(u1::PointData,u2::PointData,cache::BasicILMCache,i)\n\nCalculate the inner product of surface point data u1 and u2 for body i in the cache cache, scaling as appropriate for this cache.\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#LinearAlgebra.norm-Tuple{PointData, BasicILMCache, Int64}","page":"Immersed layer caches","title":"LinearAlgebra.norm","text":"norm(u::PointData,cache::BasicILMCache,i::Int)\n\nCalculate the norm of surface point data u, using the scaling associated with cache, for body i in the body list of cache.\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#CartesianGrids.integrate-Union{Tuple{N}, Tuple{ScalarData{N, T, DT} where {T, DT<:(AbstractVector{T} where T)}, BasicILMCache{N, SCA, ND, BLT, NT, DST, REGT, RSNT, ESNT, RT, ET, LT, GVT, GNT, GCT, SVT, SST} where {SCA<:AbstractScalingType, ND, BLT<:BodyList, NT<:VectorData, DST<:ScalarData, REGT<:Regularize, RSNT<:RegularizationMatrix, ESNT<:InterpolationMatrix, RT<:RegularizationMatrix, ET<:InterpolationMatrix, LT<:CartesianGrids.Laplacian, GVT, GNT, GCT, SVT, SST}, Int64}} where N","page":"Immersed layer caches","title":"CartesianGrids.integrate","text":"integrate(u::PointData,cache::BasicILMCache,i::Int)\n\nCalculate the discrete surface integral of scalar data u on the immersed points in cache, on body i in the body list in cache. This uses trapezoidal rule quadrature. If u is VectorData, then this returns a vector of the integrals in each coordinate direction. This operation produces the same effect, regardless if cache is set up for GridScaling or IndexScaling. In both cases, the surface element areas are used.\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#Other-cache-utilities","page":"Immersed layer caches","title":"Other cache utilities","text":"","category":"section"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"view(::PointData,::BasicILMCache,::Int)\nRegularizationMatrix(::BasicILMCache,::PointData,::GridData)\nInterpolationMatrix(::BasicILMCache,::GridData,::PointData)","category":"page"},{"location":"manual/caches/#Base.view-Tuple{PointData, BasicILMCache, Int64}","page":"Immersed layer caches","title":"Base.view","text":"view(u::PointData,cache::BasicILMCache,i::Int)\n\nProvide a view of point data u corresponding to body i in the list of bodies in cache.\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#CartesianGrids.RegularizationMatrix-Tuple{BasicILMCache, PointData, GridData}","page":"Immersed layer caches","title":"CartesianGrids.RegularizationMatrix","text":"RegularizationMatrix(cache::BasicILMCache,src::PointData,trg::GridData)\n\nCreate a regularization matrix for regularizing point data of type src to grid data of type trg. (Both src and trg must be appropriately sized for the grid and points in cache.)\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/#CartesianGrids.InterpolationMatrix-Tuple{BasicILMCache, GridData, PointData}","page":"Immersed layer caches","title":"CartesianGrids.InterpolationMatrix","text":"InterpolationMatrix(cache::BasicILMCache,src::GridData,trg::PointData)\n\nCreate a interpolation matrix for regularizing grid data of type src to point data of type trg. (Both src and trg must be appropriately sized for the grid and points in cache.)\n\n\n\n\n\n","category":"method"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"[1]: Yang, X., et al., (2009) \"A smoothing technique for discrete delta functions with application to immersed boundary method in moving boundary simulations,\" J. Comput. Phys., 228, 7821–7836.","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"","category":"page"},{"location":"manual/caches/","page":"Immersed layer caches","title":"Immersed layer caches","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#ImmersedLayers.jl","page":"Home","title":"ImmersedLayers.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"tools for immersing surfaces and their operations in Cartesian grids","category":"page"},{"location":"#Package-objective","page":"Home","title":"Package objective","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The objective of this package is to implement","category":"page"},{"location":"","page":"Home","title":"Home","text":"the tools for regularizing and interpolating data between discretely-represented surfaces and Cartesian grids\ndiscrete Heaviside functions that mask the regions interior or exterior of surfaces\ndiscrete differential operators that immerse surface data into the grid (i.e., \"layers\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"At this time, the package only implements these in two spatial dimensions. The operators and tools are described in detail in [1], but a summary is given below.","category":"page"},{"location":"#Background","page":"Home","title":"Background","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A lot of problems in physics involve surfaces and their interaction with fields in a higher-dimensional space. One way to facilitate this interaction is by \"immersing\" the surface data, as well as the associated operations on these data, into the higher-dimensional space, and similarly, allowing data in the higher-dimensional space to be restricted to the surface. Underlying these is the concept of a \"masked\" field, which takes a certain continuous form on one side of a surface and another form on the other side. A Heaviside function H can be used to write this mathematically [1]:","category":"page"},{"location":"","page":"Home","title":"Home","text":"f = H(chi) f^+ + H(-chi) f^-","category":"page"},{"location":"","page":"Home","title":"Home","text":"where chi is a level set function, taking a positive value on the + side of the surface and negative value on the - side. The chi=0 level set implicitly defines the surface. Also, the gradient of chi is proportional to the unit normal vector, mathbfn. In fact, we can always choose this function so that it is the local normal.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A really neat thing happens when we take a spatial derivative of f. For example, the gradient:","category":"page"},{"location":"","page":"Home","title":"Home","text":"nabla f = H(chi) nabla f^+ + H(-chi) nabla f^- + delta(chi)mathbfn(f^+ - f^-)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, we get a masked form of the gradient fields of f on either side, plus a term involving the jump in f across the surface, times the normal vector, times the Dirac delta function delta(chi). This last factor is the immersion operator: it immerses the surface jump in f into the higher-dimensional space. Other derivatives (e.g., curl, divergence of vector fields) lead to immersion similar terms. If we the divergence of the gradient above, we get a Poisson equation with two immersion terms:","category":"page"},{"location":"","page":"Home","title":"Home","text":"nabla^2 f = H(chi) nabla^2 f^+ + H(-chi) nabla^2 f^- + delta(chi)mathbfn cdot (nabla f^+ - nabla f^-) +  nabla cdot leftdelta(chi)mathbfn(f^+ - f^-) right","category":"page"},{"location":"","page":"Home","title":"Home","text":"The last two terms are single and double layers, in the language of the theory of potentials. Generically, in any partial differential equation, we refer to these terms as immersed layers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"So standard partial differential equations can be adapted for the masked fields, so that the equations are augmented with the surface quantities. Restriction, delta^T(chi), is the transpose of immersion. It arises when we wish to impose constraints on the surface behavior; we can instead apply this constraint to the restricted form of the masked field, e.g., setting it to a prescribed value, f_s, on the surface:","category":"page"},{"location":"","page":"Home","title":"Home","text":"delta^T(chi) f = f_s","category":"page"},{"location":"","page":"Home","title":"Home","text":"In a computational environment, we discretize the fields on both the surface as well as in the higher-dimensional space, so this immersion process involves regularization (the discrete form of immersion) and interpolation (the discrete form of restriction), defined with the help of a discrete version of the Dirac delta function, the \"DDF\". We discretize the higher-dimensional space with the a staggered Cartesian grid, using tools in the CartesianGrids.jl package, which is fully exported by this package. The package also exports RigidBodyTools.jl, which has a variety of tools for creating and transforming bodies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, to regularize surface scalar data to the cell centers of the grid, we use a matrix operator, R_c. Alternatively, for regularizing vector surface data to cell faces, we use R_f. Each of these has a transpose, used for interpolation of the grid data to the surface points, e.g, R_c^T.","category":"page"},{"location":"","page":"Home","title":"Home","text":"When we combine these operations with the standard differential operators on the grid, we get a powerful set of tools for numerically solving PDEs.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package works on Julia 1.4 and above and is registered in the general Julia registry. To install from the REPL, type e.g.,","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add ImmersedLayers","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, in any version, type","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using ImmersedLayers","category":"page"},{"location":"","page":"Home","title":"Home","text":"The plots in this documentation are generated using Plots.jl. You might want to install that, too, to follow the examples.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Eldredge, J. D. (2021) \"A method of immersed layers on Cartesian grids, with application to incompressible flows,\" arXiv:2103.04521.","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"EditURL = \"<unknown>/literate/stokes.jl\"","category":"page"},{"location":"manual/stokes/#Stokes-flow","page":"Stokes flow","title":"Stokes flow","text":"","category":"section"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"Here, we'll demonstrate a solution of the Stokes equations, with Dirichlet (i.e. no-slip) boundary conditions on a surface. The purpose of this case is to demonstrate the use of the tools with vector-valued data – in this case, the fluid velocity field.","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"After taking the curl of the velocity-pressure form of the Stokes equations, the governing equations for this problem can be written as","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"mu nabla^2 omega - nabla times (delta(chi) mathbfsigma) = nablatimes nabla cdot (delta(chi)mathbfSigma)","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"delta^T(chi) mathbfv = overlinemathbfv_b","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"mathbfv = nabla phi + nablatimes psi","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"where psi and phi are the solutions of","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"nabla^2 psi = -omega","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"nabla^2 phi = delta(chi) mathbfncdot mathbfv_b","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"and mathbfSigma = mu (mathbfv_bmathbfn + mathbfn mathbfv_b) is a surface viscous flux tensor; and mathbfv_b = mathbfv_b^+ - mathbfv_b^- and overlinemathbfv_b = (mathbfv_b^+ + mathbfv_b^-)2 are the jump and average of the surface velocities on either side of a surface.","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"We can discretize and combine these equations into a saddle-point form for psi and sigma:","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"beginbmatrixL^2  C_s^T  C_s  0 endbmatrixbeginpmatrix psi  mathbfsigma endpmatrix = beginpmatrix -C D_s mathbfv_b   overlinev_b - G_s L^-1 R mathbfncdot mathbfv_b  endpmatrix","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"Note that L^2 represents the discrete biharmonic operator. (We have absorbed the viscosity mu into the scaling of the problem.)","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"We can easily break this down into algorithmic form by the same block-LU decomposition of other problems. The difference here is that mathbfsigma is vector-valued.","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"using ImmersedLayers\nusing Plots\nusing LinearAlgebra\nusing UnPack","category":"page"},{"location":"manual/stokes/#Set-up-the-extra-cache-and-solve-function","page":"Stokes flow","title":"Set up the extra cache and solve function","text":"","category":"section"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"The problem type takes the usual basic form","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"struct StokesFlowProblem{DT,ST} <: ImmersedLayers.AbstractVectorILMProblem{DT,ST}\n   g :: PhysicalGrid\n   bodies :: BodyList\n   StokesFlowProblem(g::PT,bodies::BodyList;ddftype=CartesianGrids.Yang3,scaling=IndexScaling) where {PT} = new{ddftype,scaling}(g,bodies)\n   StokesFlowProblem(g::PT,body::Body;ddftype=CartesianGrids.Yang3,scaling=IndexScaling) where {PT} = new{ddftype,scaling}(g,BodyList([body]))\nend","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"As with other cases, the extra cache holds additional intermediate data, as well as the Schur complement. We need a few more intermediate variable for this problem. We'll also construct the filtering matrix for showing the traction field.","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"struct StokesFlowCache{SMT,CMT,RCT,DVT,VNT,ST,VFT,FT} <: AbstractExtraILMCache\n   S :: SMT\n   C :: CMT\n   Rc :: RCT\n   dv :: DVT\n   vb :: DVT\n   vprime :: DVT\n   dvn :: VNT\n   sstar :: ST\n   vϕ :: VFT\n   ϕ :: FT\nend","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"Extend the prob_cache function to construct the extra cache","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"function ImmersedLayers.prob_cache(prob::StokesFlowProblem,base_cache::BasicILMCache)\n    S = create_CL2invCT(base_cache)\n    C = create_surface_filter(base_cache)\n\n    dv = zeros_surface(base_cache)\n    vb = zeros_surface(base_cache)\n    vprime = zeros_surface(base_cache)\n\n    dvn = ScalarData(dv)\n    sstar = zeros_gridcurl(base_cache)\n    vϕ = zeros_grid(base_cache)\n    ϕ = Nodes(Primal,sstar)\n\n    Rc = RegularizationMatrix(base_cache,dvn,ϕ)\n\n    StokesFlowCache(S,C,Rc,dv,vb,vprime,dvn,sstar,vϕ,ϕ)\nend","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"And finally, extend the solve function to do the actual solving. This form takes as input the the external and internal velocities on the surface and returns the velocity field, streamfunction field, and surface traction","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"function ImmersedLayers.solve(vsplus,vsminus,prob::StokesFlowProblem,sys::ILMSystem)\n    @unpack extra_cache, base_cache = sys\n    @unpack nrm = base_cache\n    @unpack S, C, Rc, dv, vb, vprime, sstar, dvn, vϕ, ϕ  = extra_cache\n\n    σ = zeros_surface(sys)\n    s = zeros_gridcurl(sys)\n    v = zeros_grid(sys)\n\n    dv .= vsplus-vsminus\n    vb .= 0.5*(vsplus + vsminus)\n\n    # Compute ψ*\n    surface_divergence!(v,dv,sys)\n    curl!(sstar,v,sys)\n    sstar .*= -1.0\n\n    inverse_laplacian!(sstar,sys)\n    inverse_laplacian!(sstar,sys)\n\n    # Adjustment for jump in normal velocity\n    pointwise_dot!(dvn,nrm,dv)\n    regularize!(ϕ,dvn,Rc)\n    inverse_laplacian!(ϕ,sys)\n    grad!(vϕ,ϕ,sys)\n    interpolate!(vprime,vϕ,sys)\n    vprime .= vb - vprime\n\n    # Compute surface velocity due to ψ*\n    curl!(v,sstar,sys)\n    interpolate!(vb,v,sys)\n\n    # Spurious slip\n    vprime .-= vb\n    σ .= S\\vprime\n\n    # Correction streamfunction\n    surface_curl!(s,σ,sys)\n    s .*= -1.0\n    inverse_laplacian!(s,sys)\n    inverse_laplacian!(s,sys)\n\n    # Correct\n    s .+= sstar\n\n    # Assemble the velocity\n    curl!(v,s,sys)\n    v .+= vϕ\n\n    # Filter the traction twice to clean it up a bit\n    σ .= C^2*σ\n\n    return v, s, σ\nend","category":"page"},{"location":"manual/stokes/#Set-up-a-grid-and-body","page":"Stokes flow","title":"Set up a grid and body","text":"","category":"section"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"We'll consider a rectangle here","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"Δx = 0.01\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx)\nΔs = 1.4*cellsize(g)\nbody = Rectangle(0.5,0.25,Δs,shifted=true)","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"Set up the problem and the system","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"prob = StokesFlowProblem(g,body,scaling=GridScaling)\nsys = ImmersedLayers.__init(prob)","category":"page"},{"location":"manual/stokes/#Solve-the-problem","page":"Stokes flow","title":"Solve the problem","text":"","category":"section"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"We will consider the flow generated by two basic motions of the body. In the first, we will simply translate the body to the right at unit velocity. We set the external x velocity to 1 and y velocity to zero. The internal velocity we set to zero.","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"vsplus = zeros_surface(sys)\nvsminus = zeros_surface(sys)\nvsplus.u .= 1.0\nvsplus.v .= 0.0\nnothing #hide","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"Now solve it (and time it)","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"solve(vsplus,vsminus,prob,sys) #hide\n@time v, s, σ = solve(vsplus,vsminus,prob,sys)\nnothing #hide","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"Let's look at the velocity components","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"plot(v,sys)","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"Note that the velocity is zero inside, as desired. Let's look at the streamlines here","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"plot(s,sys)","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"We'll plot the surface traction components, too.","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"plot(σ.u,label=\"σx\")\nplot!(σ.v,label=\"σy\")","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"Now, let's apply a different motion, where we rotate it counter-clockwise at unit angular velocity","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"pts = points(sys)\nvsplus.u .= -pts.v\nvsplus.v .= pts.u\nnothing #hide","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"Solve it again and plot the velocity and streamlines","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"v, s, σ = solve(vsplus,vsminus,prob,sys)\nplot(v,sys)","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"plot(s,sys)","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"","category":"page"},{"location":"manual/stokes/","page":"Stokes flow","title":"Stokes flow","text":"This page was generated using Literate.jl.","category":"page"}]
}
