<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Matrix operators · ImmersedLayers.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ImmersedLayers.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../caches/">Immersed layer caches</a></li><li><a class="tocitem" href="../surfaceops/">Surface-grid operations</a></li><li><a class="tocitem" href="../multbodies/">Multiple bodies</a></li><li><a class="tocitem" href="../gridops/">Grid operations</a></li><li><a class="tocitem" href="../helmholtz/">Helmholtz decomposition</a></li><li class="is-active"><a class="tocitem" href>Matrix operators</a><ul class="internal"><li><a class="tocitem" href="#Matrix-construction-functions"><span>Matrix construction functions</span></a></li></ul></li><li><a class="tocitem" href="../dirichlet/">A Dirichlet Poisson problem</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li></ul></li><li><span class="tocitem">Setting up PDEs</span><ul><li><a class="tocitem" href="../problems/">Problems and the system</a></li><li><a class="tocitem" href="../neumann/">Poisson with Neumann conditions</a></li><li><a class="tocitem" href="../stokes/">Stokes flow</a></li><li><a class="tocitem" href="../heatconduction/">Setting up a time-varying PDE</a></li><li><a class="tocitem" href="../heatconduction-unbounded/">A time-varying PDE with forcing</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Basics</a></li><li class="is-active"><a href>Matrix operators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Matrix operators</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Matrix-operators"><a class="docs-heading-anchor" href="#Matrix-operators">Matrix operators</a><a id="Matrix-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-operators" title="Permalink"></a></h1><p>Many solutions of partial differential equations with immersed layers, particularly Poisson problems, lead to saddle-point problems, in which the Schur complement operator is a matrix composed from some of the surface-grid operators discussed in <a href="../surfaceops/#Surface-grid-operations">Surface-grid operations</a>. The package provides some convenience tools for constructing these matrices. By their nature, the construction of these matrices is slow, since each column involves the application of the same set of operations. However, the point of this construction is to do it once and store it for repeated application.</p><p>One common saddle point system is</p><p class="math-container">\[A = \begin{bmatrix} L &amp; R \\ R^T &amp; 0 \end{bmatrix}\]</p><p>where <span>$L$</span> is the discrete Laplacian and <span>$R$</span> and <span>$R^T$</span> are the regularization and interpolation operators (<a href="../surfaceops/#ImmersedLayers.regularize!"><code>regularize!</code></a> and <a href="../surfaceops/#ImmersedLayers.interpolate!"><code>interpolate!</code></a>), respectively. This system arises in the solution of the Poisson equation with Dirichlet boundary conditions on the immersed surface. The Schur complement of this is <span>$S = - R^T L^{-1} R$</span>. This matrix can be obtained using the function <a href="#ImmersedLayers.create_RTLinvR"><code>create_RTLinvR</code></a>.</p><p>Another common saddle point system is</p><p class="math-container">\[A = \begin{bmatrix} L &amp; D_s \\ G_s &amp; R_n^T R_n \end{bmatrix}\]</p><p>where <span>$D_s$</span> and <span>$G_s$</span> are the surface divergence and gradient operators (<a href="../surfaceops/#ImmersedLayers.surface_divergence!"><code>surface_divergence!</code></a> and <a href="../surfaceops/#ImmersedLayers.surface_grad!"><code>surface_grad!</code></a>), respectively, and <span>$R_n$</span> and <span>$R_n^T$</span> are <a href="../surfaceops/#ImmersedLayers.regularize_normal!"><code>regularize_normal!</code></a> and <a href="../surfaceops/#ImmersedLayers.normal_interpolate!"><code>normal_interpolate!</code></a>. This system arises in the solution of the Poisson equation with Neumann boundary conditions on the immersed surface. The Schur complement of this is <span>$S = R_n^T R_n - G_s L^{-1} D_s$</span>. Each of the matrices in this are individually provided by the package, by the functions <a href="#ImmersedLayers.create_nRTRn"><code>create_nRTRn</code></a> and <a href="#ImmersedLayers.create_GLinvD"><code>create_GLinvD</code></a>, respectively. However, it is useful to know that the sum of these two matrices is exactly the matrix <span>$-C_s L^{-1}C_s^T$</span>, where <span>$C_s$</span> and <span>$C_s^T$</span> are surface curl operators <a href="../surfaceops/#ImmersedLayers.surface_curl!"><code>surface_curl!</code></a>. This complete matrix is provided by <a href="#ImmersedLayers.create_CLinvCT"><code>create_CLinvCT</code></a>.</p><p>Another helpful matrix operator is the surface filter, given by</p><p class="math-container">\[\tilde{R}^T R\]</p><p>where <span>$\tilde{R}^T$</span> is a modified form of the interpolation operator, designed to return the regularized field to the surface points while maintaining the integral value of the original field <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. We can obtain this matrix with <a href="#ImmersedLayers.create_surface_filter"><code>create_surface_filter</code></a>.</p><h2 id="Matrix-construction-functions"><a class="docs-heading-anchor" href="#Matrix-construction-functions">Matrix construction functions</a><a id="Matrix-construction-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-construction-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ImmersedLayers.create_RTLinvR" href="#ImmersedLayers.create_RTLinvR"><code>ImmersedLayers.create_RTLinvR</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_RTLinvR(cache::BasicILMCache[;scale=1.0])</code></pre><p>Using the provided cache <code>cache</code>, construct the square matrix <span>$-R^T L^{-1}R$</span>, which maps data of type <code>ScalarData</code> to data of the same type. The operators <code>R^T</code> and <code>R</code> correspond to <a href="../surfaceops/#ImmersedLayers.interpolate!"><code>interpolate!</code></a> and <a href="../surfaceops/#ImmersedLayers.regularize!"><code>regularize!</code></a> and <code>L^{-1}</code> is the inverse of the grid Laplacian. The optional keyword <code>scale</code> multiplies the matrix by the designated value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/5edaccc54ff21b6e3d61bed2323cd04b4895ae49/src/matrix_operators.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImmersedLayers.create_CLinvCT" href="#ImmersedLayers.create_CLinvCT"><code>ImmersedLayers.create_CLinvCT</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_CLinvCT(cache::BasicILMCache[;scale=1.0])</code></pre><p>Using the provided cache <code>cache</code>, construct the square matrix <span>$-C_s L^{-1}C_s^T$</span>, which maps data of the primary point data type of the cache to data of the same type. The operators <code>C_s</code> and <code>C_s^T</code> correspond to <a href="../surfaceops/#ImmersedLayers.surface_curl!"><code>surface_curl!</code></a> and <code>L</code> is the grid Laplacian. The optional keyword <code>scale</code> multiplies the matrix by the designated value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/5edaccc54ff21b6e3d61bed2323cd04b4895ae49/src/matrix_operators.jl#L32-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImmersedLayers.create_CLinvCT_scalar" href="#ImmersedLayers.create_CLinvCT_scalar"><code>ImmersedLayers.create_CLinvCT_scalar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_CLinvCT_scalar(cache::BasicILMCache[;scale=1.0])</code></pre><p>Using the provided cache <code>cache</code>, construct the square matrix <span>$-C_s L^{-1}C_s^T$</span>, which maps data of the scalar point data type of the cache to data of the same type. The operators <code>C_s</code> and <code>C_s^T</code> correspond to <a href="../surfaceops/#ImmersedLayers.surface_curl!"><code>surface_curl!</code></a> and <code>L</code> is the grid Laplacian. The optional keyword <code>scale</code> multiplies the matrix by the designated value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/5edaccc54ff21b6e3d61bed2323cd04b4895ae49/src/matrix_operators.jl#L63-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImmersedLayers.create_CL2invCT" href="#ImmersedLayers.create_CL2invCT"><code>ImmersedLayers.create_CL2invCT</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_CL2invCT(cache::BasicILMCache[;scale=1.0])</code></pre><p>Using the provided cache <code>cache</code>, construct the square matrix <span>$-C_s L^{-2} C_s^T$</span>, which maps data of the primary point data type of the cache to data of the same type. The operators <code>C_s</code> and <code>C_s^T</code> correspond to <a href="../surfaceops/#ImmersedLayers.surface_curl!"><code>surface_curl!</code></a> and <code>L</code> is the grid Laplacian. The optional keyword <code>scale</code> multiplies the matrix by the designated value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/5edaccc54ff21b6e3d61bed2323cd04b4895ae49/src/matrix_operators.jl#L94-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImmersedLayers.create_GLinvD" href="#ImmersedLayers.create_GLinvD"><code>ImmersedLayers.create_GLinvD</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_GLinvD(cache::BasicILMCache[;scale=1.0])</code></pre><p>Using the provided cache <code>cache</code>, construct the square matrix <span>$-G_s L^{-1}D_s$</span>, which maps data of type <code>ScalarData</code> to data of the same type. The operators <code>G_s</code> and <code>D_s</code> correspond to <a href="../surfaceops/#ImmersedLayers.surface_grad!"><code>surface_grad!</code></a> and <a href="../surfaceops/#ImmersedLayers.surface_divergence!"><code>surface_divergence!</code></a>, and <code>L</code> is the grid Laplacian. The optional keyword <code>scale</code> multiplies the matrix by the designated value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/5edaccc54ff21b6e3d61bed2323cd04b4895ae49/src/matrix_operators.jl#L127-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImmersedLayers.create_GLinvD_cross" href="#ImmersedLayers.create_GLinvD_cross"><code>ImmersedLayers.create_GLinvD_cross</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_GLinvD_cross(cache::BasicILMCache[;scale=1.0])</code></pre><p>Using the provided cache <code>cache</code>, construct the square matrix <span>$-\hat{G}_s L^{-1}\hat{D}_s$</span>, which maps data of type <code>ScalarData</code> to data of the same type. The operators <code>G_s</code> and <code>D_s</code> correspond to <a href="../surfaceops/#ImmersedLayers.surface_grad_cross!"><code>surface_grad_cross!</code></a> and <a href="../surfaceops/#ImmersedLayers.surface_divergence_cross!"><code>surface_divergence_cross!</code></a>, and <code>L</code> is the grid Laplacian. The optional keyword <code>scale</code> multiplies the matrix by the designated value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/5edaccc54ff21b6e3d61bed2323cd04b4895ae49/src/matrix_operators.jl#L187-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImmersedLayers.create_nRTRn" href="#ImmersedLayers.create_nRTRn"><code>ImmersedLayers.create_nRTRn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_nRTRn(cache::BasicILMCache[;scale=1.0])</code></pre><p>Using the provided cache <code>cache</code>, construct the square matrix <span>$n\cdot R_f^T R_f n \circ$</span>, which maps data of type <code>ScalarData</code> to data of the same type. The operators <code>R_f^T</code> and <code>R_f</code> correspond to the interpolation and regularization matrices. The optional keyword <code>scale</code> multiplies the matrix by the designated value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/5edaccc54ff21b6e3d61bed2323cd04b4895ae49/src/matrix_operators.jl#L217-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImmersedLayers.create_surface_filter" href="#ImmersedLayers.create_surface_filter"><code>ImmersedLayers.create_surface_filter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_surface_filter(cache::BasicILMCache)</code></pre><p>Create a surface filtering matrix operator <span>$\tilde{R}^T R$</span>, where <span>$\tilde{R}^T$</span> represents a modified version of the interpolation operator. The resulting matrix can be applied to surface data to filter out high-frequency components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/ImmersedLayers.jl/blob/5edaccc54ff21b6e3d61bed2323cd04b4895ae49/src/matrix_operators.jl#L246-L253">source</a></section></article><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Goza, A., et al., (2016) &quot;Accurate computation of surface stresses and forces with immersed boundary methods,&quot; J. Comput. Phys., 321, 860–873.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../helmholtz/">« Helmholtz decomposition</a><a class="docs-footer-nextpage" href="../dirichlet/">A Dirichlet Poisson problem »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.13 on <span class="colophon-date" title="Monday 28 February 2022 18:04">Monday 28 February 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
